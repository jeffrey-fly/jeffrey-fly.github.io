<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B树索引（postgres）</title>
    <url>/2025/07/10/database/B%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>存储引擎之所以能够快速定位数据，离不开索引。B树索引是历经考验、使用最广泛的一种索引结构。pg中的B树索引是为ordinal data types（可以比较和排序）设计的。</p>
<h2 id="一-结构"><a href="#一-结构" class="headerlink" title="一 结构"></a>一 结构</h2><p>每一个节点就是一个页（Page）。page的大小定义决定了索引node的容量；每个节点（node）由多个element组成（element包括 索引key 和 一个指针）。内部节点中的元素指向下一层的节点；叶子节点中的元素则指向堆中的元组。这种结构就是 PostgreSQL 中 B-Tree 索引的基础：内部节点用于导航，叶子节点保存指向真实数据的引用。</p>
<h2 id="二-特性"><a href="#二-特性" class="headerlink" title="二 特性"></a>二 特性</h2><ol>
<li>有序(Orderable): 所有 B-Tree 索引按照给定的顺序存储值，支持 ASC&#x2F;DESC 和 NULLS FIRST&#x2F;LAST 等排序选项</li>
<li>叶子结点存储数据（key以及tuple的指针），内部结点存储key</li>
<li>每一层除了最有结点，均存储一个高键（high key）：每个节点中最大的值。The first entry in this page contains the high key</li>
<li>叶子页之间有双向链表指针（左兄弟&#x2F;右兄弟），用于范围扫描（BETWEEN、ORDER BY 等范围查询优化）。</li>
</ol>
<h2 id="三-多列索引"><a href="#三-多列索引" class="headerlink" title="三 多列索引"></a>三 多列索引</h2><p>一个索引文件，存储多列键值组合：索引条目（index tuple）中存储这几列的值作为一个组合键。<br>多列索引的比较是逐列进行的，先比较第1列 a，如果相等，再比较第2列 b，依次类推。pg使用逐字段比较器（每列使用其数据类型对应的 &lt; 运算符）逐列比较<br>默认情况下，索引值是按照升序（ASC）排列的，但如果需要，你也可以指定为降序（DESC）。如果索引是基于单列创建的，排序顺序通常无所谓，因为扫描可以沿任意方向进行。但在多列索引中，排序顺序就变得很重要了。</p>
<h3 id="PostgreSQL-多列-B-tree-索引的匹配原则"><a href="#PostgreSQL-多列-B-tree-索引的匹配原则" class="headerlink" title="PostgreSQL 多列 B-tree 索引的匹配原则"></a>PostgreSQL 多列 B-tree 索引的匹配原则</h3><ul>
<li>PostgreSQL 的多列索引（比如 (a, b)）是按列的 最左前缀（left-prefix）顺序构建的。</li>
<li>能有效利用索引的条件，必须从第一列开始匹配，且满足索引的顺序关系。</li>
</ul>
<p>PostgreSQL 多列索引中，当你只指定了“非第一列”的查询条件时，理论上有一种优化方法叫做 Skip Scan:<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_ab ON mytable(a, b);</span><br><span class="line">SELECT * FROM mytable WHERE b = 42;</span><br></pre></td></tr></table></figure>
<p>这个时候由于 没有给出 a 的值，PostgreSQL 的 B-tree 无法用这个索引来直接查找。</p>
<p>但是，理论上如果第一列（a）的取值不多，比如只有 v1, v2, …, vn，查询可以被改写为多次扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHERE a = v1 AND b = 42;</span><br><span class="line">SELECT * FROM mytable WHERE a = v2 AND b = 42;</span><br><span class="line">...</span><br><span class="line">SELECT * FROM mytable WHERE a = vn AND b = 42;</span><br></pre></td></tr></table></figure>
<p>每次都能利用索引 (a, b) 的“最左前缀”性质进行查找，然后再合并结果。这就是 Skip Scan 的思路。</p>
<p>PostgreSQL 当前 不支持 Skip Scan</p>
<h2 id="四-include"><a href="#四-include" class="headerlink" title="四 include"></a>四 include</h2><p>B-tree 索引还可以通过 INCLUDE 子句扩展额外的列，这些列不参与查找，但可以包含在索引中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_ab_inc ON t(a, b) INCLUDE (c, d);</span><br></pre></td></tr></table></figure>
<p>这样可以使某些 SELECT 查询满足 Index-Only Scan（覆盖索引），避免回表. 类似于mysql 的聚族索引（和聚族索引不同的是：include属于冗余存储）</p>
<h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> SELECT p.name,</span><br><span class="line">       pg_index_has_property(&#x27;flights_pkey&#x27;, p.name)</span><br><span class="line">FROM unnest(array[</span><br><span class="line">  &#x27;clusterable&#x27;,</span><br><span class="line">  &#x27;index_scan&#x27;,</span><br><span class="line">  &#x27;bitmap_scan&#x27;,</span><br><span class="line">  &#x27;backward_scan&#x27;</span><br><span class="line">]) p(name);</span><br><span class="line"></span><br><span class="line">      name        | pg_index_has_property</span><br><span class="line">------------------+-----------------------</span><br><span class="line"> clusterable      | t</span><br><span class="line"> index_scan       | t</span><br><span class="line"> bitmap_scan      | t</span><br><span class="line"> backward_scan    | t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="clusterable"><a href="#clusterable" class="headerlink" title="clusterable"></a>clusterable</h3><p>clusterable 表示索引是否支持用于 CLUSTER 操作。<br>CLUSTER 命令会按照指定的索引顺序，对表中的数据行进行物理重排，让表的数据页顺序与索引顺序一致。<br>这样可以提高基于该索引的扫描性能，因为数据的物理顺序和索引顺序相同，减少随机 I&#x2F;O。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLUSTER my_table USING my_index;</span><br></pre></td></tr></table></figure>
<ul>
<li>会根据 my_index 的顺序，重新排列 my_table 的物理存储。</li>
<li>聚簇后的表，在按该索引扫描时性能更好</li>
</ul>
<h4 id="影响和注意点"><a href="#影响和注意点" class="headerlink" title="影响和注意点"></a>影响和注意点</h4><ul>
<li>聚簇是一次性操作，执行后数据会按索引顺序存储，但后续的 INSERT、UPDATE 可能打乱这个顺序。</li>
<li>如果表数据频繁更新，聚簇效果会逐渐减弱，需要定期重新执行 CLUSTER。</li>
<li>聚簇对大表的操作比较重，执行时表会被锁。</li>
</ul>
<h3 id="index-scan"><a href="#index-scan" class="headerlink" title="index_scan"></a>index_scan</h3><p>索引是否支持普通的 Index Scan（例如 WHERE id &#x3D; 123）</p>
<h3 id="bitmap-scan"><a href="#bitmap-scan" class="headerlink" title="bitmap_scan"></a>bitmap_scan</h3><p>Bitmap Scan 是 PostgreSQL 查询计划中的一种索引访问方法，主要用于当多个条件组合过滤时，或者单个索引扫描返回大量行时，提高访问效率的技术。<br>它分两步完成：</p>
<ol>
<li>Bitmap Index Scan：先扫描索引，找到所有符合条件的行的 TID（物理行指针），把它们用一个“位图”（bitmap）来表示；</li>
<li>Bitmap Heap Scan：再根据这个位图去访问表的 heap 页，只读取需要的行，避免全表扫描。</li>
</ol>
<h4 id="为什么要用-Bitmap-Scan？"><a href="#为什么要用-Bitmap-Scan？" class="headerlink" title="为什么要用 Bitmap Scan？"></a>为什么要用 Bitmap Scan？</h4><ol>
<li>当单个条件筛选出的行比较多时，普通索引扫描会频繁跳页，导致随机 I&#x2F;O 增加。</li>
<li>多个条件联合过滤时，可以对多个索引分别做 Bitmap Index Scan，合并位图后再访问表。</li>
<li>通过先用位图标记符合条件的行，再按物理顺序访问表页，减少随机访问，提高缓存命中率。</li>
</ol>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>适合返回大量结果的索引查询；</li>
<li>通过减少随机访问，降低 I&#x2F;O；</li>
<li>支持多个索引结果合并，提高复杂查询效率。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>需要额外的内存存储位图，位图过大会消耗较多资源；</li>
<li>对于返回行很少的查询，普通索引扫描往往更快。</li>
</ol>
<h3 id="backward-scan"><a href="#backward-scan" class="headerlink" title="backward_scan"></a>backward_scan</h3><p>即索引扫描支持双向遍历：可以从索引的左端（最小键）开始向右扫描，也可以从索引的右端（最大键）开始向左扫描。例如 ORDER BY id DESC 时利用该索引</p>
<h2 id="关于索引膨胀"><a href="#关于索引膨胀" class="headerlink" title="关于索引膨胀"></a>关于索引膨胀</h2><p>索引可能会随着插入和删除不断膨胀，而不会自然收缩，需要通过重建或 REINDEX 来处理。</p>
<ol>
<li>当需要向节点中插入数据而发现节点已满时，PostgreSQL 会先尝试“修剪”冗余数据（例如：删除已过期或无效的元组），希望通过回收空间来避免进一步拆分。</li>
<li>在 PostgreSQL 的 B-tree 实现中，节点一旦因为插入新数据而被拆分，就不会再被合并回来。哪怕后续通过 vacuum 操作清理了旧数据，节点中元素数量减少，也不会自动合并。</li>
<li>标准的 B-tree 数据结构理论上是支持合并操作的（比如删除数据后可合并空节点），但 PostgreSQL 的实现为了简化逻辑或出于性能原因，没有实现这一特性</li>
</ol>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>postgres internals 14</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft协议</title>
    <url>/2025/01/15/database/Raft%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Raft 是一个分布式一致性算法，被设计为比 Paxos 更易于理解，同时具备相似的性能和安全性。它常用于构建容错的分布式系统，确保多个节点在面对网络分区、节点失效等情况下能够达成一致</p>
<h2 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h2><ol>
<li>Leader选举：通过选举机制确保每个时间段只有一个节点（Leader）负责日志复制和状态变更。</li>
<li>日志复制：Leader 将客户端的操作（日志）复制到其他节点（Follower），确保日志的一致性。</li>
<li>状态机一致性：通过确保所有节点按相同顺序应用日志，实现一致性。</li>
</ol>
<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="1-角色"><a href="#1-角色" class="headerlink" title="1. 角色"></a>1. 角色</h3><ul>
<li>Leader：负责接收客户端请求，将操作以日志形式写入并同步给 Follower。</li>
<li>Follower：响应 Leader 的同步请求，被动地接受 Leader 的日志和指令。</li>
<li>Candidate：在 Leader 失效后，由 Follower 转为 Candidate，通过投票选举自己为新 Leader。</li>
</ul>
<h3 id="2-选举过程"><a href="#2-选举过程" class="headerlink" title="2. 选举过程"></a>2. 选举过程</h3><ul>
<li>若 Follower 超时未收到 Leader 的心跳信号，会转为 Candidate 并发起选举。</li>
<li>每个节点在选举期间投票给自己，同时请求其他节点投票。</li>
<li>如果一个 Candidate 获得了超过半数的投票，则成为 Leader。</li>
</ul>
<h3 id="3-日志复制"><a href="#3-日志复制" class="headerlink" title="3. 日志复制"></a>3. 日志复制</h3><ul>
<li>Leader 接收到客户端请求后，将其作为日志条目添加到自己的日志中。</li>
<li>Leader 使用 AppendEntries RPC 将日志复制到 Follower。</li>
<li>当多数节点确认日志条目后，Leader 将日志提交，并通知所有节点应用日志到状态机。</li>
</ul>
<h3 id="4-一致性保证"><a href="#4-一致性保证" class="headerlink" title="4. 一致性保证"></a>4. 一致性保证</h3><ul>
<li>使用 任期号（Term） 防止陈旧的 Leader 发出无效指令。</li>
<li>确保日志条目在所有节点上按照相同顺序出现，避免状态不一致。</li>
</ul>
<h2 id="扩展：MultiRaft协议"><a href="#扩展：MultiRaft协议" class="headerlink" title="扩展：MultiRaft协议"></a>扩展：MultiRaft协议</h2><p>MultiRaft 是 Raft 的一种扩展，旨在支持多个 Raft 实例同时运行，以便在大规模分布式系统中更高效地管理数据分片和分布式事务。</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ol>
<li>单个 Raft 实例在处理大量数据时可能成为瓶颈。</li>
<li>在分布式系统中，通常需要对数据进行分区，每个分区由独立的一组节点管理。</li>
<li>MultiRaft 提供了一种机制，通过运行多个 Raft 实例，每个实例负责一部分数据，从而提高系统的吞吐量和扩展性</li>
</ol>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li>多实例并行运行：</li>
</ol>
<ul>
<li>每个 Raft 实例管理一个独立的数据分片（shard）。</li>
<li>每个实例有自己的 Leader、Follower 和日志，独立运行 Raft 协议。</li>
</ul>
<ol start="2">
<li>共享底层资源：</li>
</ol>
<ul>
<li>多个 Raft 实例可以运行在相同的物理节点上，共享网络、存储和 CPU 等资源。</li>
<li>使用高效的调度机制协调实例间的资源竞争。</li>
</ul>
<ol start="3">
<li>动态分片和迁移：</li>
</ol>
<ul>
<li>数据分片可以动态调整，每个分片由一个 Raft 实例管理。</li>
<li>分片可以在节点之间迁移，以应对节点故障或负载不均。</li>
</ul>
<ol start="4">
<li>跨分片操作：</li>
</ol>
<ul>
<li>支持分布式事务，需要在多个 Raft 实例之间协调。</li>
<li>一般通过两阶段提交（2PC）或共识组间通信来实现。</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>Raft</th>
<th>MultiRaft</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>提供单一一致性机制</td>
<td>提供分区一致性机制</td>
</tr>
<tr>
<td>运行实例</td>
<td>单个 Raft 集群</td>
<td>多个独立的 Raft 集群</td>
</tr>
<tr>
<td>适用场景</td>
<td>小规模系统</td>
<td>大规模分布式存储或事务场景</td>
</tr>
<tr>
<td>扩展性</td>
<td>有限,单点可能成为瓶颈</td>
<td>高扩展性，分片机制避免瓶颈</td>
</tr>
<tr>
<td>复杂度</td>
<td>较低</td>
<td>较高，需要处理跨分片事务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>TPCC</title>
    <url>/2025/06/04/database/TPCC/</url>
    <content><![CDATA[<ol>
<li>ER digram:<br><img src="/images/TPCC/823c7b37-30c8-4241-a074-f1f603c396af.png" alt="TPCC"></li>
</ol>
]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>innodb and heap table</title>
    <url>/2025/10/25/database/innodb-and-pg/</url>
    <content><![CDATA[<p>昨日和同事探讨了一下pg与mysql，发现对于mysql的innodb存储引擎了解甚少，正好周末，深入学习了解了一下，整理一下这两天学到的东西。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>InnoDB：MySQL 的主要存储引擎<br>heap table：postgres数据库P表在物理上的存储（Heap File）</p>
<h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><h3 id="innodb-底层存储"><a href="#innodb-底层存储" class="headerlink" title="innodb 底层存储"></a>innodb 底层存储</h3><p>innodb是一个基于聚簇索引（Clustered Index）的存储引擎。</p>
<h4 id="数据存储方式-1"><a href="#数据存储方式-1" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><ul>
<li>聚簇索引存储表数据  <ul>
<li>表的主键索引就是数据本身的物理存储顺序。</li>
<li>每个页（page）一般 16KB，页内数据按主键顺序排列。</li>
<li>非主键列数据和行信息都在叶子节点。</li>
</ul>
</li>
<li>二级索引<ul>
<li>非主键索引存储的是主键值而不是行指针。</li>
<li>查询非主键列时，需要先通过二级索引拿到主键，再去主键聚簇索引里查数据（回表，row lookup）。</li>
</ul>
</li>
</ul>
<h4 id="页与数据组织"><a href="#页与数据组织" class="headerlink" title="页与数据组织"></a>页与数据组织</h4><ul>
<li>数据按 B+ 树页组织。</li>
<li>插入&#x2F;更新可能导致页分裂。</li>
</ul>
<h3 id="postgres-heap-table"><a href="#postgres-heap-table" class="headerlink" title="postgres heap table"></a>postgres heap table</h3><h4 id="数据存储方式-2"><a href="#数据存储方式-2" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><ul>
<li>数据按插入顺序存放，没有聚簇索引。</li>
<li>行标识符 TID（tuple id） 用于指向表的页和行。</li>
<li>页（默认 8KB）内存储多行 tuple。</li>
<li>没有聚簇索引，非索引扫描可能会更慢，但插入非常快。</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>B+ 树、哈希、GIN、GiST 等索引都是附加结构，存储独立于表。</li>
<li>回表操作是通过 TID 定位行。</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>PostgreSQL 堆表</th>
</tr>
</thead>
<tbody><tr>
<td>数据组织</td>
<td>聚簇索引（主键决定物理顺序）</td>
<td>堆表，顺序插入</td>
</tr>
<tr>
<td>主键访问</td>
<td>快（顺序扫描&#x2F;范围查询）</td>
<td>需要 B+ 树索引或全表扫描</td>
</tr>
<tr>
<td>二级索引访问</td>
<td>回表（先索引后主键查行）</td>
<td>回表（索引 -&gt; TID -&gt; 行）</td>
</tr>
<tr>
<td>插入性能</td>
<td>如果主键顺序插入快，否则可能页分裂</td>
<td>快，顺序写入，几乎不分裂</td>
</tr>
<tr>
<td>更新&#x2F;删除</td>
<td>支持 in-place 更新，但大行更新可能迁移</td>
<td>创建新行，旧行留存，需要 vacuum</td>
</tr>
<tr>
<td>MVCC</td>
<td>Undo log + hidden columns</td>
<td>xmin&#x2F;xmax + heap tuple</td>
</tr>
<tr>
<td>表膨胀</td>
<td>自动管理页空间</td>
<td>容易膨胀，需要 vacuum</td>
</tr>
<tr>
<td>查询优化</td>
<td>聚簇索引优化范围查询</td>
<td>多依赖索引，或者全表扫描</td>
</tr>
</tbody></table>
<p>因为pg的存储结构导致访问数据，多了许多随机io：从索引到数据文件。导致pg的查询性能不如innnodb</p>
<h3 id="pg的一些优化"><a href="#pg的一些优化" class="headerlink" title="pg的一些优化"></a>pg的一些优化</h3><h4 id="CLUSTER-命令（物理重排）"><a href="#CLUSTER-命令（物理重排）" class="headerlink" title="CLUSTER 命令（物理重排）"></a>CLUSTER 命令（物理重排）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLUSTER t USING idx_id;</span><br></pre></td></tr></table></figure>
<p>把表物理顺序按照索引顺序重排 —— 效果类似 InnoDB 聚簇索引。<br>缺点：</p>
<ul>
<li>是离线操作；</li>
<li>之后新插入的行会破坏顺序（除非周期性 recluster）</li>
</ul>
<h4 id="索引仅扫描（Index-Only-Scan）"><a href="#索引仅扫描（Index-Only-Scan）" class="headerlink" title="索引仅扫描（Index Only Scan）"></a>索引仅扫描（Index Only Scan）</h4><p>如果查询的字段都在索引里且可见性检查通过（可见性 map 中标记为 all-visible），可以不访问堆表，直接从索引返回结果。</p>
<h4 id="BRIN-索引"><a href="#BRIN-索引" class="headerlink" title="BRIN 索引"></a>BRIN 索引</h4><p>BRIN 全称是 Block Range INdex，是一种 非常轻量级的索引，设计理念与 B-Tree 不同：<br>不是存储每一行的索引它只存储堆表的一段范围（block range）内的最小值和最大值等摘要信息。每个 BRIN 索引条目覆盖 多个物理数据页（例如 128 个 8KB 页面 &#x3D; 1MB 的行数据）。<br>通过这些范围信息，可以快速排除不可能匹配的块，再去 heap 查找具体 tuple。<br>简单理解：BRIN 是“粗粒度索引”，通过块范围（block range）而非单行建立索引<br>非常适合 大表 + 顺序或局部相关数据：大表 + 顺序或局部相关数据：</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 查看指令</title>
    <url>/2024/12/24/debug/gdb-%E6%9F%A5%E7%9C%8B%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="使用-x-命令和内存地址："><a href="#使用-x-命令和内存地址：" class="headerlink" title="使用 x 命令和内存地址："></a>使用 x 命令和内存地址：</h2><p>x (examine) 命令允许你检查内存中的数据。你可以指定要检查的内存地址、格式和单位。</p>
<p>基本语法： x &#x2F;nfu addr</p>
<ul>
<li><p>n：要显示的单位数量。</p>
</li>
<li><p>f：显示格式（例如，x 表示十六进制，t 表示二进制，d 表示十进制）。</p>
</li>
<li><p>u：单位大小（b 表示字节，h 表示半字（16 位），w 表示字（32 位），g 表示巨字（64 位））。</p>
</li>
<li><p>addr：要检查的内存地址。</p>
</li>
</ul>
<p>示例： 假设有一个 32 位整数 val，其地址为 0x12345678，你想以 16 位为单位查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x /2ht 0x12345678</span><br></pre></td></tr></table></figure>

<p>这将显示从 0x12345678 开始的两个半字（16 位）的十六进制值。</p>
<p>结合 p 命令获取地址： 你可以使用 p &amp;变量名 获取变量的地址，然后将其传递给 x 命令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;val = 0x%x\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并用 GDB 调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o <span class="built_in">test</span></span><br><span class="line">gdb ./test</span><br></pre></td></tr></table></figure>
<p>在 GDB 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) p &amp;val</span><br><span class="line"><span class="variable">$1</span> = (int *) 0x7fffffffe0dc</span><br><span class="line">(gdb) x /2ht 0x7fffffffe0dc</span><br><span class="line">0x7fffffffe0dc: 0x5678  0x1234</span><br></pre></td></tr></table></figure>
<p>这里注意字节序，在小端序机器上，低位字节在前，高位字节在后，所以显示为 0x5678 0x1234。<br>如果想要二进制显示，则使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x /2ht 0x7fffffffe0dc</span><br><span class="line">0x7fffffffe0dc: 0101011001111000        0001001000110100</span><br></pre></td></tr></table></figure>

<h2 id="使用表达式和位运算（对于变量值）："><a href="#使用表达式和位运算（对于变量值）：" class="headerlink" title="使用表达式和位运算（对于变量值）："></a>使用表达式和位运算（对于变量值）：</h2><p>如果你只想查看变量的值，而不需要查看内存，可以使用 C 语言的位运算来提取 16 位部分，然后使用 p&#x2F;t 显示。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int val = 0x12345678;</span><br></pre></td></tr></table></figure>
<p>在 GDB 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p/t (val &amp; 0xFFFF) // 获取低 16 位</span><br><span class="line"><span class="variable">$1</span> = 0101011001111000</span><br><span class="line">(gdb) p/t ((val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0</span>xFFFF) // 获取高 <span class="number">16</span> 位</span><br><span class="line"><span class="variable">$2</span> = <span class="number">0001001000110100</span></span><br></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>对于查看内存中的数据（包括变量在内存中的表示），使用 x 命令结合 h (半字) 和 t (二进制) 格式指定符是最直接的方法。<br>对于只查看变量的值，使用位运算提取 16 位部分，然后使用 p&#x2F;t 也是一个有效的选择。<br>选择哪种方法取决于你的具体需求。如果你需要查看变量在内存中的布局（例如，在结构体或数组中），x 命令是更好的选择。如果你只需要查看变量值的不同部分，位运算可能更方便。</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use asan in linux</title>
    <url>/2025/03/16/debug/How-to-use-asan-in-linux/</url>
    <content><![CDATA[<h2 id="1-安装编译工具"><a href="#1-安装编译工具" class="headerlink" title="1. 安装编译工具"></a>1. 安装编译工具</h2><p>ASan 是 GCC 和 Clang 内建的功能，无需额外安装 ASan，只需要你的编译器支持即可。GCC ≥ 4.8 &#x2F; Clang ≥ 3.1 就支持 ASan  </p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@lavm-bar1guved6:~# clang --version</span><br><span class="line">Ubuntu clang version 14.0.0-1ubuntu1.1</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line"></span><br><span class="line">root@lavm-bar1guved6:~# gcc --version</span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="2-how-to-use"><a href="#2-how-to-use" class="headerlink" title="2. how to use"></a>2. how to use</h2><h3 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -g your_file.c -o your_program</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="使用cmake"><a href="#使用cmake" class="headerlink" title="使用cmake"></a>使用cmake</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译阶段（C/C++）加 ASan 插桩</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> -fsanitize=address -fno-omit-frame-pointer -g&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -fsanitize=address -fno-omit-frame-pointer -g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接阶段链接 libasan</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -fsanitize=address&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;</span> -fsanitize=address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">cmake -DCMAKE_C_FLAGS=<span class="string">&quot;-fsanitize=address -fno-omit-frame-pointer -g&quot;</span> \</span><br><span class="line">    -DCMAKE_EXE_LINKER_FLAGS=<span class="string">&quot;-fsanitize=address&quot;</span> \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Debug \</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="使用-Makefile"><a href="#使用-Makefile" class="headerlink" title="使用 Makefile"></a>使用 Makefile</h3><p>可以在 CFLAGS 中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CFLAGS += -fsanitize=address -g -fno-omit-frame-pointer</span><br><span class="line">LDFLAGS += -fsanitize=address</span><br></pre></td></tr></table></figure>
<h3 id="使用-LSAN（泄漏检测）"><a href="#使用-LSAN（泄漏检测）" class="headerlink" title="使用 LSAN（泄漏检测）"></a>使用 LSAN（泄漏检测）</h3><p>GCC 和 Clang 中 ASan 自动包含 LeakSanitizer（LSan），但某些情况下要确保：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fsanitize=address -fno-omit-frame-pointer</span><br></pre></td></tr></table></figure>
<p>加上 -fno-omit-frame-pointer 可以让调用栈更完整。</p>
<h2 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3. 运行程序"></a>3. 运行程序</h2><p>编译好的程序可以直接运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./your_program</span><br></pre></td></tr></table></figure>
<h2 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=detect_leaks=1:halt_on_error=0:symbolize=1:quarantine_size=1024:log_path=/home/postgres/asan/asan.log</span><br></pre></td></tr></table></figure>
<h2 id="5-Example"><a href="#5-Example" class="headerlink" title="5. Example"></a>5. Example</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==791265==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 1024 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7f6fcee65887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x55adcdfee87a in main /home/postgres/codes/sample/epoll_server.c:54</span><br><span class="line">    #2 0x7f6fcebb1d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 1024 byte(s) leaked in 1 allocation(s).</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试改变返回值</title>
    <url>/2025/01/23/debug/gdb%E8%B0%83%E8%AF%95%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 GDB 调试时，有时候需要修改返回值，但是返回值有时候无法直接使用p修改，如std::list::empty(); 如何修改标准库的empty函数返回值呢？</p>
<h2 id="修改寄存器值"><a href="#修改寄存器值" class="headerlink" title="修改寄存器值"></a>修改寄存器值</h2><p>函数的返回值通常存储在特定寄存器中（例如，x86-64 架构中是 %rax）。在函数返回之前，你可以修改 %rax 的值。</p>
<p>步骤：</p>
<ol>
<li>在函数返回之前设置断点（如 ret 指令处）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b *func+&lt;offset&gt; # 偏移地址为即将返回的位置</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.运行程序并等待断点触发<br>3.修改返回值所在的寄存器（例如 %rax）：</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2025/08/05/debug/io/</url>
    <content><![CDATA[<h2 id="确认-I-O-是否是瓶颈，需要从多个角度综合判断，-瓶颈可能体现在磁盘、文件系统甚至内核调度上。"><a href="#确认-I-O-是否是瓶颈，需要从多个角度综合判断，-瓶颈可能体现在磁盘、文件系统甚至内核调度上。" class="headerlink" title="确认 I&#x2F;O 是否是瓶颈，需要从多个角度综合判断， 瓶颈可能体现在磁盘、文件系统甚至内核调度上。"></a>确认 I&#x2F;O 是否是瓶颈，需要从多个角度综合判断， 瓶颈可能体现在磁盘、文件系统甚至内核调度上。</h2><h3 id="1-使用系统工具监控-I-O"><a href="#1-使用系统工具监控-I-O" class="headerlink" title="1. 使用系统工具监控 I&#x2F;O"></a>1. 使用系统工具监控 I&#x2F;O</h3><h4 id="Linux-常用："><a href="#Linux-常用：" class="headerlink" title="Linux 常用："></a>Linux 常用：</h4><ol>
<li><p><strong><code>iostat</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>%util</code> 高接近 100% → 磁盘基本饱和。</li>
<li><code>await</code> 高 → 每次 I&#x2F;O 延迟大。</li>
<li><code>r/s</code> 和 <code>w/s</code> → 每秒读写次数，衡量吞吐能力。</li>
</ul>
</li>
<li><p><strong><code>iotop</code></strong></p>
<ul>
<li>实时显示哪个进程在进行 I&#x2F;O 以及占用的 I&#x2F;O 带宽。</li>
<li>可以确认是单个进程占用过多 I&#x2F;O 还是多个进程平均分摊。</li>
</ul>
</li>
<li><p><strong><code>vmstat</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bi</code>&#x2F;<code>bo</code> 字段表示每秒块设备读写量。</li>
<li><code>wa</code> 字段表示 CPU 等待 I&#x2F;O 的百分比，高的话说明 I&#x2F;O 成为 CPU 等待瓶颈。</li>
</ul>
</li>
<li><p><strong><code>dstat</code> &#x2F; <code>perf stat</code></strong></p>
<ul>
<li>更细粒度监控吞吐量、延迟和上下文切换。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-检查磁盘吞吐能力"><a href="#2-检查磁盘吞吐能力" class="headerlink" title="2. 检查磁盘吞吐能力"></a>2. 检查磁盘吞吐能力</h3><ul>
<li><p>测试磁盘最大写入带宽：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/tmp/testfile bs=1M count=1024 oflag=direct</span><br></pre></td></tr></table></figure>

<ul>
<li><code>oflag=direct</code> 避免缓存干扰。</li>
<li>如果测试带宽接近你程序的写入量，磁盘可能就是瓶颈。</li>
</ul>
</li>
<li><p>同理，可以测试并发读写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fio --name=randrw --rw=randrw --bs=4k --size=1G --numjobs=10 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fio</code> 可以模拟多线程读写负载，测出 IOPS 和吞吐量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-观察系统行为"><a href="#3-观察系统行为" class="headerlink" title="3. 观察系统行为"></a>3. 观察系统行为</h3><ul>
<li><p><strong>CPU vs I&#x2F;O 时间</strong>：</p>
<ul>
<li><code>top</code> 或 <code>perf top</code> 中如果 CPU 很空闲，程序主要在等待 I&#x2F;O → I&#x2F;O 瓶颈。</li>
</ul>
</li>
<li><p><strong>延迟累积</strong>：</p>
<ul>
<li>如果程序写入文件很慢，但 CPU 使用低且磁盘高负载 → 瓶颈在 I&#x2F;O。</li>
</ul>
</li>
<li><p><strong>锁与等待</strong>：</p>
<ul>
<li>并发写入时，文件系统锁、页缓存锁也会引入“假 I&#x2F;O 瓶颈”，需要 <code>perf trace</code> 或 <code>blktrace</code> 排查。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 异步调试</title>
    <url>/2024/11/11/debug/nonstop/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> target-async 1 </span><br><span class="line"><span class="built_in">set</span> pagination off </span><br><span class="line"><span class="built_in">set</span> non-stop on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> object on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> static-members on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> demangle on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> sevenbit-strings off</span><br><span class="line"></span><br><span class="line">python </span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(0,<span class="string">&#x27;/usr/share/gcc-4.8.2/python*) </span></span><br><span class="line"><span class="string">from libstdcxx.v6.printers import register_libstdcxx_printers</span></span><br><span class="line"><span class="string">register_libstdcxx_printers (None)</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>分析tcmalloc 内存增长 —- pprof</title>
    <url>/2024/10/27/debug/pprof/</url>
    <content><![CDATA[<p>有时候程序莫名内存上涨厉害，但不是泄漏，如何定位哪申请使用的大量内存呢？</p>
<p>如果没使用tcmalloc，使用heaptrack工具（git clone <a href="https://github.com/KDE/heaptrack.git%EF%BC%89%EF%BC%9B">https://github.com/KDE/heaptrack.git）；</a></p>
<p>如果使用了tcmalloc，可以通过tcmalloc自带的工具来分析</p>
<h2 id="一-工具"><a href="#一-工具" class="headerlink" title="一 工具"></a>一 工具</h2><ol>
<li>tcmalloc</li>
<li>pprof</li>
</ol>
<p>pprof相当于分析器，阅读器，分析阅读的内容为heap文件，内容包括  </p>
<ul>
<li>每个活跃分配的大小</li>
<li>分配的调用栈</li>
<li>分配次数</li>
</ul>
<h2 id="二-生成heap文件"><a href="#二-生成heap文件" class="headerlink" title="二 生成heap文件"></a>二 生成heap文件</h2><ul>
<li><p>手动<br>在程序的入口或需要开始分析的地方，添加 HeapProfilerStart(“文件路径”)。<br>在程序结束或需要停止分析的地方，添加 HeapProfilerStop()。<br>在需要手动生成快照的地方，添加 HeapProfilerDump(“文件名”)。</p>
</li>
<li><p>自动<br>设置环境变量，动态加载设置环境变量即可，tcmalloc库加载时会读取并解析这个环境变量，从而开启堆分析功能</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HEAP_PROFILE=/tmp/myapp_heap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是静态加载，需代码中启动：HeapProfilerStart</p>
</blockquote>
</li>
<li><p>补充说明<br>自动生成文件的时机：申请内存超过阈值时会自动生成，阈值可以通过HEAP_PROFILE_ALLOCATION_INTERVAL环境变量来设置</p>
</li>
</ul>
<h2 id="三-分析heap文件（快照）"><a href="#三-分析heap文件（快照）" class="headerlink" title="三 分析heap文件（快照）"></a>三 分析heap文件（快照）</h2><h3 id="单次快照"><a href="#单次快照" class="headerlink" title="单次快照"></a>单次快照</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本格式</span></span><br><span class="line">pprof test_heap --text /tmp/test_heap.0001.heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 火焰图</span></span><br><span class="line">pprof --svg /path/to/my_program.hprof &gt; flamegraph.svg</span><br></pre></td></tr></table></figure>
<h3 id="两次快照："><a href="#两次快照：" class="headerlink" title="两次快照："></a>两次快照：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对比两次快照</span></span><br><span class="line">pprof --inuse_space --base=/tmp/my_app.0001.heap /tmp/my_app.0002.heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成火焰图</span></span><br><span class="line">pprof --svg --inuse_space --base=/tmp/my_app.0001.heap /tmp/my_app.0002.heap &gt; diff_flamegraph.svg</span><br></pre></td></tr></table></figure>
<p>火焰图需要额外安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install graphviz</span><br></pre></td></tr></table></figure>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HeapProfilerStart(<span class="string">&quot;/tmp/test_heap&quot;</span>);</span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">malloc</span>(<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 分配 16MB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocated 16MB\n&quot;</span>;</span><br><span class="line">    HeapProfilerDump(<span class="string">&quot;after_alloc&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    HeapProfilerStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test_heap.cc -ltcmalloc -lpthread -lunwind -o test_heap</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调试</title>
    <url>/2025/08/13/debug/%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>只显示指定进程 <PID> 的所有线程，并实时显示它们的 CPU、内存等使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pstack &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf top -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>查看函数热点，采样一段时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf record -p &lt;PID&gt; -g -- sleep 10</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure>

<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -ttT -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><ul>
<li><p>安装perf</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common linux-tools-$(uname -r)</span><br></pre></td></tr></table></figure>
</li>
<li><p>采样数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30</span><br></pre></td></tr></table></figure>

<p>  -F 99          每秒采样 99 次<br>  -p <PID>       针对指定进程<br>  -g             采集调用栈（火焰图需要）<br>  – sleep 30    采样 30 秒</p>
</li>
<li><p>生成调用栈</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo perf script &gt; out.perf</span><br></pre></td></tr></table></figure></li>
<li><p>下载 FlameGraph 工具</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">cd FlameGraph</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成火焰图</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stackcollapse-perf.pl ../out.perf &gt; out.folded</span><br><span class="line">./flamegraph.pl out.folded &gt; flamegraph.svg</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="系统io"><a href="#系统io" class="headerlink" title="系统io"></a>系统io</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>
<p>重点关注 await（平均等待时间）和 svctm（服务时间）。如果 await &gt;&gt; svctm，说明队列很长，设备忙不过来。</p>
<h2 id="某个进程io"><a href="#某个进程io" class="headerlink" title="某个进程io"></a>某个进程io</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidstat -d -p &lt;PID&gt; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>File Descriptor Limits</title>
    <url>/2024/10/24/linux/File%20Descriptor%20Limits/</url>
    <content><![CDATA[<p><a href="https://0pointer.net/blog/file-descriptor-limits.html">https://0pointer.net/blog/file-descriptor-limits.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer Bulk Eviction</title>
    <url>/2024/12/31/postgres/Buffer-Bulk-Eviction/</url>
    <content><![CDATA[<p>If bulk reads or writes are performed, there is a risk that one-time data can quickly oust useful pages from the buffer cache.</p>
<p>As a precaution, bulk operations use rather small buffer rings, and eviction is performed within their boundaries, without affecting other buffers.</p>
<p>A buffer ring of a particular size consists of an array of buffers that are used one after another. At first, the buffer ring is empty, and individual buffers join it one by one, after being selected from the buffer cache in the usual manner. Then eviction comes into play,but only within the ring limits</p>
<p>Buffers added into a ring are not excluded from the buffer cache and can still be used by other operations. So if the buffer to be reused turns out to be pinned, or its usage count is higher than one, it will be simply detached from the ring and replaced by another buffer.<br>PostgreSQL supports three eviction strategies.</p>
<table>
<thead>
<tr>
<th><strong>strategy</strong></th>
<th>trigger</th>
<th>buffer ring</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bulk reads</strong></td>
<td>sequential scans of large tables if their size exceeds 1&#x2F;4 of the buffer cache(128MB：16384 page）</td>
<td>256KB(32 page)</td>
</tr>
<tr>
<td><strong>Bulk writes</strong></td>
<td>applied by Copy from, create table as select , and create materialized view commands, as well as by those alter table  flavors that cause table rewrites.</td>
<td>default: 16MB(2048 page)</td>
</tr>
<tr>
<td><strong>Vacuuming</strong></td>
<td>full table scan without taking the visibility map into account</td>
<td>256KB(32 page)</td>
</tr>
</tbody></table>
<p>Buffer rings do not always prevent undesired eviction. If UPDATE or DELETE commands affect a lot of rows, the performed table scan applies the bulk reads strategy, but since the pages are constantly being modified, buffer rings virtually become useless.</p>
<p>Another example worth mentioning is storing oversized data in TOAST tables. In spite of a potentially large volume of data that has to be read, toasted values are always accessed via an index, so they bypass buffer rings.</p>
<p>Let’s take a closer look at the bulk reads strategy. For simplicity, we will create a table in such a way that an inserted row takes the whole page. By default, the buffer cache size is 16,384 pages, 8 kb each. So the table must take more than 4096 pages for the scan to use a buffer ring.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SHOW</span> shared_buffers;</span><br><span class="line"> shared_buffers </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">128</span>MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> big(</span><br><span class="line">test(# id <span class="type">integer</span> <span class="keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>, s <span class="type">char</span>(<span class="number">1000</span>)</span><br><span class="line">test(# ) <span class="keyword">WITH</span> (fillfactor <span class="operator">=</span> <span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">INSERT INTO</span> big(s)</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">SELECT</span> <span class="string">&#x27;FOO&#x27;</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">4096</span><span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">4097</span></span><br><span class="line">test<span class="operator">=</span># ANALYZE big;</span><br><span class="line">ANALYZE</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> relname, relfilenode, relpages <span class="keyword">FROM</span> pg_class</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHERE</span> relname <span class="keyword">IN</span> (<span class="string">&#x27;big&#x27;</span>, <span class="string">&#x27;big_pkey&#x27;</span>);</span><br><span class="line"> relname  <span class="operator">|</span> relfilenode <span class="operator">|</span> relpages </span><br><span class="line"><span class="comment">----------+-------------+----------</span></span><br><span class="line"> big      <span class="operator">|</span>       <span class="number">16487</span> <span class="operator">|</span>     <span class="number">4097</span></span><br><span class="line"> big_pkey <span class="operator">|</span>       <span class="number">16492</span> <span class="operator">|</span>       <span class="number">14</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big;</span><br><span class="line">                 QUERY PLAN                 </span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> big (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">4097</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache</span><br><span class="line"><span class="keyword">WHERE</span> relfilenode <span class="operator">=</span> pg_relation_filenode(<span class="string">&#x27;big&#x27;</span>::regclass);</span><br><span class="line"> count </span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">    <span class="number">32</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Background Writing</title>
    <url>/2025/08/20/postgres/Background-Writing/</url>
    <content><![CDATA[<p>如果后台进程（backend）需要从缓冲区中驱逐一个脏页（dirty page），它必须将这个页面写入磁盘。这种情况是不希望发生的，因为它会导致等待（例如 I&#x2F;O 阻塞）——更好的方式是在后台异步地执行写入操作。</p>
<p>这一工作部分由 checkpointer 进程完成，但这仍然不够。因此，PostgreSQL 还引入了另一个名为 bgwriter（后台写入进程）的进程，专门用于后台写盘操作。</p>
<p>bgwriter 和驱逐（eviction）使用相同的缓冲区遍历算法，但有两个关键区别：</p>
<p>bgwriter 使用自己独立的时钟指针（clock hand），该指针从不会落后于驱逐的指针，通常还会超过它；<br>在遍历缓冲区时，bgwriter 不会降低页面的 usage count（使用计数）。<br>当一个缓冲页未被固定（unpinned）且其 usage count 为 0 时，如果它是脏的，bgwriter 就会将其刷新到磁盘。换句话说，bgwriter 在驱逐操作发生之前运行，主动地将那些很可能即将被驱逐的页面提前写入磁盘。</p>
<p>这样做的好处是：被选中驱逐的缓冲页很可能已经是干净的（clean），从而提高了驱逐操作的效率，避免了后台进程被迫同步写盘的代价。</p>
<p>总结</p>
<blockquote>
<p>checkpointer 是“周期性清理工”，而 bgwriter 是“持续扫地工”。</p>
</blockquote>
<p>checkpointer 负责最终的数据落盘一致性，而 bgwriter 提前清理“潜在垃圾”，让后台线程少“踩雷”。二者配合，保障了 PostgreSQL 的高并发性能和写入平滑性。</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Checkpoint</title>
    <url>/2025/04/03/postgres/Checkpoint/</url>
    <content><![CDATA[<p>要在发生故障后恢复数据一致性（即执行恢复操作），PostgreSQL 需要向前回放 WAL 日志，并将其中表示丢失变更的记录应用到相应的数据页上。为了确定哪些变更丢失了，系统会将磁盘上数据页的 LSN（日志序列号）与 WAL 记录的 LSN 进行比较。但问题是，我们应该从哪里开始恢复？如果恢复起点选得太晚，那么在此之前已经写入磁盘的数据页将无法接收到所有应有的变更，最终导致无法修复的数据损坏。而从日志的起始位置开始恢复又不现实：不仅无法长期保存如此巨量的数据，也无法接受过长的恢复时间。因此，我们需要一个不断向前推进的检查点（checkpoint），从而可以从这个位置安全地开始恢复，同时删除所有更早的 WAL 记录。</p>
<p>创建检查点最直接的方式是：定期暂停系统所有操作，并将所有脏页强制刷新到磁盘。但这种方式显然是不可接受的，因为系统会因此暂停不定但相当长的时间。</p>
<p>正因为如此，PostgreSQL 将检查点的过程分摊到一段时间内完成，实际上构成了一个“区间”（interval）。检查点的执行是由一个特殊的后台进程负责的，这个进程叫做 checkpointer（检查点进程）</p>
<h2 id="检查点开始（Checkpoint-start）："><a href="#检查点开始（Checkpoint-start）：" class="headerlink" title="检查点开始（Checkpoint start）："></a>检查点开始（Checkpoint start）：</h2><p>checkpointer 进程会将所有可以立即写入磁盘的内容进行刷新，包括：</p>
<ul>
<li>CLOG（提交日志）中的事务状态信息，</li>
<li>子事务的元数据，</li>
<li>以及其他一些结构。</li>
</ul>
<h2 id="检查点执行过程（Checkpoint-execution）："><a href="#检查点执行过程（Checkpoint-execution）：" class="headerlink" title="检查点执行过程（Checkpoint execution）："></a>检查点执行过程（Checkpoint execution）：</h2><p>检查点执行的大部分时间都耗费在将 脏页（dirty pages）刷新到磁盘上。</p>
<p>首先，在检查点开始时，所有当时处于“脏”状态的缓冲区（buffer）的页头会被打上一个特殊标记（tag）。这个过程非常迅速，因为它不涉及任何 I&#x2F;O 操作，只是内存中的标记设置。</p>
<p>随后，checkpointer 会遍历所有缓冲区，并将带有该标记的页写入磁盘。这些页不会被驱逐出缓存（即它们仍然保留在缓冲池中），只是被刷盘，因此在这个过程中可以忽略使用计数（usage count）和 pin 计数（pin count）。</p>
<p>页面按 ID 顺序处理，以尽可能避免随机写入。为实现更好的负载均衡，PostgreSQL 会在多个表空间之间交替进行写入（因为它们可能位于不同的物理设备上）。</p>
<p>后端进程（backend）也可以将打了标记的缓冲页写入磁盘 —— 如果它们先访问到了这些页的话。无论由谁写入，缓冲区的标记都会在这个阶段被清除，因此每个缓冲页在此次检查点中只会被写一次。  </p>
<p>很自然地，在 checkpoint 进行期间，缓冲区中的页面仍然可能被修改。但由于这些新的脏页没有被打上标记，checkpointer 会忽略它们。</p>
<h2 id="检查点完成："><a href="#检查点完成：" class="headerlink" title="检查点完成："></a>检查点完成：</h2><p>当在检查点开始时被标记为脏的所有缓冲页都已经写入磁盘后，检查点就被视为完成。从现在起（但不是在此之前！），本次检查点的起始位置将被作为恢复操作的新起点。在这个点之前写入的所有 WAL 日志都不再需要了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time →</span><br><span class="line">LSN：</span><br><span class="line">      ┌──────────────────────────────────────────────────────────────────────┐</span><br><span class="line">      │                                                                      │</span><br><span class="line">  0 ──┴─────┬───────────────────────────────────────────┬────────────┬───────┘</span><br><span class="line">            │                                           │            │</span><br><span class="line">            ▼                                           ▼            ▼</span><br><span class="line">            1                                           2            3</span><br><span class="line">✔ 若 3 写入成功：恢复可从 2 开始（即 redo = 2）</span><br><span class="line">✘ 若 3 写入失败：恢复只能从 1 开始（上次 checkpoint）</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 1：上一次 checkpoint 的起始 LSN（redo）</span><br><span class="line">- 2：本次 checkpoint 开始时wallog最大LSN（新的redo点）</span><br><span class="line">- 3：本次 checkpoint 完成后写入 WAL 的记录（记录了 redo=2）</span><br></pre></td></tr></table></figure>
<p>最后，checkpointer 进程会创建一条表示检查点完成的 WAL 记录，并在其中标明此次检查点的起始 LSN。由于检查点在开始时不会写入任何日志，因此这个起始 LSN 可以是任意类型的 WAL 记录所属的 LSN。<br>此外，PGDATA&#x2F;global&#x2F;pg_control 文件也会被更新，以指向最近完成的检查点。（在此过程完成之前，pg_control 始终保留着上一个检查点的信息。）</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">UPDATE</span> big <span class="keyword">SET</span> s <span class="operator">=</span> <span class="string">&#x27;FOO&#x27;</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache <span class="keyword">WHERE</span> isdirty;</span><br><span class="line">count </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">4119</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line">pg_current_wal_insert_lsn</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF7E0 (<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> CHECKPOINT;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache <span class="keyword">WHERE</span> isdirty;</span><br><span class="line">count </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line">pg_current_wal_insert_lsn </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF890 </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>最新的 WAL 条目与检查点完成有关（CHECKPOINT_ONLINE）。该检查点的起始 LSN 出现在 redo 之后；这个位置对应的是检查点开始时最新插入的 WAL 条目。</p>
<p>同样的信息也可以在 pg_control 文件中找到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres$ <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>bin<span class="operator">/</span>pg_controldata \</span><br><span class="line"><span class="operator">-</span>D <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>data <span class="operator">|</span> egrep <span class="string">&#x27;Latest.*location&#x27;</span> Latest checkpoint location: <span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF818</span><br><span class="line">Latest checkpoint<span class="string">&#x27;s REDO location: 0/3E7EF7E0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Install postgres from codes in linux</title>
    <url>/2024/06/30/postgres/Install-postgres-from-codes-in-linux/</url>
    <content><![CDATA[<p>First, we need to create a postgres user and add it to the sudo group</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -aG <span class="built_in">sudo</span> postgres <span class="comment"># 注意安全，云主机不要这么设置</span></span><br></pre></td></tr></table></figure>

<h2 id="Get-codes"><a href="#Get-codes" class="headerlink" title="Get codes"></a>Get codes</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://git.postgresql.org/git/postgresql.git</span><br></pre></td></tr></table></figure>
<p>Compile after installing dependencies</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">  build-essential \</span><br><span class="line">  libreadline-dev \</span><br><span class="line">  zlib1g-dev \</span><br><span class="line">  flex \</span><br><span class="line">  bison \</span><br><span class="line">  libxml2-dev \</span><br><span class="line">  libxslt1-dev \</span><br><span class="line">  libssl-dev \</span><br><span class="line">  libpam0g-dev \</span><br><span class="line">  libedit-dev \</span><br><span class="line">  libldap2-dev \</span><br><span class="line">  libicu-dev \</span><br><span class="line">  tcl-dev \</span><br><span class="line">  uuid-dev \</span><br><span class="line">  python3-dev \</span><br><span class="line">  libperl-dev \</span><br><span class="line">  llvm-dev \</span><br><span class="line">  clang \</span><br><span class="line">  libperl-dev \</span><br><span class="line">  libpython3-dev \</span><br><span class="line">  libossp-uuid-dev \</span><br><span class="line">  systemtap-sdt-dev \</span><br><span class="line">  pkg-config</span><br><span class="line">./configure --enable-debug <span class="string">&#x27;CFLAGS=-O0 -g&#x27;</span> --enable-cassert --enable-depend --enable-dtrace --without-icu --with-llvm</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>
<h2 id="Modify-environment-variables"><a href="#Modify-environment-variables" class="headerlink" title="Modify environment variables"></a>Modify environment variables</h2><p>create a configure file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.pg_env</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前使用的 PostgreSQL 安装路径</span></span><br><span class="line"><span class="built_in">export</span> PG_HOME=<span class="variable">$HOME</span>/pgsql</span><br><span class="line"><span class="built_in">export</span> PGDATA=<span class="variable">$HOME</span>/pgdata</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PG_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PG_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：显示当前 PostgreSQL 版本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🔧 Loaded PG env: <span class="subst">$(pg_config --version)</span>&quot;</span></span><br><span class="line">在 ~/.bashrc 末尾加上这一行：</span><br><span class="line">[ -f ~/.pg_env ] &amp;&amp; <span class="built_in">source</span> ~/.pg_env</span><br></pre></td></tr></table></figure>
<h2 id="initdb"><a href="#initdb" class="headerlink" title="initdb"></a>initdb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R postgres:postgres /usr/local/pgsql</span><br><span class="line">initdb</span><br></pre></td></tr></table></figure>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pg_ctl -D /usr/local/pgsql/data -l logfile start</span><br></pre></td></tr></table></figure>

<h2 id="About-Extensions"><a href="#About-Extensions" class="headerlink" title="About Extensions"></a>About Extensions</h2><p>cd contrib</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>登录你要使用的数据库，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION pageinspect;</span><br><span class="line">\dx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>LWLock in postgres</title>
    <url>/2025/09/05/postgres/LWLock-in-postgres/</url>
    <content><![CDATA[<h2 id="一-相关结构体说明"><a href="#一-相关结构体说明" class="headerlink" title="一 相关结构体说明"></a>一 相关结构体说明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LWLock</span></span><br><span class="line">&#123;</span><br><span class="line">    uint16           tranche;       <span class="comment">/* tranche ID */</span></span><br><span class="line">    pg_atomic_uint32 state;         <span class="comment">/* state of exclusive/nonexclusive lockers */</span></span><br><span class="line">    proclist_head    waiters;       <span class="comment">/* list of waiting PGPROCs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCK_DEBUG</span></span><br><span class="line">    pg_atomic_uint32 nwaiters;      <span class="comment">/* number of waiters */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PGPROC</span>    *owner;        <span class="comment">/* last exclusive owner of the lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; LWLock;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>tranche<br>每个 LWLock 都属于某个 tranche，tranche 是一个 int 类型的 ID，代表这把锁的用途</p>
</li>
<li><p>state<br>bit0～23：共享锁状态，实际最多用bit0～17，因为backend最多18位<br>bit24: 排他锁状态<br>bit28：用于锁定等待队列：waiters<br>bit29: 是否允许唤醒等待队列里面的进程，初始状态：LW_FLAG_RELEASE_OK<br>bit30: LW_FLAG_HAS_WAITERS ：是否有waiter</p>
</li>
<li><p>waiters<br>等待队列</p>
</li>
</ul>
<h2 id="二-Interface说明"><a href="#二-Interface说明" class="headerlink" title="二 Interface说明"></a>二 Interface说明</h2><h3 id="2-1-LWLockAcquire"><a href="#2-1-LWLockAcquire" class="headerlink" title="2.1 LWLockAcquire"></a>2.1 LWLockAcquire</h3><p>加锁，失败进入等待队列，直接加上锁的情况，可能会造成等待队列无效唤醒  </p>
<blockquote>
<p>acquire a lightweight lock in the specified mode<br>Side effect: cancel&#x2F;die interrupts are held off until lock release.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == LW_EXCLUSIVE)</span><br><span class="line">&#123;</span><br><span class="line">    lock_free = (old_state &amp; LW_LOCK_MASK) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lock_free)</span><br><span class="line">        desired_state += LW_VAL_EXCLUSIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_free = (old_state &amp; LW_VAL_EXCLUSIVE) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lock_free)</span><br><span class="line">        desired_state += LW_VAL_SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按位判断前25位即可知道此LWLock是否被进程所占</p>
<h3 id="2-2-LWLockRelease"><a href="#2-2-LWLockRelease" class="headerlink" title="2.2 LWLockRelease"></a>2.2 LWLockRelease</h3><p>进行唤醒条件：</p>
<ul>
<li>oldstate &amp; LW_FLAG_HAS_WAITERS：等待队列非空。这个条件确认有进程在等待锁。  </li>
<li>oldstate &amp; LW_FLAG_RELEASE_OK： 允许唤醒。这个标志表示系统在上次唤醒后，已经将再次唤醒其他等待者的权限交给了被唤醒的进程。</li>
<li>(oldstate &amp; LW_LOCK_MASK) &#x3D;&#x3D; 0：锁已空闲。这个条件确认锁当前没有被任何进程占用（无论是独占模式还是共享模式，计数都为零）</li>
</ul>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock</title>
    <url>/2025/09/03/postgres/Lock/</url>
    <content><![CDATA[<h2 id="全局hash"><a href="#全局hash" class="headerlink" title="全局hash"></a>全局hash</h2><p>LockMethodLockHash：存储LOCK<br>LockMethodProcLockHash：存储PROCLOCK<br>LockMethodLocalHash：存储LOCALLOCK</p>
<p>同一个LOCK资源对象可以被多个不同的 PROCLOCK 持有，而这些 PROCLOCK 又分别属于不同的进程。</p>
<h2 id="LOCKTAG"><a href="#LOCKTAG" class="headerlink" title="LOCKTAG"></a>LOCKTAG</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCKTAG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	uint32		locktag_field1; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint32		locktag_field2; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint32		locktag_field3; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint16		locktag_field4; <span class="comment">/* a 16-bit ID field */</span></span><br><span class="line">	uint8		locktag_type;	<span class="comment">/* see enum LockTagType */</span></span><br><span class="line">	uint8		locktag_lockmethodid;	<span class="comment">/* lockmethod indicator */</span></span><br><span class="line">&#125; LOCKTAG;</span><br></pre></td></tr></table></figure>
<ul>
<li>locktag_type<br>标识这个锁是针对哪类资源的。每种 LockTagType 决定了 LOCKTAG 里后面几个字段（locktag_field1 ~ locktag_field4）是怎么解释的，比如：<br>LOCKTAG_TRANSACTION：xid<br>LOCKTAG_RELATION：dbOid + relOid<br>LOCKTAG_TUPLE：dbOid + relOid + blockNum + offNum       </li>
<li>locktag_lockmethodid<ul>
<li>DEFAULT_LOCKMETHOD（id &#x3D; DEFAULT_LOCKMETHOD)<br>  绝大多数用户可见的锁（relation, tuple, transactionid 等）都走它。</li>
<li>USER_LOCKMETHOD（id &#x3D; USER_LOCKMETHOD)<br>  提供给 pg_advisory_lock() 一类的 advisory lock，用于用户自定义锁。</li>
</ul>
</li>
</ul>
<h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LOCKTAG		tag;			</span><br><span class="line">	LOCKMASK	grantMask;		</span><br><span class="line">	LOCKMASK	waitMask;		</span><br><span class="line">	dlist_head	procLocks;		</span><br><span class="line">	dclist_head     waitProcs;		</span><br><span class="line">	<span class="type">int</span>		requested[MAX_LOCKMODES];	</span><br><span class="line">	<span class="type">int</span>		nRequested;		</span><br><span class="line">	<span class="type">int</span>		granted[MAX_LOCKMODES]; </span><br><span class="line">	<span class="type">int</span>		nGranted;		</span><br><span class="line">&#125; LOCK;</span><br></pre></td></tr></table></figure>
<ul>
<li>waitProcs<br>等待本LOCK的PGPROC链表</li>
<li>procLocks<br>等待本LOCK的PROCLOCK链表</li>
<li>waitMask<br>该资源上等待的锁类型</li>
<li>grantMask<br>该资源上已经授予的锁类型</li>
</ul>
<h2 id="LOCKMODE"><a href="#LOCKMODE" class="headerlink" title="LOCKMODE"></a>LOCKMODE</h2><p>每种资源支持8种锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NoLock					0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessShareLock			1	<span class="comment">/* SELECT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowShareLock			2	<span class="comment">/* SELECT FOR UPDATE/FOR SHARE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowExclusiveLock		3	<span class="comment">/* INSERT, UPDATE, DELETE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareUpdateExclusiveLock 4	<span class="comment">/* VACUUM (non-FULL), ANALYZE, CREATE</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * INDEX CONCURRENTLY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareLock				5	<span class="comment">/* CREATE INDEX (WITHOUT CONCURRENTLY) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareRowExclusiveLock	6	<span class="comment">/* like EXCLUSIVE MODE, but allows ROW</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * SHARE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ExclusiveLock			7	<span class="comment">/* blocks ROW SHARE/SELECT...FOR UPDATE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessExclusiveLock		8	<span class="comment">/* ALTER TABLE, DROP TABLE, VACUUM FULL,</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * and unqualified LOCK TABLE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLockMode				8	<span class="comment">/* highest standard lock mode */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="冲突矩阵"><a href="#冲突矩阵" class="headerlink" title="冲突矩阵"></a>冲突矩阵</h2><table>
<thead>
<tr>
<th>Requested Lock Mode</th>
<th>ACCESS SHARE</th>
<th>ROW SHARE</th>
<th>ROW EXCL.</th>
<th>SHARE UPDATE EXCL.</th>
<th>SHARE</th>
<th>SHARE ROW EXCL.</th>
<th>EXCL.</th>
<th>ACCESS EXCL.</th>
</tr>
</thead>
<tbody><tr>
<td>ACCESS SHARE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>ROW SHARE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ROW EXCL.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE UPDATE EXCL.</td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE ROW EXCL.</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>EXCL.</td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ACCESS EXCL.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.postgresql.org/docs/17/explicit-locking.html">postgres官方文档</a>  </p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Logging</title>
    <url>/2025/02/27/postgres/Logging/</url>
    <content><![CDATA[<p>在发生故障（例如停电、操作系统错误或数据库服务器崩溃）时，RAM 中的所有内容都将丢失；只有写入磁盘的数据会保留下来。要在故障后启动服务器，您必须恢复数据一致性。如果磁盘本身已损坏，则必须通过备份恢复来解决相同的问题。</p>
<p>理论上，您可以始终保持磁盘上的数据一致性。但实际上，这意味着服务器必须不断地将随机页面写入磁盘（尽管顺序写入成本更低），并且此类写入的顺序必须保证在任何特定时刻都不会损害一致性（这很难实现，尤其是当您处理复杂的索引结构时）。</p>
<p>与大多数数据库系统一样，PostgreSQL 采用了一种不同的方法。</p>
<p>服务器运行时，部分当前数据仅存在于 RAM 中，其写入永久存储的操作被推迟。因此，服务器运行时存储在磁盘上的数据始终是不一致的，因为页面从不会一次性全部刷新。但是，RAM 中发生的每个更改（例如在缓冲区缓存中执行的页面更新）都会被记录下来：PostgreSQL 会创建一个日志条目，其中包含在需要时重复此操作所需的所有基本信息。</p>
<p>页面修改相关的日志条目必须先于修改后的页面本身写入磁盘。这就是日志名称的由来：预写式日志（write-ahead log），简称 WAL。这项要求保证了在发生故障时，PostgreSQL 可以从磁盘读取 WAL 条目并重放它们，以重复那些已完成但结果仍在 RAM 中且在崩溃前未写入磁盘的操作。</p>
<p>保留预写式日志通常比将随机页面写入磁盘更高效。WAL 条目构成一个连续的数据流，即使是硬盘驱动器 (HDD) 也能很好地处理。此外，WAL 条目通常比页面大小更小。</p>
<p>为了在发生故障时避免数据不一致，所有可能破坏数据一致性的操作都需要记录下来。具体来说，以下操作会记录在 预写式日志 (WAL) 中：</p>
<ul>
<li>WAL 记录的操作</li>
</ul>
<ol>
<li>缓冲区缓存中的页面修改：由于写入是延迟的，这些修改需要记录下来以备恢复。</li>
<li>事务提交和回滚：事务状态的变化发生在 CLOG 缓冲区中，不会立即写入磁盘，因此需要记录。</li>
<li>文件操作：当添加或删除表时，文件和目录的创建与删除等操作必须与数据更改同步，所以也要记录。</li>
</ol>
<ul>
<li>WAL 不记录的操作</li>
</ul>
<ol>
<li>unlogged表相关操作</li>
<li>临时表上的操作：由于临时表的生命周期仅限于创建它们的会话，所以它们的操作不会被记录。<blockquote>
<p>在 PostgreSQL 10 之前，哈希索引的操作也不会被记录。它们的主要目的是将哈希函数与不同的数据类型匹配。</p>
</blockquote>
</li>
</ol>
<p>除了用于崩溃恢复之外，WAL 还可以用于从备份进行时间点恢复以及数据复制。</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Recovery in postgres</title>
    <url>/2025/10/24/postgres/Recovery/</url>
    <content><![CDATA[<p>服务器启动时，第一个启动的进程是 postmaster（新版本为postgres）。postmaster 接着会生成 startup process（启动进程），startup process 负责在发生故障时进行数据恢复。</p>
<blockquote>
<p>startup process 是一个短暂的、一次性的进程，它的主要职责是在数据库启动时执行崩溃恢复或归档恢复。它完成它的工作后，就会退出。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:/root$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               in production</span><br><span class="line">postgres@lavm-bar1guved6:/root$ </span><br></pre></td></tr></table></figure>
<p>一个正常停止的服务器会处于“已关闭”（shut down）状态；而一个未运行的服务器却显示为“生产中”（in production）状态，则表明发生了故障。在这种情况下，启动进程（startup process）将自动从在同一个 pg_control 文件中找到的最新完成的检查点（checkpoint）**的起始 LSN 处开始进行恢复。</p>
<blockquote>
<p>如果 PGDATA 目录中包含与备份相关的 backup_label 文件，则起始 LSN 位置会从该文件中获取。</p>
</blockquote>
<p>在启动过程中，系统会从指定位置开始，逐一读取WAL（Write-Ahead Log，预写式日志）条目。如果数据页的 LSN（Log Sequence Number，日志序列号）小于当前读取到的 WAL 条目的 LSN，系统会将该 WAL 条目应用到数据页上。如果数据页的 LSN 已经大于 WAL 条目的 LSN，则不应应用该 WAL 条目；事实上，也绝不能应用，因为 WAL 条目被设计为必须严格按顺序重放。</p>
<p>然而，有些 WAL 条目是Full Page Image（FPI）。这类条目可以应用于页面的任何状态，因为它们会完全覆盖页面内容，无论页面原先是什么状态都不重要。因此，这种修改是幂等的（idempotent）——多次应用不会改变结果另一个幂等操作的例子是注册事务状态的变更：每个事务的状态在 CLOG（事务提交日志）中是通过设置特定位来表示的，这种设置不依赖于原来的位值。因此，不需要在 CLOG 页面中记录最近变更的 LSN（日志序列号），因为日志重放时只要设置一次这些位就够了，重复设置也不会有副作用最后，系统会执行一次 checkpoint（检查点），将恢复后的所有修改持久化到磁盘，此时 启动进程（startup process） 的任务就完成了。</p>
<p>WAL 日志条目会被应用到缓冲池（buffer cache）中的页面上，就像正常运行时对数据页的普通修改一样。</p>
<p>文件的恢复也遵循类似方式：例如，若某条 WAL 记录表明某个文件应该存在，但实际却缺失，系统就会重新创建这个文件。<br>一旦恢复完成，所有 unlogged relations会被它们对应的 初始化副本（init fork） 覆盖。</p>
<p>最后，系统会执行一次 checkpoint，将恢复后的所有修改持久化到磁盘，此时 启动进程（startup process） 的任务就完成了<br>在其经典形式中，恢复过程包含两个阶段：</p>
<ul>
<li>roll-forward阶段：重放 WAL 日志，重复执行在崩溃时丢失的操作；</li>
<li>roll-back阶段：服务器中止那些在故障发生时尚未提交的事务。<br>在 PostgreSQL 中，向后回滚是不需要的。恢复完成后，CLOG（事务状态日志）中对未完成事务既没有提交（commit）标记，也没有中止（abort）标记（这在技术上表示该事务处于活动状态），但因为可以确定该事务已经不再运行，所以系统会将其视为已中止（aborted）。</li>
</ul>
<p>我们可以通过强制服务器以“立即模式”（immediate mode）停止来模拟故障：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:/root$ pg_ctl stop -m immediate</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br><span class="line">postgres@lavm-bar1guved6:/root$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               in production</span><br></pre></td></tr></table></figure>
<p>当我们启动服务器时，启动进程会检测到之前发生了故障，因而进入恢复模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2025-08-04 10:23:31.860 CST [487414] LOG:  starting PostgreSQL 19devel on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, 64-bit</span><br><span class="line">2025-08-04 10:23:31.861 CST [487414] LOG:  listening on IPv4 address &quot;127.0.0.1&quot;, port 5432</span><br><span class="line">2025-08-04 10:23:31.878 CST [487414] LOG:  listening on Unix socket &quot;/tmp/.s.PGSQL.5432&quot;</span><br><span class="line">2025-08-04 10:23:31.920 CST [487420] LOG:  database system was interrupted; last known up at 2025-08-01 09:36:11 CST</span><br><span class="line">2025-08-04 10:23:32.098 CST [487420] LOG:  database system was not properly shut down; automatic recovery in progress</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  redo starts at 0/01B75168</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  invalid record length at 0/01B752A8: expected at least 24, got 0</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  redo done at 0/01B75270 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s</span><br><span class="line">2025-08-04 10:23:32.132 CST [487418] LOG:  checkpoint starting: end-of-recovery fast wait</span><br><span class="line">2025-08-04 10:23:32.152 CST [487418] LOG:  checkpoint complete: wrote 0 buffers (0.0%), wrote 3 SLRU buffers; 0 WAL file(s) added, 0 removed, 0 recycled; write=0.006 s, sync=0.005 s, total=0.022 s; sync files=2, longest=0.005 s, average=0.003 s; distance=0 kB, estimate=0 kB; lsn=0/01B752A8, redo lsn=0/01B752A8</span><br><span class="line">2025-08-04 10:23:32.155 CST [487414] LOG:  database system is ready to accept connections</span><br></pre></td></tr></table></figure>
<p>如果服务器正在正常关闭，postmaster 会先断开所有客户端连接，然后执行最后一次检查点操作，将所有脏页（未写入磁盘的修改页面）刷写到磁盘上。</p>
<p>看当前的WAL位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line">---------------------------</span><br><span class="line"> 0/01B75358</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<p>我们正常停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_ctl stop</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br></pre></td></tr></table></figure>
<p>现在的数据库状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               shut down</span><br></pre></td></tr></table></figure>
<p>在WAL的末尾，我们看到了表示最后一次checkpoint的CHECKPOINT_SHUTDOWN 条目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_waldump  -p /home/postgres/pgdata/pg_wal -s 0/01B75358</span><br><span class="line">rmgr: XLOG        len (rec/tot):    114/   114, tx:          0, lsn: 0/01B75358, prev 0/01B75320, desc: CHECKPOINT_SHUTDOWN redo 0/01B75358; tli 1; prev tli 1; fpw true; wal_level replica; xid 0:758; oid 24576; multi 1; offset 0; oldest xid 746 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</span><br><span class="line">pg_waldump: error: error in WAL record at 0/01B75358: invalid record length at 0/01B753D0: expected at least 24, got 0</span><br><span class="line">postgres@lavm-bar1guved6:~$ </span><br></pre></td></tr></table></figure>
<p>最新的 pg_waldump 消息显示该工具已读取 WAL到末尾。</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>RD-Trees for Full-Text Search</title>
    <url>/2025/09/10/postgres/RD-Trees-for-Full-Text-Search/</url>
    <content><![CDATA[<h2 id="关于全文搜索"><a href="#关于全文搜索" class="headerlink" title="关于全文搜索"></a>关于全文搜索</h2><p>全文搜索的目标是从提供的文档集中选择与搜索查询匹配的文档</p>
<p>为了进行搜索，文档会被转换为 tsvector 类型，该类型包含文档中的词素（lexemes）及其在文档中的位置。词素是将单词转换为适合搜索的格式。默认情况下，所有单词都会被标准化为小写，并去除其词尾。</p>
<blockquote>
<p>“并去除其词尾”指的是在全文搜索中，对单词进行词干提取（stemming）或词形归一化（normalization）的过程。具体来说，这是将单词的词尾（如英语中的复数、时态、词性变化等）去除，提取出单词的词干（stem）或基本形式，以便在搜索时能够匹配同一词根的不同变体。例如：单词“running”、“ran”和“runs”都源自同一词根“run”。在全文搜索的处理中，这些单词可能会被归一化为“run”，即去除词尾变化，保留词干。搜索“run”时，系统不仅会匹配“run”，还会匹配“running”、“ran”和“runs”等形式，因为它们都被归一化为相同的词干“run”。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SET</span> default_text_search_config <span class="operator">=</span> english;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(</span><br><span class="line">    <span class="string">&#x27;No one can tell me, nobody knows, &#x27;</span> <span class="operator">||</span></span><br><span class="line">    <span class="string">&#x27;Where the wind comes from, where the wind goes.&#x27;</span></span><br><span class="line">);</span><br><span class="line">                             to_tsvector                              </span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line"> <span class="string">&#x27;come&#x27;</span>:<span class="number">11</span> <span class="string">&#x27;goe&#x27;</span>:<span class="number">16</span> <span class="string">&#x27;know&#x27;</span>:<span class="number">7</span> <span class="string">&#x27;nobodi&#x27;</span>:<span class="number">6</span> <span class="string">&#x27;one&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;tell&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;wind&#x27;</span>:<span class="number">10</span>,<span class="number">15</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>所谓的停用词（如“the”或“from”）会被过滤掉：这些词被认为出现频率过高，搜索它们无法返回有意义的搜索结果。当然，所有这些转换都是可以配置的。</p>
<p>查询由另一种类型表示：tsquery。任何查询都包含一个或多个通过逻辑连接符连接的词素：&amp;（与）、|（或）、!（非）。你还可以使用括号来定义操作符的优先级。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsquery(<span class="string">&#x27;wind &amp; (comes | goes)&#x27;</span>);</span><br><span class="line">         to_tsquery          </span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"> <span class="string">&#x27;wind&#x27;</span> <span class="operator">&amp;</span> ( <span class="string">&#x27;come&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;goe&#x27;</span> )</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>全文搜索中唯一使用的操作符是匹配操作符 @@：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, oprcode::regproc, amopstrategy <span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid <span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily <span class="keyword">JOIN</span> pg_operator opr <span class="keyword">ON</span> opr.oid <span class="operator">=</span> amopopr</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;tsvector_ops&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">       amopopr        <span class="operator">|</span>   oprcode   <span class="operator">|</span> amopstrategy </span><br><span class="line"><span class="comment">----------------------+-------------+--------------</span></span><br><span class="line"> @@(tsvector,tsquery) <span class="operator">|</span> ts_match_vq <span class="operator">|</span>            <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>该操作符判断文档是否满足查询条件。以下是一个示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;Where the wind comes from, where the wind goes&#x27;</span>) @@ to_tsquery(<span class="string">&#x27;wind &amp; coming&#x27;</span>);</span><br><span class="line"> ?<span class="keyword">column</span>? </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>这绝不是对全文搜索的详尽描述，但这些信息应足以理解索引的基础知识。</p>
<h2 id="Indexing-tsvector-Data"><a href="#Indexing-tsvector-Data" class="headerlink" title="Indexing tsvector Data"></a>Indexing tsvector Data</h2><p>为了实现快速的全文搜索，必须使用索引来支持。索引的对象不是文档本身，而是 tsvector 值。这里有两种选择：一种是在表达式上构建索引并进行类型转换，另一种是添加一个单独的 tsvector 类型列并对该列进行索引。第一种方法的优点是不会浪费空间来存储 tsvector 值，因为这些值实际上并不需要直接存储。但这种方法比第二种方法慢，因为索引引擎需要重新检查访问方法返回的所有堆元组。这意味着对于每个重新检查的行，都需要再次计算 tsvector 值，而且正如我们很快会看到的，GiST 索引会重新检查所有行。</p>
<p>让我们构建一个简单的示例。我们将创建一个包含两列的表：第一列存储文档，第二列存储 tsvector 值。我们可以使用触发器来更新第二列，但更方便的做法是直接将该列声明为生成列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> ts(</span><br><span class="line">    doc text,</span><br><span class="line">    doc_tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> (</span><br><span class="line">         to_tsvector(<span class="string">&#x27;pg_catalog.english&#x27;</span>, doc) </span><br><span class="line">    ) STORED</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX ts_gist_idx <span class="keyword">ON</span> ts</span><br><span class="line"><span class="keyword">USING</span> gist(doc_tsv);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的例子中，我使用了带有单一参数的 to_tsvector 函数，通过设置 default_text_search_config 参数来定义全文搜索配置。这种函数变体的波动性（volatility）类别是 STABLE，因为它隐式依赖于参数值。但在这里，我使用了另一种变体，显式指定配置；这种变体是 IMMUTABLE，可以用于生成表达式。</p>
</blockquote>
<p>我们插入几行数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> ts(doc) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some cows&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a moo, there a moo&#x27;</span>), (<span class="string">&#x27;Everywhere a moo moo&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some chicks&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a cluck, there a cluck&#x27;</span>), (<span class="string">&#x27;Everywhere a cluck cluck&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>),(<span class="string">&#x27;And on his farm he had some pigs&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here an oink, there an oink&#x27;</span>),(<span class="string">&#x27;Everywhere an oink oink&#x27;</span>)</span><br><span class="line">RETURNING doc_tsv;</span><br><span class="line">            doc_tsv             </span><br><span class="line"><span class="comment">--------------------------------</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;cow&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;chick&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">4</span> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;pig&#x27;</span>:<span class="number">8</span></span><br><span class="line"> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">(<span class="number">12</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>因此，R 树不适合用于索引文档，因为边界框（bounding box）的概念对文档没有意义。因此，使用了其 RD 树（俄罗斯套娃，Russian Doll）变体。RD 树不使用边界框，而是使用边界集（bounding set），即一个包含其所有子集元素的集合。对于全文搜索，这样的集合包含文档的词素（lexemes），但在一般情况下，边界集可以是任意的。</p>
<p>在索引条目中表示边界集有几种方法。最简单的一种是列举集合中的所有元素。如下图所示</p>
<p>为了找到满足 DOC_TSC @@ TO_TSQUERY(‘COW’) 条件的文档，我们需要深入到那些已知包含“cow”词素的子节点的节点。</p>
<p>这种表示方式的问题显而易见。文档中的词素数量可能非常庞大，而页面大小是有限的。即使单个文档的独特词素数量不算太多，在树的较高层级中，它们的联合集仍然可能变得过大。 全文搜索使用了另一种解决方案，即更紧凑的签名树（signature tree）。对于那些熟悉布隆过滤器（Bloom filter）的人来说，这种解决方案应该很熟悉。 每个词素可以由其签名（signature）表示：一个特定长度的位字符串，其中只有一位被置为 1。置为 1 的位由词素的哈希函数决定。 文档的签名是对该文档中所有词素签名的按位或（bitwise OR）操作结果。</p>
<p>这种方法的优点显而易见：索引条目大小相同且相当小，因此索引非常紧凑。但也存在一些缺点。首先，无法执行仅索引扫描（index-only scan），因为索引不再存储索引键，每个返回的 TID（行标识）都必须通过表进行重新检查。此外，准确性也会受到影响：索引可能返回许多误报（false positives），这些误报需要在重新检查阶段过滤掉。</p>
<p>让我们再次看看 DOC_TSC @@ TO_TSQUERY(‘COW’) 条件。查询的签名（signature）以与文档相同的方式计算；在这个特定情况下，其签名等于 0000010。一致性函数（consistency function）必须找到所有签名中具有相同位被置位的子节点。</p>
<p>与前面的例子相比，这里需要扫描更多的节点，因为存在误报（false-positive）命中。由于签名的容量有限，在大型集合中，某些词素必然会具有相同的签名。在这个例子中，这样的词素是“cow”和“oink”。这意味着一个签名可能匹配多个不同的文档；在这里，查询的签名对应于三个文档。</p>
<p>误报会降低索引的效率，但不会以任何方式影响其正确性：因为假阴性（false negatives）被保证排除，所以不会遗漏所需的值。</p>
<p>显然，签名的实际大小要大得多。默认情况下，签名占用 123 字节（992 位），因此冲突的概率远低于本例中所示。如果需要，可以使用操作符类参数进一步将签名大小增加到大约 2000 字节。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ... <span class="keyword">USING</span> gist(<span class="keyword">column</span> tsvector_ops(siglen <span class="operator">=</span> <span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<p>此外，如果值足够小（略小于页面大小的 1&#x2F;16，对于标准页面大约是 500 字节），tsvector_ops 操作符类会在索引的叶子页面中存储 tsvector 值本身，而不是它们的签名。</p>
<p>为了了解索引在真实数据上的工作方式，我们可以使用 pgsql-hackers 邮件列表存档。该存档包含 356,125 封电子邮件，包括发送日期、主题、作者姓名和正文文本。让我们添加一个 tsvector 类型的列并构建索引。在这里，我将三个值（主题、作者和正文文本）组合成一个单一的向量，以展示文档可以动态生成，而不必存储在单一列中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> mail_messages <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> ( to_tsvector(</span><br><span class="line"><span class="string">&#x27;pg_catalog.english&#x27;</span>, subject<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>author<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>body_plain ) ) STORED;</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored.</span><br><span class="line">...</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored. </span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mail_gist_idx <span class="keyword">ON</span> mail_messages <span class="keyword">USING</span> gist(tsv);</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_gist_idx&#x27;</span>));</span><br><span class="line">pg_size_pretty </span><br><span class="line">−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">127</span> MB </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>在填充该列（tsv）的过程中，一些特别长的词因为长度太大被过滤掉了。但一旦索引构建完成，就可以用于搜索查询了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">27575</span> read<span class="operator">=</span><span class="number">31875</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">75</span> read<span class="operator">=</span><span class="number">4</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>除了满足条件的 898 行之外，访问方法还返回了另外 7852 行，这些行需要后续通过回检（recheck）来过滤。如果我们增加签名容量（signature capacity），准确性（也就是索引效率）会提高，但索引的大小也会随之增加。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">DROP</span> INDEX mail_messages_tsv_idx;</span><br><span class="line"><span class="keyword">DROP</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> mail_messages</span><br><span class="line"><span class="keyword">USING</span> gist(tsv tsvector_ops(siglen<span class="operator">=</span><span class="number">1024</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>));</span><br><span class="line"> pg_size_pretty </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">241</span> MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">25968</span> read<span class="operator">=</span><span class="number">33482</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">3</span> read<span class="operator">=</span><span class="number">2</span> dirtied<span class="operator">=</span><span class="number">1</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>我已经展示了访问方法的属性，其中大多数在所有操作符类中都是相同的。但是下面两个列级别的属性值得一提：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> f</span><br><span class="line"> distance_orderable <span class="operator">|</span> f</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>现在不可能进行 Index-only 扫描了，因为无法从签名中恢复出原始值。<br>不过在这个特定的场景下这是完全可以接受的：<br>tsvector 值只是用于搜索，我们真正需要的是文档本身（也就是实际的数据行）。<br>对于 tsvector_ops 类来说，也没有定义排序操作符</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL Structure(Physical-Structure)</title>
    <url>/2025/07/29/postgres/WAL-Structure-Physical-Structure/</url>
    <content><![CDATA[<p>在磁盘上，WAL 被存储在 PGDATA&#x2F;pg_wal 目录中，以单独的文件（或称为段）的形式存在。它们的大小由只读参数 wal_segment_size 指示。</p>
<p>对于高负载系统，增加段大小可能是有意义的，因为这可以减少开销。但这个设置只能在集群初始化时修改（通过 initdb –wal-segsize）。</p>
<p>WAL 记录会写入当前文件，直到该文件空间耗尽；此时 PostgreSQL 会开始写入一个新文件。</p>
<p>我们可以确定某条记录位于哪个文件中，以及它在该文件起始位置的偏移量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> file_name, <span class="built_in">upper</span>(to_hex(file_offset)) file_offset <span class="keyword">FROM</span> pg_walfile_name_offset(<span class="string">&#x27;1/EBDDC500&#x27;</span>);</span><br><span class="line">        file_name         <span class="operator">|</span> file_offset </span><br><span class="line"><span class="comment">--------------------------+-------------</span></span><br><span class="line"> <span class="number">0000000100000001000000</span>EB <span class="operator">|</span> DDC500</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>该文件的名称由两部分组成。最高的八位十六进制数字（4个字节）表示用于从备份中恢复的时间线（timeline），而其余部分（8个字节）表示 LSN（日志序列号）的高位比特（LSN 的低位比特则体现在 file_offset 字段中）。</p>
<p>要查看当前的 WAL 文件，可以调用以下函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> pg_ls_waldir()</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;0000000100000001000000EB&#x27;</span>;</span><br><span class="line">           name           <span class="operator">|</span>   size   <span class="operator">|</span>      modification      </span><br><span class="line"><span class="comment">--------------------------+----------+------------------------</span></span><br><span class="line"> <span class="number">0000000100000001000000</span>EB <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span> <span class="number">2025</span><span class="number">-07</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">49</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们使用 pg_waldump 工具查看新创建的 WAL 记录的头部信息。该工具既可以按 LSN 范围（就像这个例子中那样）过滤 WAL 记录，也可以按特定的事务 ID 过滤。</p>
<p>pg_waldump 工具应以 postgres 用户身份运行，因为它需要访问磁盘上的 WAL 文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ pg_waldump <span class="operator">-</span>p <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>data<span class="operator">/</span>pg_wal <span class="operator">-</span>s  <span class="number">1</span><span class="operator">/</span>EBDDA4F8 <span class="operator">-</span>e <span class="number">1</span><span class="operator">/</span>EBDDC500</span><br><span class="line">rmgr: XLOG        len (rec<span class="operator">/</span>tot):     <span class="number">49</span><span class="operator">/</span>   <span class="number">109</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA4F8, prev <span class="number">1</span><span class="operator">/</span>EBDDA4C0, <span class="keyword">desc</span>: FPI_FOR_HINT , blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">376833</span> blk <span class="number">0</span> FPW</span><br><span class="line">rmgr: Heap        len (rec<span class="operator">/</span>tot):     <span class="number">69</span><span class="operator">/</span>    <span class="number">69</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA568, prev <span class="number">1</span><span class="operator">/</span>EBDDA4F8, <span class="keyword">desc</span>: HOT_UPDATE old_xmax: <span class="number">961</span>, old_off: <span class="number">1</span>, old_infobits: [], flags: <span class="number">0x40</span>, new_xmax: <span class="number">0</span>, new_off: <span class="number">2</span>, blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">376833</span> blk <span class="number">0</span></span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">54</span><span class="operator">/</span>    <span class="number">54</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA5B0, prev <span class="number">1</span><span class="operator">/</span>EBDDA568, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">960</span> oldestRunningXid <span class="number">961</span>; <span class="number">1</span> xacts: <span class="number">961</span></span><br><span class="line">rmgr: XLOG        len (rec<span class="operator">/</span>tot):     <span class="number">49</span><span class="operator">/</span>  <span class="number">7777</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA5E8, prev <span class="number">1</span><span class="operator">/</span>EBDDA5B0, <span class="keyword">desc</span>: FPI_FOR_HINT , blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">2691</span> blk <span class="number">19</span> FPW</span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">54</span><span class="operator">/</span>    <span class="number">54</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC468, prev <span class="number">1</span><span class="operator">/</span>EBDDA5E8, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">960</span> oldestRunningXid <span class="number">961</span>; <span class="number">1</span> xacts: <span class="number">961</span></span><br><span class="line">rmgr: Transaction len (rec<span class="operator">/</span>tot):     <span class="number">34</span><span class="operator">/</span>    <span class="number">34</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC4A0, prev <span class="number">1</span><span class="operator">/</span>EBDDC468, <span class="keyword">desc</span>: <span class="keyword">COMMIT</span> <span class="number">2025</span><span class="number">-07</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">04</span>:<span class="number">55.325979</span> CST</span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">50</span><span class="operator">/</span>    <span class="number">50</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC4C8, prev <span class="number">1</span><span class="operator">/</span>EBDDC4A0, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">961</span> oldestRunningXid <span class="number">962</span></span><br><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ </span><br></pre></td></tr></table></figure>
<ol>
<li>FPI_FOR_HINT（全页镜像，为 Hint Bit）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: XLOG len (rec/tot): 49/109, tx: 0, lsn: 1/EBDDA4F8, prev 1/EBDDA4C0, desc: FPI_FOR_HINT , blkref #0: rel 1663/32814/376833 blk 0 FPW</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: XLOG：表示这是 XLOG（日志）资源管理器记录。</li>
<li>FPI_FOR_HINT：全页镜像用于设置 Hint bit。为了避免 Hint bit 修改没有日志而导致数据页 checksum 校验失败，PostgreSQL 会把整个页面写入 WAL（FPW, Full Page Write）。</li>
<li>rel 1663&#x2F;32814&#x2F;376833 blk 0：指的是某个表的第 0 页（block 0），文件标识符是：数据库OID&#x3D;32814，表OID&#x3D;376833。</li>
<li>tx: 0：不是某个事务产生的，而是后台 hint bit 的写入。</li>
<li>FPW：全页写入。</li>
</ul>
<ol start="2">
<li>HOT_UPDATE（堆表中的更新） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Heap len (rec/tot): 69/69, tx: 961, lsn: 1/EBDDA568, prev 1/EBDDA4F8, desc: HOT_UPDATE old_xmax: 961, old_off: 1, old_infobits: [], flags: 0x40, new_xmax: 0, new_off: 2, blkref #0: rel 1663/32814/376833 blk 0</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: Heap：这是 Heap 表的更新记录。</li>
<li>HOT_UPDATE：表示使用了“Heap-Only Tuple”优化，即更新没有修改索引字段，所以新旧 tuple 都在一个页里。</li>
<li>tx: 961：由事务 961 发起。</li>
<li>old_off: 1 -&gt; new_off: 2：第 1 个 tuple 更新为第 2 个位置的 tuple。</li>
<li>old_xmax: 961：原始 tuple 的删除者是当前事务。</li>
<li>new_xmax: 0：新 tuple 尚未被删除。</li>
<li>rel 1663&#x2F;32814&#x2F;376833 blk 0：仍然是这个表第 0 页</li>
</ul>
<ol start="3">
<li>RUNNING_XACTS（记录活跃事务信息） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 54/54, tx: 0, lsn: 1/EBDDA5B0, prev 1/EBDDA568, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 960 oldestRunningXid 961; 1 xacts: 961</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: Standby：这是为备机记录活跃事务信息。</li>
<li>nextXid: 962：下一个将被分配的事务 ID。</li>
<li>latestCompletedXid: 960：最后一个完成的事务。</li>
<li>oldestRunningXid: 961：最老的活跃事务。</li>
<li>1 xacts: 961：当前只有一个活跃事务 961。<br>  这类记录有助于逻辑解码和备机恢复时判断哪些事务是已提交、未提交。</li>
</ul>
<ol start="4">
<li>FPI_FOR_HINT（另一个 hint bit 的全页写入） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: XLOG len (rec/tot): 49/7777, tx: 961, lsn: 1/EBDDA5E8, prev 1/EBDDA5B0, desc: FPI_FOR_HINT , blkref #0: rel 1663/32814/2691 blk 19 FPW</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>又是一个 FPI_FOR_HINT，但这次是针对：<br>  rel 1663&#x2F;32814&#x2F;2691 blk 19：另外一个表的第 19 页。</li>
<li>注意这次记录总长度达到了 7777 字节，很可能是完整的数据页写入（通常 8KB）。</li>
</ul>
<ol start="5">
<li><p>RUNNING_XACTS（再次记录活跃事务）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 54/54, tx: 0, lsn: 1/EBDDC468, prev 1/EBDDA5E8, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 960 oldestRunningXid 961; 1 xacts: 961</span><br></pre></td></tr></table></figure>
<p> 和之前类似，再次记录活跃事务 961。</p>
</li>
<li><p>COMMIT（事务提交）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Transaction len (rec/tot): 34/34, tx: 961, lsn: 1/EBDDC4A0, prev 1/EBDDC468, desc: COMMIT 2025-07-28 16:04:55.325979 CST</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>事务 961 正式提交。</li>
<li>提交时间 是 2025-07-28 16:04:55。</li>
</ul>
<ol start="7">
<li>RUNNING_XACTS（提交后活跃事务清空） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 50/50, tx: 0, lsn: 1/EBDDC4C8, prev 1/EBDDC4A0, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 961 oldestRunningXid 962</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>事务 961 已完成，现在没有活跃事务了。</li>
<li>nextXid 为 962，准备分配给下一个事务。</li>
</ul>
<p>查看日志文件路径  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=# SELECT pg_relation_filepath(&#x27;wal&#x27;);</span><br><span class="line"> pg_relation_filepath </span><br><span class="line">----------------------</span><br><span class="line"> base/32814/376833</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL Structure(Logical-Structure)</title>
    <url>/2025/07/30/postgres/WAL-Structure-Logical-Structure/</url>
    <content><![CDATA[<p>从wal逻辑结构来看，WAL 可被描述为变长日志条目流。每个条目都包含有关特定操作的一些数据，并以标准标头作为前缀。该标头提供的信息包括但不限于：</p>
<ul>
<li>与条目（entry）相关的事务 ID </li>
<li>解释条目的资源管理器</li>
<li>用于检测数据损坏的校验和</li>
<li>条目长度</li>
<li>对前一个 WAL 条目的引用<blockquote>
<p>WAL 通常是按正向读取的，但某些工具（例如 pg_rewind）可能会反向扫描它</p>
</blockquote>
</li>
</ul>
<p>WAL 数据本身可以具有不同的格式和含义。例如，它可能是一段页片段（page fragment），需要替换某个页面中指定偏移处的一部分内容。相应的资源管理器（resource manager）必须知道如何解析并重放这一特定条目。针对表、各种索引类型、事务状态以及其他实体，PostgreSQL 都有独立的资源管理器来处理它们各自的 WAL。</p>
<p>WAL 文件会占用服务器共享内存中的特殊缓冲区。用于 WAL 的缓存大小由参数 wal_buffers 决定。默认情况下，这个大小会自动设为总缓冲区缓存（buffer cache）大小的 1&#x2F;32。</p>
<p>WAL 缓存与缓冲区缓存（buffer cache）非常相似，但它通常以环形缓冲区（ring buffer）的方式运行：新的日志条目被添加到缓冲区的头部，而旧的条目则从尾部开始写入磁盘。如果 WAL 缓存太小，就会比必要的更频繁地进行磁盘同步操作。</p>
<p>在系统负载较低的情况下，插入位置（即缓冲区的头部）几乎总是与已经写入磁盘的条目位置（即缓冲区的尾部）保持一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_lsn <span class="operator">|</span> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">--------------------+---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDC2CD8         <span class="operator">|</span> <span class="number">1</span><span class="operator">/</span>EBDC2CD8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在PostgreSQL 10之前，所有函数名称都包含XLOG首字母缩写词，而不是WAL。</p>
</blockquote>
<p>为了引用某个特定的日志条目，PostgreSQL 使用一种特殊的数据类型：pg_lsn（日志序列号，Log Sequence Number，简称 LSN）。它表示从 WAL 起始位置开始，以字节为单位的 64 位偏移量。LSN 通常以两个十六进制数字表示，中间用斜杠（&#x2F;）分隔。</p>
<p>我们创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> wal(id <span class="type">integer</span>);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> wal <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">启动一个事务，并记录下当前 WAL 插入位置的 LSN。</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA4F8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>现在执行一个任意命令，例如，更新一行数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">UPDATE</span> wal <span class="keyword">SET</span> id <span class="operator">=</span> id <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>页面的修改是在 RAM 中的缓冲区缓存（buffer cache）中进行的。这个更改也会记录在位于 RAM 中的 WAL 页面中。因此，插入的 LSN 会向前推进。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA5E8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>为了确保修改后的数据页是在对应的 WAL 条目之后才被刷新到磁盘，数据页的页头会存储该页最新相关的 WAL 条目的 LSN。你可以使用 pageinspect 插件查看这个 LSN。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> lsn <span class="keyword">FROM</span> page_header(get_raw_page(<span class="string">&#x27;wal&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">    lsn     </span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA5B0</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>整个数据库集群只有一个 WAL，并且新的条目会不断地追加到其中。因此，存储在数据页中的 LSN 可能会比 之前某个时刻 pg_current_wal_insert_lsn() 返回的 LSN 更小。但如果系统中没有发生任何操作，这两个数值将会相同。</p>
<p>现在提交这个事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">commit</span>操作同样被日志记录，同时<span class="keyword">insert</span> lsn再次改变</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDC500</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>为了确保某个 CLog 页在对应的 WAL 条目写入磁盘之前不会被刷新到磁盘，必须追踪该页所对应的最新 WAL 条目的 LSN。但这种 LSN 信息是保存在内存（RAM）中的，而不是存在 CLog 页本身</p>
<p>某个时刻，WAL 日志条目会被写入磁盘；此时，才能把对应的 CLOG 和数据页从缓存中淘汰（evict）。如果必须更早淘汰这些缓存页，那么系统会发现这一点，并会先强制将对应的 WAL 条目写入磁盘。<br>如果你知道两个 LSN（日志序列号）的位置，就可以通过简单地相减计算这两者之间的 WAL 日志大小（以字节为单位）。只需将它们转换为 pg_lsn 类型即可进行减法运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># demo<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="string">&#x27;1/EBDDC500&#x27;</span>::pg_lsn <span class="operator">-</span> <span class="string">&#x27;1/EBDDA4F8&#x27;</span>::pg_lsn;</span><br><span class="line"> ?<span class="keyword">column</span>? </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">     <span class="number">8200</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>在这个具体案例中，更新（update）和提交（commit）操作相关的 WAL 条目大约占用了几千字节。可以用相同的方法，估算某个工作负载在单位时间内产生的 WAL 日志量。<br>这些信息对设置检查点（checkpoint）参数非常重要。</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use pgbench</title>
    <url>/2025/05/14/postgres/pgbench-md/</url>
    <content><![CDATA[<p>pgbench is a benchmarking tool bundled with PostgreSQL, designed to simulate a TPC-B-like workload, not a full TPC-C</p>
<h2 id="1-Initialize-the-Test-Database"><a href="#1-Initialize-the-Test-Database" class="headerlink" title="1. Initialize the Test Database"></a>1. Initialize the Test Database</h2><p>This sets up the schema and populates data.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -i -s 10 mydb</span><br></pre></td></tr></table></figure>
<ul>
<li>-i: Initialize the database.</li>
<li>-s 10: Scale factor. Each scale unit ~100,000 rows in the pgbench_accounts table.</li>
<li>mydb: The database to test.</li>
</ul>
<h2 id="2-Run-a-Simple-Benchmark-Test"><a href="#2-Run-a-Simple-Benchmark-Test" class="headerlink" title="2. Run a Simple Benchmark Test"></a>2. Run a Simple Benchmark Test</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -c 10 -j 2 -T 60 mydb</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 10: 10 concurrent clients.</li>
<li>-j 2: 2 threads.</li>
<li>-T 60: Run for 60 seconds.</li>
<li>mydb: Target database.</li>
</ul>
<p>It will output something like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[postgres@iZ2ze4mflpfiplp0evcw8gZ root]$ pgbench -c 10 -j 2 -T 60 mydb</span><br><span class="line">pgbench (18devel)</span><br><span class="line">starting vacuum...end.</span><br><span class="line">transaction type: &lt;builtin: TPC-B (sort of)&gt;</span><br><span class="line">scaling factor: 10</span><br><span class="line">query mode: simple</span><br><span class="line">number of clients: 10</span><br><span class="line">number of threads: 2</span><br><span class="line">maximum number of tries: 1</span><br><span class="line">duration: 60 s</span><br><span class="line">number of transactions actually processed: 12841</span><br><span class="line">number of failed transactions: 0 (0.000%)</span><br><span class="line">latency average = 46.726 ms</span><br><span class="line">initial connection time = 39.072 ms</span><br><span class="line">tps = 214.013767 (without initial connection time)</span><br><span class="line">[postgres@iZ2ze4mflpfiplp0evcw8gZ root]$</span><br></pre></td></tr></table></figure>
<h2 id="3-Run-Custom-SQL-Scripts"><a href="#3-Run-Custom-SQL-Scripts" class="headerlink" title="3. Run Custom SQL Scripts"></a>3. Run Custom SQL Scripts</h2><p>You can benchmark with custom SQL transactions:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -f myscript.sql -c 10 -T 60 mydb</span><br></pre></td></tr></table></figure>
<p>Where myscript.sql contains something like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM pgbench_accounts WHERE aid = :aid;</span><br><span class="line">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>Use :variable for substitution. We can define variables using -D:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -f myscript.sql -D aid=12345 -D delta=50 -c 10 -T 60 mydb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>page</title>
    <url>/2025/08/11/postgres/page/</url>
    <content><![CDATA[<p>Each page has a certain inner layout that usually consists of the following parts:<br>page header</p>
<ul>
<li>page header</li>
<li>an array of item pointers</li>
<li>free space</li>
<li>items (row versions)</li>
<li>special space</li>
</ul>
<h2 id="Page结构示意图："><a href="#Page结构示意图：" class="headerlink" title="Page结构示意图："></a>Page结构示意图：</h2><style>.pcdsdolufpvf{zoom:50%;}</style>

<h2 id="pageinspect-extension"><a href="#pageinspect-extension" class="headerlink" title="pageinspect extension"></a>pageinspect extension</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE</span> EXTENSION pageinspect;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts;</span><br><span class="line"> id <span class="operator">|</span> client  <span class="operator">|</span> amount </span><br><span class="line"><span class="comment">----+---------+--------</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> bob     <span class="operator">|</span> <span class="number">100.00</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> bob     <span class="operator">|</span> <span class="number">900.00</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> alice   <span class="operator">|</span> <span class="number">800.00</span></span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span> charlie <span class="operator">|</span> <span class="number">100.00</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> lower, upper, special, pagesize <span class="keyword">FROM</span> page_header(get_raw_page(<span class="string">&#x27;accounts&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize </span><br><span class="line"><span class="comment">-------+-------+---------+----------</span></span><br><span class="line">    <span class="number">40</span> <span class="operator">|</span>  <span class="number">8032</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">FROM</span> heap_page_items(get_raw_page(<span class="string">&#x27;accounts&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_off <span class="operator">|</span> lp_flags <span class="operator">|</span> lp_len <span class="operator">|</span> t_xmin <span class="operator">|</span> t_xmax <span class="operator">|</span> t_field3 <span class="operator">|</span> t_ctid <span class="operator">|</span> t_infomask2 <span class="operator">|</span> t_infomask <span class="operator">|</span> t_hoff <span class="operator">|</span> t_bits <span class="operator">|</span> t_oid <span class="operator">|</span>                t_data                </span><br><span class="line"><span class="comment">----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------+--------------------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>   <span class="number">8152</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">758</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">4</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">1282</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b0081e803</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>   <span class="number">8112</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">5</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">2306</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0200000009626f620b00816400</span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span>   <span class="number">8072</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">6</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">2306</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000009626f620b00818403</span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span>   <span class="number">8032</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">758</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">7</span>)  <span class="operator">|</span>       <span class="number">49155</span> <span class="operator">|</span>      <span class="number">10498</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b00812003</span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span>   <span class="number">7992</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">5</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0200000009626f620b00816300</span><br><span class="line">  <span class="number">6</span> <span class="operator">|</span>   <span class="number">7952</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">6</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000009626f620b00818303</span><br><span class="line">  <span class="number">7</span> <span class="operator">|</span>   <span class="number">7912</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">7</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b00811f03</span><br><span class="line">  <span class="number">8</span> <span class="operator">|</span>   <span class="number">7864</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">41</span> <span class="operator">|</span>    <span class="number">809</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">8</span>)  <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>       <span class="number">2562</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000011636861726c69650b00816400</span><br><span class="line">  <span class="number">9</span> <span class="operator">|</span>   <span class="number">7816</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">41</span> <span class="operator">|</span>    <span class="number">811</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">9</span>)  <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>       <span class="number">2050</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0400000011636861726c69650b00816400</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * disk page organization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * space management information generic to any page</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		pd_lsn		- identifies xlog record for last change to this page.</span></span><br><span class="line"><span class="comment"> *		pd_checksum - page checksum, if set.</span></span><br><span class="line"><span class="comment"> *		pd_flags	- flag bits.</span></span><br><span class="line"><span class="comment"> *		pd_lower	- offset to start of free space.</span></span><br><span class="line"><span class="comment"> *		pd_upper	- offset to end of free space.</span></span><br><span class="line"><span class="comment"> *		pd_special	- offset to start of special space.</span></span><br><span class="line"><span class="comment"> *		pd_pagesize_version - size in bytes and page layout version number.</span></span><br><span class="line"><span class="comment"> *		pd_prune_xid - oldest XID among potentially prunable tuples on page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The LSN is used by the buffer manager to enforce the basic rule of WAL:</span></span><br><span class="line"><span class="comment"> * &quot;thou shalt write xlog before data&quot;.  A dirty buffer cannot be dumped</span></span><br><span class="line"><span class="comment"> * to disk until xlog has been flushed at least as far as the page&#x27;s LSN.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pd_checksum stores the page checksum, if it has been set for this page;</span></span><br><span class="line"><span class="comment"> * zero is a valid value for a checksum. If a checksum is not in use then</span></span><br><span class="line"><span class="comment"> * we leave the field unset. This will typically mean the field is zero</span></span><br><span class="line"><span class="comment"> * though non-zero values may also be present if databases have been</span></span><br><span class="line"><span class="comment"> * pg_upgraded from releases prior to 9.3, when the same byte offset was</span></span><br><span class="line"><span class="comment"> * used to store the current timelineid when the page was last updated.</span></span><br><span class="line"><span class="comment"> * Note that there is no indication on a page as to whether the checksum</span></span><br><span class="line"><span class="comment"> * is valid or not, a deliberate design choice which avoids the problem</span></span><br><span class="line"><span class="comment"> * of relying on the page contents to decide whether to verify it. Hence</span></span><br><span class="line"><span class="comment"> * there are no flag bits relating to checksums.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pd_prune_xid is a hint field that helps determine whether pruning will be</span></span><br><span class="line"><span class="comment"> * useful.  It is currently unused in index pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The page version number and page size are packed together into a single</span></span><br><span class="line"><span class="comment"> * uint16 field.  This is for historical reasons: before PostgreSQL 7.3,</span></span><br><span class="line"><span class="comment"> * there was no concept of a page version number, and doing it this way</span></span><br><span class="line"><span class="comment"> * lets us pretend that pre-7.3 databases have page version number zero.</span></span><br><span class="line"><span class="comment"> * We constrain page sizes to be multiples of 256, leaving the low eight</span></span><br><span class="line"><span class="comment"> * bits available for a version number.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Minimum possible page size is perhaps 64B to fit page header, opaque space</span></span><br><span class="line"><span class="comment"> * and a minimal tuple; of course, in reality you want it much bigger, so</span></span><br><span class="line"><span class="comment"> * the constraint on pagesize mod 256 is not an important restriction.</span></span><br><span class="line"><span class="comment"> * On the high end, we can only support pages up to 32KB because lp_off/lp_len</span></span><br><span class="line"><span class="comment"> * are 15 bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* XXX LSN is member of *any* block, not only page-organized ones */</span></span><br><span class="line">	PageXLogRecPtr pd_lsn;		<span class="comment">/* LSN: next byte after last byte of xlog</span></span><br><span class="line"><span class="comment">														 * record for last change to this page */</span></span><br><span class="line">	uint16		pd_checksum;	  <span class="comment">/* checksum */</span></span><br><span class="line">	uint16		pd_flags;		    <span class="comment">/* flag bits, see below */</span></span><br><span class="line">	LocationIndex pd_lower;		<span class="comment">/* offset to start of free space */</span></span><br><span class="line">	LocationIndex pd_upper;		<span class="comment">/* offset to end of free space */</span></span><br><span class="line">	LocationIndex pd_special;	<span class="comment">/* offset to start of special space */</span></span><br><span class="line">	uint16		pd_pagesize_version;</span><br><span class="line">	TransactionId pd_prune_xid; <span class="comment">/* oldest prunable XID, or zero if none */</span></span><br><span class="line">	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; <span class="comment">/* line pointer array */</span></span><br><span class="line">&#125; PageHeaderData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PageHeaderData *PageHeader;</span><br></pre></td></tr></table></figure>

<h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">drop</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> t(</span><br><span class="line">test(# id <span class="type">integer</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>, s text</span><br><span class="line">test(# );</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> t(s);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">INSERT INTO</span> t(s) <span class="keyword">VALUES</span> (<span class="string">&#x27;FOO&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_xact_id();</span><br><span class="line"> pg_current_xact_id </span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line">                <span class="number">766</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>))\gx</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">1</span> ]<span class="comment">-------------------</span></span><br><span class="line">lp          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">lp_off      <span class="operator">|</span> <span class="number">8160</span></span><br><span class="line">lp_flags    <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">lp_len      <span class="operator">|</span> <span class="number">32</span></span><br><span class="line">t_xmin      <span class="operator">|</span> <span class="number">766</span></span><br><span class="line">t_xmax      <span class="operator">|</span> <span class="number">0</span></span><br><span class="line">t_field3    <span class="operator">|</span> <span class="number">0</span></span><br><span class="line">t_ctid      <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">t_infomask2 <span class="operator">|</span> <span class="number">2</span></span><br><span class="line">t_infomask  <span class="operator">|</span> <span class="number">2050</span></span><br><span class="line">t_hoff      <span class="operator">|</span> <span class="number">24</span></span><br><span class="line">t_bits      <span class="operator">|</span> </span><br><span class="line">t_oid       <span class="operator">|</span> </span><br><span class="line">t_data      <span class="operator">|</span> \x0100000009464f4f</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="string">&#x27;(0,&#x27;</span><span class="operator">||</span>lp<span class="operator">||</span><span class="string">&#x27;)&#x27;</span> <span class="keyword">AS</span> ctid,</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">CASE</span> lp_flags</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;unused&#x27;</span></span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;redirect to &#x27;</span><span class="operator">||</span>lp_off</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">&#x27;dead&#x27;</span> </span><br><span class="line">test<span class="operator">-</span># <span class="keyword">END</span> <span class="keyword">AS</span> state,</span><br><span class="line">test<span class="operator">-</span># t_xmin <span class="keyword">as</span> xmin,</span><br><span class="line">test<span class="operator">-</span># t_xmax <span class="keyword">as</span> xmax,</span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">256</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmin_committed, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">512</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmin_aborted, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">1024</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmax_committed, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">2048</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmax_aborted</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">FROM</span> heap_page_items(get_raw_page(<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> ctid  <span class="operator">|</span> state  <span class="operator">|</span> xmin <span class="operator">|</span> xmax <span class="operator">|</span> xmin_committed <span class="operator">|</span> xmin_aborted <span class="operator">|</span> xmax_committed <span class="operator">|</span> xmax_aborted </span><br><span class="line"><span class="comment">-------+--------+------+------+----------------+--------------+----------------+--------------</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> normal <span class="operator">|</span>  <span class="number">766</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> f              <span class="operator">|</span> f            <span class="operator">|</span> f              <span class="operator">|</span> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a href="https://blog.csdn.net/u010217262/article/details/123879205">【转】AntDB&#x2F;PostgreSQL内部原理：表Page结构解析_postgresql对应antdb的版本-CSDN博客</a></p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/05/11/tools/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="about-draft"><a href="#about-draft" class="headerlink" title="about draft"></a>about draft</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;草稿标题&quot;</span><br><span class="line">hexo server --draft</span><br><span class="line">//xxx不带md后缀</span><br><span class="line">hexo publish post xxx </span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress</title>
    <url>/2025/07/31/tools/wordpress/</url>
    <content><![CDATA[<h2 id="Ubuntu安装wordpress"><a href="#Ubuntu安装wordpress" class="headerlink" title="Ubuntu安装wordpress"></a>Ubuntu安装wordpress</h2><ul>
<li><p>安装apache：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2 -y</span><br><span class="line">chown -R www-data:www-data /var/www/html</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装php</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y php php-mysql php-json</span><br><span class="line">yum install php php-mysqlnd php-json</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install php libapache2-mod-php php-mysql -y</span><br><span class="line">apt install php-cli php-curl php-gd php-mbstring php-xml php-zip -y</span><br></pre></td></tr></table></figure></li>
<li><p>安装database</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mariadb-server</span><br><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install mysql-server -y</span><br></pre></td></tr></table></figure>
<p>  修改密码：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;12345&#x27;；</span><br><span class="line"></span><br><span class="line">CREATE DATABASE wordpress_db;</span><br><span class="line">CREATE USER &#x27;wp_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">GRANT ALL PRIVILEGES ON wordpress_db.* TO &#x27;wp_user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装wordpress</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/www/html</span><br><span class="line">wget https://wordpress.org/latest.tar.gz </span><br><span class="line">tar -xvzf latest.tar.gz</span><br><span class="line">chown -R www-data:www-data /var/www/html/wordpress</span><br><span class="line">chmod -R 755 /var/www/html/wordpress</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 Apache 默认虚拟主机配置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>
<p>  找到：<br>  DocumentRoot &#x2F;var&#x2F;www&#x2F;html<br>  改成：<br>  DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress</p>
</li>
<li><p>&#x2F;etc&#x2F;apache2&#x2F;apache2.conf 添加：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www/html/wordpress&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<p>  如果你希望支持 WordPress 的 .htaccess 功能，请保留 AllowOverride All</p>
</li>
<li><p>固定连接</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache2ctl -M | grep rewrite</span><br><span class="line">a2enmod rewrite</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>
<p>  在 WordPress 后台重新保存固定链接</p>
</li>
<li><p>重启服务</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
</search>
