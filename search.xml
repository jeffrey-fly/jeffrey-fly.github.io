<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B树索引（postgres）</title>
    <url>/2025/07/10/database/B%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>存储引擎之所以能够快速定位数据，离不开索引。B树索引是历经考验、使用最广泛的一种索引结构。pg中的B树索引是为ordinal data types（可以比较和排序）设计的。</p>
<h2 id="一-结构"><a href="#一-结构" class="headerlink" title="一 结构"></a>一 结构</h2><p>每一个节点就是一个页（Page）。page的大小定义决定了索引node的容量；每个节点（node）由多个element组成（element包括 索引key 和 一个指针）。内部节点中的元素指向下一层的节点；叶子节点中的元素则指向堆中的元组。这种结构就是 PostgreSQL 中 B-Tree 索引的基础：内部节点用于导航，叶子节点保存指向真实数据的引用。</p>
<h2 id="二-特性"><a href="#二-特性" class="headerlink" title="二 特性"></a>二 特性</h2><ol>
<li>有序(Orderable): 所有 B-Tree 索引按照给定的顺序存储值，支持 ASC&#x2F;DESC 和 NULLS FIRST&#x2F;LAST 等排序选项</li>
<li>叶子结点存储数据（key以及tuple的指针），内部结点存储key</li>
<li>每一层除了最有结点，均存储一个高键（high key）：每个节点中最大的值。The first entry in this page contains the high key</li>
<li>叶子页之间有双向链表指针（左兄弟&#x2F;右兄弟），用于范围扫描（BETWEEN、ORDER BY 等范围查询优化）。</li>
</ol>
<h2 id="三-多列索引"><a href="#三-多列索引" class="headerlink" title="三 多列索引"></a>三 多列索引</h2><p>一个索引文件，存储多列键值组合：索引条目（index tuple）中存储这几列的值作为一个组合键。<br>多列索引的比较是逐列进行的，先比较第1列 a，如果相等，再比较第2列 b，依次类推。pg使用逐字段比较器（每列使用其数据类型对应的 &lt; 运算符）逐列比较<br>默认情况下，索引值是按照升序（ASC）排列的，但如果需要，你也可以指定为降序（DESC）。如果索引是基于单列创建的，排序顺序通常无所谓，因为扫描可以沿任意方向进行。但在多列索引中，排序顺序就变得很重要了。</p>
<h3 id="PostgreSQL-多列-B-tree-索引的匹配原则"><a href="#PostgreSQL-多列-B-tree-索引的匹配原则" class="headerlink" title="PostgreSQL 多列 B-tree 索引的匹配原则"></a>PostgreSQL 多列 B-tree 索引的匹配原则</h3><ul>
<li>PostgreSQL 的多列索引（比如 (a, b)）是按列的 最左前缀（left-prefix）顺序构建的。</li>
<li>能有效利用索引的条件，必须从第一列开始匹配，且满足索引的顺序关系。</li>
</ul>
<p>PostgreSQL 多列索引中，当你只指定了“非第一列”的查询条件时，理论上有一种优化方法叫做 Skip Scan:<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_ab ON mytable(a, b);</span><br><span class="line">SELECT * FROM mytable WHERE b = 42;</span><br></pre></td></tr></table></figure>
<p>这个时候由于 没有给出 a 的值，PostgreSQL 的 B-tree 无法用这个索引来直接查找。</p>
<p>但是，理论上如果第一列（a）的取值不多，比如只有 v1, v2, …, vn，查询可以被改写为多次扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mytable WHERE a = v1 AND b = 42;</span><br><span class="line">SELECT * FROM mytable WHERE a = v2 AND b = 42;</span><br><span class="line">...</span><br><span class="line">SELECT * FROM mytable WHERE a = vn AND b = 42;</span><br></pre></td></tr></table></figure>
<p>每次都能利用索引 (a, b) 的“最左前缀”性质进行查找，然后再合并结果。这就是 Skip Scan 的思路。</p>
<p>PostgreSQL 当前 不支持 Skip Scan</p>
<h2 id="四-include"><a href="#四-include" class="headerlink" title="四 include"></a>四 include</h2><p>B-tree 索引还可以通过 INCLUDE 子句扩展额外的列，这些列不参与查找，但可以包含在索引中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_ab_inc ON t(a, b) INCLUDE (c, d);</span><br></pre></td></tr></table></figure>
<p>这样可以使某些 SELECT 查询满足 Index-Only Scan（覆盖索引），避免回表. 类似于mysql 的聚族索引（和聚族索引不同的是：include属于冗余存储）</p>
<h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> SELECT p.name,</span><br><span class="line">       pg_index_has_property(&#x27;flights_pkey&#x27;, p.name)</span><br><span class="line">FROM unnest(array[</span><br><span class="line">  &#x27;clusterable&#x27;,</span><br><span class="line">  &#x27;index_scan&#x27;,</span><br><span class="line">  &#x27;bitmap_scan&#x27;,</span><br><span class="line">  &#x27;backward_scan&#x27;</span><br><span class="line">]) p(name);</span><br><span class="line"></span><br><span class="line">      name        | pg_index_has_property</span><br><span class="line">------------------+-----------------------</span><br><span class="line"> clusterable      | t</span><br><span class="line"> index_scan       | t</span><br><span class="line"> bitmap_scan      | t</span><br><span class="line"> backward_scan    | t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="clusterable"><a href="#clusterable" class="headerlink" title="clusterable"></a>clusterable</h3><p>clusterable 表示索引是否支持用于 CLUSTER 操作。<br>CLUSTER 命令会按照指定的索引顺序，对表中的数据行进行物理重排，让表的数据页顺序与索引顺序一致。<br>这样可以提高基于该索引的扫描性能，因为数据的物理顺序和索引顺序相同，减少随机 I&#x2F;O。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLUSTER my_table USING my_index;</span><br></pre></td></tr></table></figure>
<ul>
<li>会根据 my_index 的顺序，重新排列 my_table 的物理存储。</li>
<li>聚簇后的表，在按该索引扫描时性能更好</li>
</ul>
<h4 id="影响和注意点"><a href="#影响和注意点" class="headerlink" title="影响和注意点"></a>影响和注意点</h4><ul>
<li>聚簇是一次性操作，执行后数据会按索引顺序存储，但后续的 INSERT、UPDATE 可能打乱这个顺序。</li>
<li>如果表数据频繁更新，聚簇效果会逐渐减弱，需要定期重新执行 CLUSTER。</li>
<li>聚簇对大表的操作比较重，执行时表会被锁。</li>
</ul>
<h3 id="index-scan"><a href="#index-scan" class="headerlink" title="index_scan"></a>index_scan</h3><p>索引是否支持普通的 Index Scan（例如 WHERE id &#x3D; 123）</p>
<h3 id="bitmap-scan"><a href="#bitmap-scan" class="headerlink" title="bitmap_scan"></a>bitmap_scan</h3><p>Bitmap Scan 是 PostgreSQL 查询计划中的一种索引访问方法，主要用于当多个条件组合过滤时，或者单个索引扫描返回大量行时，提高访问效率的技术。<br>它分两步完成：</p>
<ol>
<li>Bitmap Index Scan：先扫描索引，找到所有符合条件的行的 TID（物理行指针），把它们用一个“位图”（bitmap）来表示；</li>
<li>Bitmap Heap Scan：再根据这个位图去访问表的 heap 页，只读取需要的行，避免全表扫描。</li>
</ol>
<h4 id="为什么要用-Bitmap-Scan？"><a href="#为什么要用-Bitmap-Scan？" class="headerlink" title="为什么要用 Bitmap Scan？"></a>为什么要用 Bitmap Scan？</h4><ol>
<li>当单个条件筛选出的行比较多时，普通索引扫描会频繁跳页，导致随机 I&#x2F;O 增加。</li>
<li>多个条件联合过滤时，可以对多个索引分别做 Bitmap Index Scan，合并位图后再访问表。</li>
<li>通过先用位图标记符合条件的行，再按物理顺序访问表页，减少随机访问，提高缓存命中率。</li>
</ol>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>适合返回大量结果的索引查询；</li>
<li>通过减少随机访问，降低 I&#x2F;O；</li>
<li>支持多个索引结果合并，提高复杂查询效率。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>需要额外的内存存储位图，位图过大会消耗较多资源；</li>
<li>对于返回行很少的查询，普通索引扫描往往更快。</li>
</ol>
<h3 id="backward-scan"><a href="#backward-scan" class="headerlink" title="backward_scan"></a>backward_scan</h3><p>即索引扫描支持双向遍历：可以从索引的左端（最小键）开始向右扫描，也可以从索引的右端（最大键）开始向左扫描。例如 ORDER BY id DESC 时利用该索引</p>
<h2 id="关于索引膨胀"><a href="#关于索引膨胀" class="headerlink" title="关于索引膨胀"></a>关于索引膨胀</h2><p>索引可能会随着插入和删除不断膨胀，而不会自然收缩，需要通过重建或 REINDEX 来处理。</p>
<ol>
<li>当需要向节点中插入数据而发现节点已满时，PostgreSQL 会先尝试“修剪”冗余数据（例如：删除已过期或无效的元组），希望通过回收空间来避免进一步拆分。</li>
<li>在 PostgreSQL 的 B-tree 实现中，节点一旦因为插入新数据而被拆分，就不会再被合并回来。哪怕后续通过 vacuum 操作清理了旧数据，节点中元素数量减少，也不会自动合并。</li>
<li>标准的 B-tree 数据结构理论上是支持合并操作的（比如删除数据后可合并空节点），但 PostgreSQL 的实现为了简化逻辑或出于性能原因，没有实现这一特性</li>
</ol>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>postgres internals 14</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTables and LSM Trees</title>
    <url>/2025/11/08/database/SSTables-and-LSM-Trees/</url>
    <content><![CDATA[<p>SSTables：Sorted String Table ： 每个segment文件中key值是有序（根据key值排序）并且唯一的。sstable有如下优势：</p>
<ul>
<li>merge简单高效</li>
<li>因为有序，不需要维护所有记录的索引，可以是稀疏索引</li>
<li>因为有序，可以按block进行压缩同时维护索引，除了降低磁盘占用以外，还可以降低磁盘io</li>
</ul>
<h2 id="构建和管理SSTables"><a href="#构建和管理SSTables" class="headerlink" title="构建和管理SSTables"></a>构建和管理SSTables</h2><p>因为写入是无序的，所以我们需要在内存中借助于红黑树或者avl树等数据结构来保证：任意写入，有序读取.</p>
<p>构建步骤如下:</p>
<ol>
<li>当写入发生时，将写入的key-value加入内存平衡树（如红黑树）中，称为”memtable”</li>
<li>当memtable增大到一定阈值后（a few megabytes），将memtable写入磁盘生成一个SSTable文件。新写入的SSTable成为数据库中最新的segment文件。 写入SSTable到磁盘时，写入可以继续写入新的memtable</li>
<li>读请求来时，优先在memtable中查找，然后按顺序从新到老查找磁盘上的segment文件</li>
<li>随着时间的推移，可以后台启动合并和压缩segment文件、丢弃或者覆盖掉老的文件</li>
</ol>
<p>这种机制工作的很好，但是存在一个问题，如果数据库宕机了，内存中的memtable还没有来得及写入磁盘，可能造成数据丢失。可以通过一个单独的log文件来记录所有的操作，这个log的作用只是用于宕机恢复memtable，每当memtable被写入磁盘，相应的log文件就可以被丢弃了</p>
<h2 id="用SSTables构建LSM-tree"><a href="#用SSTables构建LSM-tree" class="headerlink" title="用SSTables构建LSM-tree"></a>用SSTables构建LSM-tree</h2><p>LSM-Tree用于 LevelDB 和 RocksDB、嵌入其他应用的key-value存储引擎。参考：Google’s Bigtable paper</p>
<p>SSTables + log &#x3D; “Log-Structured Merge-Tree ”</p>
<h3 id="LSM-tree两种文件管理策略："><a href="#LSM-tree两种文件管理策略：" class="headerlink" title="LSM-tree两种文件管理策略："></a>LSM-tree两种文件管理策略：</h3><ol>
<li><p>Size-Tiered Compaction（STC） </p>
<ul>
<li><p>基本思想<br>  “当某一层（或同一大小区间）的 SSTable 文件数达到阈值时，将它们合并成一个更大的文件。”<br> 也就是说，不是按“层级”，而是按“文件大小”来触发 compaction。</p>
</li>
<li><p>结构示意<br> MemTable → SSTable</p>
</li>
<li><p>优点</p>
<ul>
<li>写放大低<br>  每条数据在被 flush 后只会参与少数几次合并；每次合并是“几块 → 一块”，合并次数较少。</li>
<li>写入吞吐高<br>  flush 后直接落地；合并是批量异步进行；对写性能非常友好。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>读放大高<br>  同一 key 可能存在于多个 SSTable 中；读时需要查多个文件（除非借助 Bloom Filter）。</li>
<li>空间放大高<br>  合并不够积极；多个旧版本的数据同时存在；临时文件和重复 key 较多。</li>
</ul>
</li>
<li><p>应用场景<br> 适合写多读少的场景；比如日志系统、时间序列数据库（TSDB）、写入密集的监控系统Cassandra 默认采用 STCS（Size-Tiered Compaction Strategy）</p>
</li>
</ul>
</li>
<li><p>Level Compaction（LC）<br> 这种策略是 LevelDB、RocksDB 采用的，更现代化。又叫 leveled compaction 或 分层压实。</p>
<ul>
<li><p>基本思想：<br> 数据被组织成多个层级（Level 0, Level 1, Level 2…），每一层都有固定大小的空间限制，同一层内文件的 key 范围 互不重叠。</p>
</li>
<li><p>层次结构：<br> Level 0: 多个小 SSTable，key 范围可能重叠。<br> Level 1: 较大文件，key 范围不重叠。<br> Level 2: 更大文件，key 范围不重叠。<br> …</p>
</li>
<li><p>Compaction 逻辑：<br> 当某一层（如 Level 0）容量超标；就选择一个 SSTable（或一组）与下一层（如 Level 1）中 key 范围重叠的文件；合并、去重、重写为更大的 SSTable，放入下一层。</p>
</li>
<li><p>优点</p>
<ul>
<li>读性能优异<br>  除 Level 0 外，其余层内文件 key 范围不重叠；读取某个 key 只需查找每层最多一个文件；查找代价从 O(n_files) 降到 O(levels)。</li>
<li>空间利用率高<br>  去重及时；每层占用空间接近固定比例；不容易膨胀。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>写放大高<br>  每条数据会多次参与合并（从 L0 → L1 → L2…）；每次都要重写到下一层； 磁盘写入量是原始写入的数倍。</li>
<li>Compaction 代价大<br>  大文件之间的合并非常消耗 I&#x2F;O；RocksDB 必须限制后台 compaction 线程数量。</li>
</ul>
</li>
<li><p>应用场景<br> 适合读写比较均衡、查询多的系统；比如 RocksDB、LevelDB、TiKV、ClickHouse 的部分引擎。</p>
</li>
</ul>
</li>
</ol>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>当查找的key在数据库中不存在时，LSM-Tree算法可能会变慢：在你确认key不存在之前，你需要检查所有memtable，所有sstable对应的磁盘文件。可以使用bloom filters：它可以检查key不在数据库中（每个sstable固化时，生成对应的bloom filter文件）</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Lehman–Yao B-tree</title>
    <url>/2025/11/22/database/Lehman%E2%80%93Yao-B-tree/</url>
    <content><![CDATA[<h2 id="1-Lehman–Yao-B-Trees"><a href="#1-Lehman–Yao-B-Trees" class="headerlink" title="1. Lehman–Yao B*-Trees"></a>1. Lehman–Yao B*-Trees</h2><p>Lehman–Yao构造了一个供并发进程使用的数据结构。该数据结构是 Wedekind提出的 B*-树的一个简单变体（其基础是 Bayer 和 McCreight定义的 B 树）。<br>Lehman–Yao B*-树定义如下。</p>
<h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><ol>
<li>Each path from the root to any leaf has the same length, h.</li>
<li>内部节点（非 root、非叶子）至少要有 k + 1 个孩子（sons）。 (k is a tree parameter; 2k is the maximum number of elements in a node, neglecting the “high key,” which is explained below.)</li>
<li>root要么是页节点要么至少有两个孩子（sons）</li>
<li>每个node最多有2k+1个孩子（sons）</li>
<li>Lehman–Yao B-tree中的所有数据的键（key）都存储在叶子节点中，叶子节点还包含指向数据库记录的指针（每一条记录都与一个 key 对应）。<br>非叶子节点包含指针，以及用于沿着这些指针继续查找的 key 值（b+ tree）。</li>
</ol>
<p>B*-树的节点看起来如图 1 所示。Ki 表示 key 域的实例Pi 表示指针。Pi 可以指向其他节点，或者——在叶子节点的情况下——指向与存储在叶子节点中的 key 值关联的记录。这种安排使得在我们的模型中，叶子节点和非叶子节点的结构基本相同。M 是一个标记，用于指示该节点是叶子节点，它占据了非叶子节点中第一个指针的位置。图 2 显示了一个 B*-树示例。</p>
<h3 id="1-2-Sequencing（顺序规则）"><a href="#1-2-Sequencing（顺序规则）" class="headerlink" title="1.2 Sequencing（顺序规则）"></a>1.2 Sequencing（顺序规则）</h3><ol>
<li>每个节点内部，key 按升序排列。</li>
<li>在 B*-tree 中，有时会在非叶子节点追加一个额外的值，称为 “high key”（见图 3）。</li>
<li>在任意节点 N 中，每个指针 Pi 指向一个子树 Ti（Pi 指向的节点为 Ti 的根）。Ti 中存储的 key 值被 Pi 左右的两个 key （Ki 和 Ki+1）界定。 这就给非叶子节点提供了一组 (pointer, value) 对    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key(Ti) ∈ (Ki-1, Ki]</span><br></pre></td></tr></table></figure>
 其中，k0 &#x3D; -∞（在 N 中物理上不存在），K2k+1 &#x3D; high key（如果存在），high key 提供了 Pi 指向的子树的上界，因此它也是以 N 为根的子树中所有值的上界。<br>叶子节点 定义类似（见图 3）：Ki &#x3D; 叶子中存储的 key；Pi &#x3D; 指向对应记录的指针</li>
</ol>
<h3 id="1-3-Insertion-Rule-插入规则"><a href="#1-3-Insertion-Rule-插入规则" class="headerlink" title="1.3 Insertion Rule(插入规则)"></a>1.3 Insertion Rule(插入规则)</h3><ol>
<li>如果一个叶子节点的条目（entries）少于 2k 个，那么一个新的条目以及指向其对应记录的指针可以直接插入到该节点中。</li>
<li>如果一个叶子节点已有 2k 个条目，则插入新的条目时，需要通过将该节点分裂为两个节点来进行，每个新节点包含原节点一半的条目。新的条目会被插入到这两个节点中的一个（在合适的位置）。由于其中一个节点是新创建的，因此必须在原单节点的父节点中插入一个新的指针。这个新的指针指向新节点；新的键值是对应于原节点拆分后左半部分的键值。此外，需要为这两个新节点分别设置高键（high key）。图 4 展示了一个节点分裂的示例。</li>
<li>对非叶子节点的插入操作与叶子节点完全相同，只是指针指向的是子节点，而不是数据记录。</li>
</ol>
<p>一个节点（按照上面给出的规则），如果条目数少于 2k，则称其为“安全节点”（就插入操作而言），因为插入可以通过对该节点的简单操作完成。同样，如果一个节点有 2k 个条目，则称其为“非安全节点”，因为必须进行分裂操作。对节点的删除操作也有类似的定义：如果删除可以在节点内完成而不会影响其他节点，则该节点称为“安全节点”；反之，如果删除会影响其他节点，则称为“非安全节点”。也就是说，如果节点的条目数多于 k + 1，则安全；如果恰好有 k + 1 条目，则非安全。</p>
<p>一个简单的例子就足以说明，对 B*-树进行并发操作的简单做法是错误的。<br>考虑图 5a 所示的 B*-树片段。假设有两个进程：一个搜索值 15，另一个插入值 9。插入操作应当导致树结构修改为图 5b 所示的样子。现在考虑下面这一系列操作：  </p>
<table>
<thead>
<tr>
<th>select(15)</th>
<th>insert(9)</th>
</tr>
</thead>
<tbody><tr>
<td>C&lt;-read(x)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>A&lt;-read(x)</td>
</tr>
<tr>
<td>exam C;get ptr to y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>exam A;get ptr to y</td>
</tr>
<tr>
<td></td>
<td>A &lt;- read(y)</td>
</tr>
<tr>
<td></td>
<td>insert 9 into A; must split into A, B</td>
</tr>
<tr>
<td></td>
<td>PUT(B, Y’)</td>
</tr>
<tr>
<td></td>
<td>PUT(A, Y)</td>
</tr>
<tr>
<td></td>
<td>Add to node x a pointer to node y’.</td>
</tr>
<tr>
<td>C &lt;- read(y)</td>
<td></td>
</tr>
<tr>
<td>error!15 not found</td>
<td></td>
</tr>
</tbody></table>
<p>问题在于，搜索操作首先返回指向 y 的指针（从 X 获得），然后才读取包含 y 的页面。在这两个操作之间，插入操作已经修改了树的结构。</p>
<h2 id="2-Previous-Approaches"><a href="#2-Previous-Approaches" class="headerlink" title="2. Previous Approaches"></a>2. Previous Approaches</h2><p>前面的例子表明，对并发 B 树问题采取简单做法是行不通的：如果不防范并发操作带来的潜在问题，多个进程的操作可能导致结果不正确。为了更好地理解这个问题，我们在此简要概述一些已经提出的其他方法和解决方案。</p>
<p>针对并发 B 树问题的第一个解决方案是由 Samadi 提出的.他的做法是最直接的一种，并且是最早考虑并发问题的方法。该方案简单地使用信号量来独占锁定任何一次树结构修改可能经过的整条路径。这实际上锁定了受影响的最高节点所在的整个子树</p>
<p>Bayer 和 Schkolnick 提出的算法对 Samadi 的方法进行了实质性的改进。他们提出了一种用于 B*-树并发操作的方案；该方案包含一些参数，可以根据所需的并发程度和类型进行设置。<br>首先，修改操作会对树的上部节点加写者排他锁（writer-exclusion locks）（这种锁只排斥其他写者，而不会阻止读者）。<br>当需要真正进行修改操作时，会施加独占锁（exclusive locks），大多应用在树的下部节点。<br>这种对独占锁的稀疏使用提高了算法的并发性能。</p>
<p>Miller 和 Snyder [12] 研究了一种方案，该方案锁定树中一个有界大小的区域。该算法使用先导锁（pioneer locks）和跟随锁（follower locks），以防止其他进程进入当前进程正在修改的树区域。被锁定的区域沿树向上移动，同时执行相应的修改操作.在使用队列管理的锁策略的帮助下，沿树向下移动的读者可以“越过”被锁定的区域，从而避免死锁。这种算法与本文提出的算法的权衡在于：本文的算法锁定树的区域明显更小，但需要对普通的 B-tree 或 B*-tree 结构进行稍微的修改，以便支持并发。</p>
<p>Ellis [6] 提出了一种针对 2-3 树的并发解决方案。文中采用了几种方法以提高并发能力，并且（据称）这些方法可以很容易地推广到 B 树。<br>该论文应用了两种思想：一是在相反方向上对一组数据进行读写（由 Lamport [11] 提出）；二是允许数据结构暂时出现轻微退化，同时允许进程不必立即完成操作，可以将工作推迟到更合适的时间再执行。</p>
<p>Guibas 和 Sedgewick [6a] 提出了一种针对平衡树的统一“双色框架”（dichromatic framework）。这是一种研究平衡树的简化方法：它将所有平衡树方案归约为“带颜色”的二叉树的特例，并具有概念上的清晰性。这些作者利用他们的框架研究一种自上而下的并发锁定方案，其中包括在沿树向下访问时对“几乎满的”节点进行分裂。我们预计，他们的方案将锁定比我们的方案更多的节点（降低并发性），并且需要略多的存储空间。</p>
<p>另一种针对 B 树并发操作的方法目前正在由 Kwong 和 Wood [10] 进行研究。</p>
<h2 id="3-Blink-Tree-for-Concurrency"><a href="#3-Blink-Tree-for-Concurrency" class="headerlink" title="3. Blink-Tree for Concurrency"></a>3. Blink-Tree for Concurrency</h2><p>B-link 树是一种在 B*-树基础上修改而成的结构，它在每个节点中增加了一个“链接（link）”指针字段（记作 P2k+1 ——见图 6）。<br>（B-link-tree 的发音是 “Blink-tree”。）   </p>
<p>这个链接指针指向当前节点所在层的下一个节点；只有在该层最右侧的节点中，这个链接指针才是空指针（null）。这样的链接指针定义是自洽的，因为所有叶子节点都位于树的同一层。  </p>
<p>因此，在 B-link 树中，同一层的所有节点都被连接成一条链表，如图 7 所示。</p>
<p>Link 指针的目的，是提供一种到达某个节点的额外途径。<br>当一个节点因为数据溢出而被分裂时，原来的单一节点会被两个新的节点取代。</p>
<p>在分裂后：</p>
<ul>
<li><p>第一个新节点的 link 指针指向第二个新节点；</p>
</li>
<li><p>第二个新节点的 link 指针则保存了原来旧节点的 link 指针内容。</p>
</li>
</ul>
<p>通常情况下，第一个新节点会占用旧节点在磁盘上的同一个物理页面。</p>
<p>设计这个方案的意图是：<br>因为这两个新节点被 link 指针连接起来，在父节点中的正确指针尚未更新之前，它们在功能上仍然等价于原来的那个单一节点。<br>Blink-tree 的精确查找与插入算法将在接下来的两个章节中给出。</p>
<p>对于树中的任意一个节点（处于某一层且不是该层的第一个节点），通常会有两种指针指向它：</p>
<p>来自其父节点的“子指针”（son pointer），以及</p>
<p>来自其左兄弟节点的 link 指针。</p>
<p>当一个节点被插入到树中时，这两个指针之中必定有一个会先被创建。<br>我们规定：在这两个指针中，link 指针必须最先存在。<br>也就是说，一个节点在树中出现时，可以暂时没有父节点的指针指向它，但必须已经有一个左兄弟指向它的 link 指针。</p>
<p>这种结构依然被定义为一个合法的树结构，因为新的“右兄弟”节点可以通过“左兄弟”到达。（这两个兄弟节点在功能上仍然可以视作一个节点。）</p>
<p>当然，为了保证良好的查找效率，来自父节点的指针必须尽快补上。</p>
<p>Link 指针的优势在于：它会在节点发生分裂时同步建立。<br>因此，即使针对新节点的常规树指针尚未全部更新完毕，link 指针仍可作为一种“临时修补”机制，使并发操作保持正确性。</p>
<p>当查找键大于节点的最大键值（由 high key 标识）时，这表明树结构已经发生变化，此时应通过 link 指针继续访问右兄弟节点。<br>虽然这种方式略低效一些（因为需要额外一次磁盘读取来跟随 link 指针），但它仍然是到达目标叶子节点的正确路径。</p>
<p>由于节点分裂本身属于例外情况，link 指针的实际使用频率应该非常低。</p>
<p>Blink-tree 结构的另一个优点是：在对树进行顺序遍历时，link 指针可以用于快速按“按层次优先（level-major）”的顺序检索树中的所有节点，或者，例如，只检索所有叶子节点。</p>
<h2 id="4-THE-SEARCH-ALGORITHM"><a href="#4-THE-SEARCH-ALGORITHM" class="headerlink" title="4. THE SEARCH ALGORITHM"></a>4. THE SEARCH ALGORITHM</h2><h3 id="4-1-算法示意图（Algorithm-Sketch）"><a href="#4-1-算法示意图（Algorithm-Sketch）" class="headerlink" title="4.1 算法示意图（Algorithm Sketch）"></a>4.1 算法示意图（Algorithm Sketch）</h3><p>要在树中查找一个值 v，搜索过程从根节点开始，沿树向下比较 v 与每个节点中的键值。在每个节点中，比较键值后，决定沿节点中哪条现有指针继续向下搜索，指示应沿该指针前往下一层节点，或直接到达叶子（记录）节点。</p>
<p>如果搜索过程中检查某个节点时，发现该节点中的最大值小于 v，则可以推断出当前节点发生了一些变化，而这些变化在搜索检查其父节点时尚未反映到父节点中。</p>
<p>这意味着当前节点已经被分裂成两个（或更多）新的节点。<br>此时，搜索必须纠正其在树中的位置错误：不再按照普通的父节点子指针（son pointer）前进，而是沿新分裂节点的 link 指针继续搜索。</p>
<p>搜索过程最终会到达 v 应该所在的叶子节点（如果 v 存在的话）。此时，该节点要么包含 v，要么不包含 v 且节点中的最大值大于 v。<br>因此，该算法能够正确地判断 v 是否存在于树中。</p>
<h2 id="4-2-算法"><a href="#4-2-算法" class="headerlink" title="4.2 算法"></a>4.2 算法</h2><p><strong>搜索（Search）</strong><br>该过程用于在树中查找一个值 𝑣。如果 𝑣 存在于树中，过程结束时：𝐴包含包含 𝑣 的节点 𝑡<br>包含指向与 𝑣 关联的记录的指针；如果 𝑣 不存在于树中，𝐴 将包含 𝑣 如果存在的话应该所在的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Search(v):</span><br><span class="line">    ...</span><br><span class="line">    if v exists:</span><br><span class="line">        A = 节点页 containing v</span><br><span class="line">        t = 指向 v 的记录</span><br><span class="line">    else:</span><br><span class="line">        A = 节点页 where v would be</span><br><span class="line">        t = null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下文算法中使用的符号在第 2 节中定义。<br>在此过程中，我们使用了一个辅助操作 scannode，其定义如下：</p>
<blockquote>
<p>x &lt;- scannode(u, A) denotes the operation of examining the tree node in memory block A for value u and returning the appropriate pointer from A (into x).</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure search(u)</span><br><span class="line">current &lt;- root;</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">while current is not a leaf do </span><br><span class="line">begin</span><br><span class="line">  current &lt;- scannode(u, A);</span><br><span class="line">  A &lt;- get(current) </span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">while t &lt;- scannode(u, A) = link ptr of A do</span><br><span class="line">begin</span><br><span class="line">  current + t ;</span><br><span class="line">  A &lt;- get(current)</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">if v is in A then done “success” else done “failure”</span><br></pre></td></tr></table></figure>
<p>请注意，这种搜索过程非常简单，其行为与非并发搜索完全相同，将 link 指针与其他指针同等对待。</p>
<p>还要注意，该过程不进行任何形式的加锁。<br>这与传统的数据库搜索算法形成对比（例如 Bayer 和 Schkolnick [3] 所述），在那些算法中，所有搜索操作都会对它们访问的节点进行读锁。</p>
<h2 id="5-THE-INSERTION-ALGORITHM"><a href="#5-THE-INSERTION-ALGORITHM" class="headerlink" title="5. THE INSERTION ALGORITHM"></a>5. THE INSERTION ALGORITHM</h2><h3 id="5-1-算法示意图（Algorithm-Sketch）"><a href="#5-1-算法示意图（Algorithm-Sketch）" class="headerlink" title="5.1 算法示意图（Algorithm Sketch）"></a>5.1 算法示意图（Algorithm Sketch）</h3><p>要在树中插入一个值 𝑢 我们执行的操作与前面描述的搜索过程类似。从根节点开始，沿树向下扫描，直到到达应该包含 𝑢 的叶子节点。同时，我们在下降过程中记录每一层中被访问过的最右节点。沿树的下降过程实际上就是在搜索 𝑢 的正确插入位置（比如称该节点为节点 𝑎 ）。</p>
<p>将值 u 插入叶子节点时，可能需要对该节点进行分裂（当节点不安全时）。<br>在这种情况下，我们对节点进行分裂（如图 8 所示），用两个新节点 a’（a 的新版本，写回同一磁盘页面）和 b’ 替换原来的节点 a。节点 a’ 和 b’ 的内容与原节点 a 相同，只是增加了值 u。随后，我们沿着先前记录的搜索路径回溯树的上层，在叶子节点的父节点中插入新节点 b’ 的条目以及 a’ 的新 high key。</p>
<p>死锁的避免是由锁定方案的良序性（well-ordering）所保证的，如下所示。<br>需要注意的是，当我们沿树向上回溯时，由于节点可能被分裂，我们必须插入新指针的节点可能并不是下降过程中经过的那个节点。换句话说，我们在下降过程中使用的旧节点可能已经被分裂；此时，正确的插入位置就在原预期插入位置右侧的某个节点。我们通过 link 指针 来找到这个节点。</p>
<h3 id="5-2-算法"><a href="#5-2-算法" class="headerlink" title="5.2 算法"></a>5.2 算法</h3><p>在下文的算法中，有些过程被视为原语操作（就像上文的 scannode 一样），因为它们容易实现，并且其具体操作对本文的目的而言并不重要。例如：</p>
<blockquote>
<p>A &lt;- node.insert (A, w, v) denotes the operation of inserting the pointer w and the value v into the node contained in A.<br>u &lt;- allocate(2 newpage for B) denotes the operation of allocating a new page on the disk. The node contained in B will be written onto this page, using the pointer u.<br>“A, B &lt;- rearrange old A, adding ..” denotes the operation of splitting A into two nodes, A and B, in core.</p>
</blockquote>
<p><strong>插入（Insert）</strong>。该算法负责将一个值 v（以及其关联的记录）插入到树中。当算法结束时，值 v 已成功插入到树中，并且在必要的情况下，算法会在从叶子向上回溯的过程中对相应的节点进行分裂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure insert(v)</span><br><span class="line">initialize stack;</span><br><span class="line">current &lt;- root;</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">while current is not a leaf do</span><br><span class="line">begin</span><br><span class="line">  t &lt;-  current;</span><br><span class="line">  current &lt;- scannode( v, A);</span><br><span class="line">  if new current was not link pointer in A then</span><br><span class="line">    push(t);</span><br><span class="line">  A &lt;- get(current);</span><br><span class="line">end;</span><br><span class="line">lock(current);</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">move.right;</span><br><span class="line">if v is in A then stop “v already exists in tree”;</span><br><span class="line">w &lt;- pointer to pages allocated for record associated with v; </span><br><span class="line">Doinsertion:</span><br><span class="line">if A is safe then</span><br><span class="line">begin</span><br><span class="line">  A &lt;-  node.insert(A, w, v); </span><br><span class="line">  put(A, current); </span><br><span class="line">  unLock(current);</span><br><span class="line">end else begin</span><br><span class="line">  u &lt;- allocate(1 new page for B);</span><br><span class="line">  A, B &lt;- rearrange old A, adding v and w, to make 2 nodes,</span><br><span class="line">    where (link ptr of A, link ptr of B) &lt;- (u, link ptr of old A);</span><br><span class="line">  y &lt;- max value stored in new A;</span><br><span class="line">  put(B, u)</span><br><span class="line">  put(A, current); </span><br><span class="line">  oldnode &lt;- current;</span><br><span class="line">  v &lt;- Y;</span><br><span class="line">  w &lt;- u;</span><br><span class="line">  current &lt;- pop(stack); </span><br><span class="line">  lock(current);</span><br><span class="line">  A &lt;- get(current); </span><br><span class="line">  move.right; </span><br><span class="line">  unlock(oldnode);</span><br><span class="line">  goto Doinsertion</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>Move.right. This procedure, which is called by insert, follows link pointers at a given level, if necessary.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure move.right</span><br><span class="line">while t &lt;- scannode(u, A) is a link pointer of A do</span><br><span class="line">begin</span><br><span class="line">  lock(t); </span><br><span class="line">  unlock(current); </span><br><span class="line">  current &lt;- t;</span><br><span class="line">A &lt;- get(current); </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>需要注意的是，该过程在向上回溯树时是 逐层进行的。此外，同时最多只会锁定三个节点，而这种情况发生的频率相对较低：仅在插入分裂节点的指针时，需要沿 link 指针向右移动 的情况下才会出现。此时，被锁定的节点包括：</p>
<ul>
<li><p>分裂节点的原始左半部分</p>
</li>
<li><p>分裂节点上一层的两个节点</p>
</li>
</ul>
<p>在插入沿右链移动的过程中需要锁定它们。</p>
<p>与传统方法相比（即只有在确定节点为安全节点时才释放锁），这种做法在 锁粒度和并发性能上都有显著改进。</p>
<p>该算法的正确性依赖于以下事实：树结构的任何变化（即任何节点的分裂）都会伴随一个 link 指针。节点分裂时，条目总是被移动到树的右侧，在右侧的新节点可以通过 link 指针被访问到，从而保证树的结构在并发操作下仍然可达且正确。</p>
<p>具体来说，对于任何层级的一个对象（与某个值相关联），我们总能大致知道它的正确插入位置，即我们在该层搜索时经过的“记录节点”。如果该对象的正确插入位置发生了移动，这种移动方式是可预知的：也就是节点分裂向右，留下的 link 指针使得搜索或插入操作仍然能够找到它。因此，从旧的“预期”插入位置开始，始终可以访问到对象的正确插入位置。</p>
<h2 id="6-CORRECTNESS-PROOF"><a href="#6-CORRECTNESS-PROOF" class="headerlink" title="6 CORRECTNESS PROOF"></a>6 CORRECTNESS PROOF</h2><p>为了证明系统的正确性，我们需要证明以下两个命题对每个进程都成立：</p>
<ol>
<li>该进程不会发生死锁（定理 1）；</li>
<li>当进程终止时，它已经正确地完成了所需的操作。<br>  更具体地说：</li>
</ol>
<ul>
<li>所有磁盘操作都保持树结构的正确性（定理 2）</li>
<li>除正在进行修改的进程之外，所有其他进程看到的树都是一致的（交互定理 3）。</li>
</ul>
<h3 id="6-1-无死锁性（Freedom-from-Deadlock-）"><a href="#6-1-无死锁性（Freedom-from-Deadlock-）" class="headerlink" title="6.1 无死锁性（Freedom from Deadlock ）"></a>6.1 无死锁性（Freedom from Deadlock ）</h3><p>首先，我们开始证明系统不存在死锁。<br>为此，我们对节点施加一个顺序：跨层从下到上、同层从左到右。下面的引理（Lemma：一种 辅助性结论，用于证明后续更大、更重要的定理（Theorem））对这一点进行了严格定义。<br><strong>引理 1</strong> 插入操作对节点加锁遵循一个良序（well-ordering：严格定义的、有序的顺序关系）关系<br><strong>证明</strong> 考虑在树的节点集合上定义如下顺序关系（&lt;）：</p>
<ol>
<li>在任意时刻 t，如果两个节点 a 和 b 与树根的距离不同（不在同一层级），那么当且仅当 b 离树根更近（处于更高层级）时，我们称 a &lt; b。</li>
<li>如果 a 和 b 与树根的距离相同（在同一层级），那么当且仅当 b 能通过从 a 开始沿着一条或多条链接指针到达（即 b 在 a 的右侧）时，我们称 a &lt; b。</li>
</ol>
<p>通过检查插入算法我们可以看到：如果在时间 t₀ 时 a &lt; b，那么在所有 t &gt; t₀ 的时间点都仍然有 a &lt; b。因为节点创建过程只是把一个节点 x 分裂成两个新节点 x′ 和 x″，并且满足 x′ &lt; x″，而且</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y&lt;x⟺y&lt;x′</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&lt;y⟺x′′&lt;y</span><br></pre></td></tr></table></figure>
<p>因此，这些节点形成了一个良序关系，插入者按照良序对节点加锁。一旦在某个节点上加锁，它不会再对该节点之下的任何节点加锁，也不会对同一层中位于左侧的节点加锁。<br>因此，插入者按照给定的良序对节点加锁。证毕。<br>由于插入者是唯一对节点加锁的过程，我们可以立即得到以下定理。  </p>
<p><strong>定理 1</strong>：无死锁性。 给定的系统不会产生死锁。</p>
<h3 id="6-2-树结构修改的正确性"><a href="#6-2-树结构修改的正确性" class="headerlink" title="6.2 树结构修改的正确性"></a>6.2 树结构修改的正确性</h3><p>为了确保树结构的完整性，我们必须检查所有修改树结构的操作。首先，需要注意的是，树结构的修改只能通过 “put” 操作 来完成。插入过程中算法中有三个地方会执行 put 操作：</p>
<ol>
<li>对安全节点重写时使用 “put(A, current)”。</li>
<li>对不安全节点的最右节点使用 “put(B, u)”。通过该操作，我们写入由节点分裂形成的两个新节点中的第二个节点。</li>
<li>对不安全节点使用 “put(A, current)”。这里写入的是两个新节点中的第一个（最左节点）。实际上，我们重写了树中已存在的页面（节点），并修改该页面的链接指针，使其指向由 “put(B, …)” 写入的新节点。</li>
</ol>
<p>注意，在算法中（针对不安全节点），“put(B, u)” 紧接在 “put(A, current)” 之前执行。我们将在下面的引理中证明，这种顺序实际上将两个 put 操作简化为本质上的一次操作。 </p>
<p><strong>引理 2</strong>. 操作 ‘put(B, u); put(A, current)’ 相当于对树结构的一次修改。<br>证明. 假设这两个操作分别写入节点 b 和 a。在执行 “put(B, u)” 时，没有其他节点指向正在写入的节点 b，因此该 put 操作对树结构没有影响。现在，当执行 “put(A, current)” 时，该操作修改了 current 指向的节点（节点 a）。修改内容包括将节点 a 的链接指针指向 b。此时，b 已经存在，并且 b 的链接指针指向与 a 的旧版本相同的节点。这样就实现了同时修改 a 并将 b 引入树结构。证毕。</p>
<p><strong>定理 2</strong>. 所有 put 操作都能正确地修改树结构。<br><strong>证明</strong><br>case 1： 对安全节点执行 “put(A, current)”。该操作只修改树中一个已加锁的节点，因此树的正确性得到保持。<br>case 2： 对不安全节点执行 “put(B, u)”。该操作不会改变树结构。<br>case 3： 对不安全节点执行 “put(A, current)”。根据引理，该操作既修改了当前节点（比如 a），又将另一个节点（比如 b，通过 “put(B, u)” 写入）引入树结构。与情况 1 类似，节点 a 在执行 “put(A, current)” 时已加锁。本例的区别在于该节点是不安全的，需要分裂。但根据引理，我们可以通过一次操作完成，保持树结构的正确性。证毕</p>
<h3 id="6-3-正确的交互"><a href="#6-3-正确的交互" class="headerlink" title="6.3 正确的交互"></a>6.3 正确的交互</h3><p>我们还需要证明，无论插入过程对树进行何种修改，其他进程仍能正确操作。<br><strong>定理 3</strong>：交互定理。 插入过程的操作不会破坏其他进程操作的正确性。</p>
<p>为了证明该定理，我们首先考虑搜索过程与插入操作的交互情况，然后考虑两个插入过程的交互情况。一般来说，为了证明插入者的操作不会破坏其他进程的正确性，我们需要考虑该进程相对于该操作的行为。在所有情况下，该操作都是原子的。</p>
<p>假设插入者在时间 t0 对节点 a 执行一次 “put” 操作。考虑另一个进程在时间 t′从磁盘读取节点 a 的情况。由于假设 “get” 和 “put” 操作是不可分割的，要么 t′&lt;t0​，要么  t0​ &lt; t′。我们将在下面的引理中证明，后一种情况不会产生问题。</p>
<p><strong>引理 3</strong><br>如果进程 𝑃 在某个时间 𝑡′ &gt; 𝑡0 读取节点 𝑎，其中 𝑡0 是插入进程 I 修改节点 𝑎 的时间，那么这一修改不会影响进程 𝑃 的正确性。</p>
<p><strong>证明</strong>. 考虑进程 P 通过节点 a 的路径。进程 P 在到达节点 a 之前所经过的路径不会被插入进程 I 改变。此外，根据上面的定理 2，进程 I 对树结构所做的任何修改都会产生一个正确的树（well-ording）。因此，进程 P 在 a 节点开始的路径（在时间 t&gt;t′t &gt; t’t&gt;t′）将无论修改如何都能正确执行。证毕。</p>
<p>为了便于将定理的证明分解成不同情况，这里列出在一个节点上对一个值可能执行的三种插入类型。</p>
<p>类型 1. 简单地将一个值及其关联指针添加到节点中。当节点是安全的（safe）时发生这种类型的插入。<br>类型 2. 对节点进行分裂，并将插入值放入分裂节点的左半部分。左半部分仍然是原来被分裂的节点。<br>类型 3. 类似地，对节点进行分裂，并将插入值放入分裂节点的右半部分。右半部分是新分配的节点。</p>
<p>现在我们开始定理的证明。我们注意到，定理的正确性涉及几个方面（情况），并将分别证明这些情况。</p>
<p>证明. 根据引理 3，只需考虑搜索或插入进程 𝑃 在插入进程 𝐼 修改节点之前开始读取该节点的情况。</p>
<p>第 1 部分. 考虑插入进程 I（在时间 t0 修改节点 n）与搜索进程 S（在时间 t′&lt; t0读取节点 n）之间的交互。记 n′ 为修改后的节点。（本节的论证同样适用于另一插入进程 I′与进程 I 交互的情况，且 I′正在执行搜索。）需要考虑的操作顺序是：S 读取节点 n；然后 I 将节点 n 修改为 n′；然后 S 根据 n 的内容继续搜索。<br>考虑三种插入类型：  </p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Type 1</td>
<td align="left">进程 I 对节点 n 执行一次简单插入。如果 n 是叶子节点，插入进程不会改变任何指针。其结果等同于序列调度中 S 在 I 之前运行的情况。如果 n 是非叶子节点，则在 n 中插入一个指向下一层某节点 m′的指针&#x2F;值对。假设 m′是通过将 I 分裂为 I′ 和 m′ 创建的。唯一可能的交互是 S 在插入指向 m′ 的指针之前已经获得了指向 I 的指针。此时指向 I 的指针指向了 I′，而 S 将使用 I′中的 link pointer 访问 m′。因此搜索仍然是正确的。</td>
</tr>
<tr>
<td align="left">Types 2 and 3</td>
<td align="left">节点 n 在插入过程中被分裂为节点 n1′ 和 n2′。对于叶子节点的情况，搜索在 n 上的结果与在 n1′和 n2′上的结果相同，除了新插入的值 S 无法找到。 如果 n 不是叶子节点，则其下层的某个节点发生了分裂，导致一个新的指针&#x2F;值对被插入节点 n，从而使 n 本身也分裂。根据归纳法，下层节点的分裂是正确的。根据引理 3，下层节点的搜索也是正确的。因此，我们只需证明节点 n 的分裂是正确的。假设节点 n 分裂为节点 n1′ 和 n2′，它们包含与原节点 n 相同的指针集合，并增加了新插入的节点。则从节点 n 开始搜索，将到达下一层与从 n1′（带有指向 n2′的 link pointer）开始搜索时相同的节点集合。特殊情况是：如果搜索在读取节点 n 时，新插入的指针已经存在，本应沿该指针继续。此时实际跟随的指针位于新指针的左侧，这会将搜索引导到某个节点（假设为 k），它位于新指针指向的节点（假设为 m）左侧。然后沿 k 的 link pointer 最终到达 m，这仍然是正确的结果。（类型 3 的论证与类型 2 相同，只是新条目插入到新创建的半节点中，而不是旧半节点。但这对论证没有影响，因为节点在分裂发生前已被S读取。）</td>
</tr>
</tbody></table>
<p>第2部分。接下来我们考虑插入进程 I 与另一个插入进程 I’ 的交互情况。进程 I’ 可能正在搜索用于插入的正确节点、回溯到另一层，或者实际尝试将一个值&#x2F;指针对插入节点 n。如果 I’ 正在搜索一个用于插入值&#x2F;指针对的节点，则该搜索行为与普通搜索进程完全相同。因此，证明与上文针对搜索进程的证明相同。</p>
<p>第3部分。如果 I’ 因为下层节点分裂而需要回溯上行树，则 I’ 需要回到上层以便将指针插入到分裂节点的新半部分。</p>
<ul>
<li>回溯是使用在下降过程中记录在栈中的信息完成的。</li>
<li>在每一层，被压入栈的节点是该层被检查过的最右侧节点。</li>
<li>考虑在将某个节点 n 压入栈和回溯时再次访问该节点之间可能发生的情况：该节点可能已经分裂过一次或多次，这些分裂会在节点 n 的“右侧”产生新的节点。</li>
<li>由于节点 n 右侧的所有节点都可以通过 link 指针访问，因此插入算法能够找到适当的位置插入值。</li>
</ul>
<p>第四部分。如果进程 I’ 试图在节点 n 上进行插入，它会尝试锁定该节点。但进程 I 已经持有节点 n 的锁。最终，I 会释放该锁，I’ 再锁定该节点并将其读入内存。根据上面的引理，该交互是正确的，因为 I’ 的读取发生在 I 的插入之前。节点 n 要么就是插入的正确位置——此时 I’ 会执行插入；要么搜索必须沿节点的 link 指针访问其右兄弟。</p>
<h3 id="LiveLock"><a href="#LiveLock" class="headerlink" title="LiveLock"></a>LiveLock</h3><p>我们在此指出，我们的算法并不能完全避免活锁(LiveLock)的可能性（即某个进程无限运行）。<br>如果一个进程因为不断跟随其他进程创建的 link 指针而无法终止，就可能发生这种情况。<br>然而，根据以下观察，我们认为在实际实现中这种情况极不可能成为问题。<br>在多处理器系统中，如果该进程运行在相对非常慢的处理器上，这种情况可能发生。</p>
<p>(1) 在我们所知的大多数系统中，处理器的运行速度大致相当。<br>(2) 在 B 树中，节点的创建和删除只占很小的比例，因此即使是较慢的处理器，也不太可能因节点的创建或删除而遇到困难（也就是说，它只需要跟随少量的 link 指针）。<br>(3) 在树的任意给定层上，只能创建固定数量的节点，从而限制了较慢处理器需要“追赶”的量。  </p>
<p>我们认为，这些想法结合起来可以使实际系统中进程发生活锁的概率几乎为零（除非涉及的进程速度差异极大）。模拟可以帮助我们验证系统在“合理”条件下能够正常工作，并帮助确定进程相对速度的可接受范围。</p>
<p>在进程速度确实存在极大差异的情况下，我们可能会引入一些额外机制来防止活锁。实现这种机制有多种选择。本文不讨论避免活锁的完整方法，但其中一种方法可能是为每个进程分配优先级，优先级可能基于进程的“存在时间”。这将保证每个进程最终会终止，因为它最终会成为最“老”的进程，从而成为拥有最高优先级的进程。</p>
<h2 id="7-DELETION"><a href="#7-DELETION" class="headerlink" title="7. DELETION"></a>7. DELETION</h2><p>一种处理删除操作的简单方法是允许叶子节点中的条目少于 K 个。对于非叶子节点则不需要这样做，因为删除操作仅会移除叶子节点中的键；非叶子节点中的键仅作为其对应指针的上界，它在删除过程中并不会被移除。</p>
<p>因此，为了从叶子节点中删除一个条目，我们对该节点执行的操作与插入操作（尤其是插入情况 1）非常类似。具体来说，我们首先搜索出值 u 所在的节点，然后锁定该节点，将其读入内存，对内存中的副本删除值 u 后再将节点重写回磁盘。有时，这样会导致节点中条目数量少于 K。<br>该算法的正确性证明与插入操作类似。例如，死锁自由性的证明非常简单，因为删除操作只需要锁定一个节点。对于操作的正确性，如果一个搜索进程在删除值 u 之前读取了节点，它仍然会报告节点中存在 u，这与序列化调度（搜索操作先于删除操作执行）是一致的，因此搜索结果仍然正确。</p>
<p>我们刚描述的这种删除处理方法比需要处理节点下溢（underflow）和合并（concatenation）的方案要简单得多。在假设插入操作发生频率高于删除操作的情况下，这种方法几乎不需要额外存储空间。</p>
<p>当然，在删除操作过多导致树节点存储利用率过低的情况下，可以执行批量重组（batch reorganization）或者全树锁定的下溢操作（underflow operation）来重新组织树结构，以保证空间的合理利用。</p>
<h2 id="8-锁定效率（LOCKING-EFFICIENCY）"><a href="#8-锁定效率（LOCKING-EFFICIENCY）" class="headerlink" title="8. 锁定效率（LOCKING EFFICIENCY）"></a>8. 锁定效率（LOCKING EFFICIENCY）</h2><p>显然，在并发方案中，至少需要一个锁，以防止不同进程同时更新同一个节点。</p>
<p>上文给出的插入操作方案，在任何时刻对任意进程使用的锁数量最多是一个常数（最多三个）。这种情况仅在特定情况下发生：当插入进程刚刚向某个节点（叶子节点或非叶子节点）插入条目，并导致该节点分裂时。在回溯树的过程中，为了向新分裂节点的一半插入指针，插入进程发现旧的父节点已经不再是正确的插入位置，因此必须沿包含父节点的这一层节点进行链式查找，以找到正确的插入位置。在整个操作过程中，同时锁定三个节点。</p>
<p>在每个节点容量较大的 B*-树中，这种类型的锁定操作发生的频率非常低。因此，除非有大量并发进程运行，否则该结构的锁冲突概率极低。</p>
<p>这种系统的行为可以通过模拟进行量化，模拟参数包括并发进程数量、每个节点的容量，以及搜索、插入和删除操作的相对频率。这样的模拟不仅可以评估当前方案的性能，也可用于与其他并发控制方案进行比较。</p>
<h2 id="9-SUMMARY-AND-CONCLUSIONS"><a href="#9-SUMMARY-AND-CONCLUSIONS" class="headerlink" title="9. SUMMARY AND CONCLUSIONS"></a>9. SUMMARY AND CONCLUSIONS</h2><p>B 树在维护大型数据库时被发现非常有用。并发操作这样的数据具有明显优势，因为它允许多个用户同时共享数据；而且在大规模数据库中，用户的数据需求通常不会产生冲突，因此并发访问是可行的。</p>
<p>本文给出了一个算法，可以在 B 树的一种变体上执行正确的并发操作。该算法的特点是任意进程在任何时刻只需使用少量常数个锁。算法本身非常直接，其流程与顺序执行的算法仅有轻微差别。（可以通过模拟来量化本文算法与顺序算法或其他并发算法相比的效率提升。）</p>
<p>这一性能的实现依赖于对数据结构的一个小改动，使得当一个进程的位置因其他进程的操作而失效时，能够进行恢复（参见 [8]）。</p>
<p>我们希望将这项工作扩展到更通用的并发数据库操作方案。理想的方案应当仅需对数据结构和顺序算法做极少量修改，同时能够保证当其他进程对数据结构做出改变使某进程的操作失效时，该进程能够正确恢复。</p>
<p>另一条未来研究方向是对算法的“并行化”：研究将一个（已充分理解的）顺序算法转换为并发算法的通用方法。目标是尽可能充分利用问题的并发特性，同时保证算法的正确性不受影响。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft协议</title>
    <url>/2025/01/15/database/Raft%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Raft 是一个分布式一致性算法，被设计为比 Paxos 更易于理解，同时具备相似的性能和安全性。它常用于构建容错的分布式系统，确保多个节点在面对网络分区、节点失效等情况下能够达成一致</p>
<h2 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h2><ol>
<li>Leader选举：通过选举机制确保每个时间段只有一个节点（Leader）负责日志复制和状态变更。</li>
<li>日志复制：Leader 将客户端的操作（日志）复制到其他节点（Follower），确保日志的一致性。</li>
<li>状态机一致性：通过确保所有节点按相同顺序应用日志，实现一致性。</li>
</ol>
<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="1-角色"><a href="#1-角色" class="headerlink" title="1. 角色"></a>1. 角色</h3><ul>
<li>Leader：负责接收客户端请求，将操作以日志形式写入并同步给 Follower。</li>
<li>Follower：响应 Leader 的同步请求，被动地接受 Leader 的日志和指令。</li>
<li>Candidate：在 Leader 失效后，由 Follower 转为 Candidate，通过投票选举自己为新 Leader。</li>
</ul>
<h3 id="2-选举过程"><a href="#2-选举过程" class="headerlink" title="2. 选举过程"></a>2. 选举过程</h3><ul>
<li>若 Follower 超时未收到 Leader 的心跳信号，会转为 Candidate 并发起选举。</li>
<li>每个节点在选举期间投票给自己，同时请求其他节点投票。</li>
<li>如果一个 Candidate 获得了超过半数的投票，则成为 Leader。</li>
</ul>
<h3 id="3-日志复制"><a href="#3-日志复制" class="headerlink" title="3. 日志复制"></a>3. 日志复制</h3><ul>
<li>Leader 接收到客户端请求后，将其作为日志条目添加到自己的日志中。</li>
<li>Leader 使用 AppendEntries RPC 将日志复制到 Follower。</li>
<li>当多数节点确认日志条目后，Leader 将日志提交，并通知所有节点应用日志到状态机。</li>
</ul>
<h3 id="4-一致性保证"><a href="#4-一致性保证" class="headerlink" title="4. 一致性保证"></a>4. 一致性保证</h3><ul>
<li>使用 任期号（Term） 防止陈旧的 Leader 发出无效指令。</li>
<li>确保日志条目在所有节点上按照相同顺序出现，避免状态不一致。</li>
</ul>
<h2 id="扩展：MultiRaft协议"><a href="#扩展：MultiRaft协议" class="headerlink" title="扩展：MultiRaft协议"></a>扩展：MultiRaft协议</h2><p>MultiRaft 是 Raft 的一种扩展，旨在支持多个 Raft 实例同时运行，以便在大规模分布式系统中更高效地管理数据分片和分布式事务。</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ol>
<li>单个 Raft 实例在处理大量数据时可能成为瓶颈。</li>
<li>在分布式系统中，通常需要对数据进行分区，每个分区由独立的一组节点管理。</li>
<li>MultiRaft 提供了一种机制，通过运行多个 Raft 实例，每个实例负责一部分数据，从而提高系统的吞吐量和扩展性</li>
</ol>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li>多实例并行运行：</li>
</ol>
<ul>
<li>每个 Raft 实例管理一个独立的数据分片（shard）。</li>
<li>每个实例有自己的 Leader、Follower 和日志，独立运行 Raft 协议。</li>
</ul>
<ol start="2">
<li>共享底层资源：</li>
</ol>
<ul>
<li>多个 Raft 实例可以运行在相同的物理节点上，共享网络、存储和 CPU 等资源。</li>
<li>使用高效的调度机制协调实例间的资源竞争。</li>
</ul>
<ol start="3">
<li>动态分片和迁移：</li>
</ol>
<ul>
<li>数据分片可以动态调整，每个分片由一个 Raft 实例管理。</li>
<li>分片可以在节点之间迁移，以应对节点故障或负载不均。</li>
</ul>
<ol start="4">
<li>跨分片操作：</li>
</ol>
<ul>
<li>支持分布式事务，需要在多个 Raft 实例之间协调。</li>
<li>一般通过两阶段提交（2PC）或共识组间通信来实现。</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>Raft</th>
<th>MultiRaft</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>提供单一一致性机制</td>
<td>提供分区一致性机制</td>
</tr>
<tr>
<td>运行实例</td>
<td>单个 Raft 集群</td>
<td>多个独立的 Raft 集群</td>
</tr>
<tr>
<td>适用场景</td>
<td>小规模系统</td>
<td>大规模分布式存储或事务场景</td>
</tr>
<tr>
<td>扩展性</td>
<td>有限,单点可能成为瓶颈</td>
<td>高扩展性，分片机制避免瓶颈</td>
</tr>
<tr>
<td>复杂度</td>
<td>较低</td>
<td>较高，需要处理跨分片事务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>innodb and heap table</title>
    <url>/2025/10/25/database/innodb-and-pg/</url>
    <content><![CDATA[<p>昨日和同事探讨了一下pg与mysql，发现对于mysql的innodb存储引擎了解甚少，正好周末，深入学习了解了一下，整理一下这两天学到的东西。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>InnoDB：MySQL 的主要存储引擎<br>heap table：postgres数据库P表在物理上的存储（Heap File）</p>
<h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><h3 id="innodb-底层存储"><a href="#innodb-底层存储" class="headerlink" title="innodb 底层存储"></a>innodb 底层存储</h3><p>innodb是一个基于聚簇索引（Clustered Index）的存储引擎。</p>
<h4 id="数据存储方式-1"><a href="#数据存储方式-1" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><ul>
<li>聚簇索引存储表数据  <ul>
<li>表的主键索引就是数据本身的物理存储顺序。</li>
<li>每个页（page）一般 16KB，页内数据按主键顺序排列。</li>
<li>非主键列数据和行信息都在叶子节点。</li>
</ul>
</li>
<li>二级索引<ul>
<li>非主键索引存储的是主键值而不是行指针。</li>
<li>查询非主键列时，需要先通过二级索引拿到主键，再去主键聚簇索引里查数据（回表，row lookup）。</li>
</ul>
</li>
</ul>
<h4 id="页与数据组织"><a href="#页与数据组织" class="headerlink" title="页与数据组织"></a>页与数据组织</h4><ul>
<li>数据按 B+ 树页组织。</li>
<li>插入&#x2F;更新可能导致页分裂。</li>
</ul>
<h3 id="postgres-heap-table"><a href="#postgres-heap-table" class="headerlink" title="postgres heap table"></a>postgres heap table</h3><h4 id="数据存储方式-2"><a href="#数据存储方式-2" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><ul>
<li>数据按插入顺序存放，没有聚簇索引。</li>
<li>行标识符 TID（tuple id） 用于指向表的页和行。</li>
<li>页（默认 8KB）内存储多行 tuple。</li>
<li>没有聚簇索引，非索引扫描可能会更慢，但插入非常快。</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>B+ 树、哈希、GIN、GiST 等索引都是附加结构，存储独立于表。</li>
<li>回表操作是通过 TID 定位行。</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>PostgreSQL 堆表</th>
</tr>
</thead>
<tbody><tr>
<td>数据组织</td>
<td>聚簇索引（主键决定物理顺序）</td>
<td>堆表，顺序插入</td>
</tr>
<tr>
<td>主键访问</td>
<td>快（顺序扫描&#x2F;范围查询）</td>
<td>需要 B+ 树索引或全表扫描</td>
</tr>
<tr>
<td>二级索引访问</td>
<td>回表（先索引后主键查行）</td>
<td>回表（索引 -&gt; TID -&gt; 行）</td>
</tr>
<tr>
<td>插入性能</td>
<td>如果主键顺序插入快，否则可能页分裂</td>
<td>快，顺序写入，几乎不分裂</td>
</tr>
<tr>
<td>更新&#x2F;删除</td>
<td>支持 in-place 更新，但大行更新可能迁移</td>
<td>创建新行，旧行留存，需要 vacuum</td>
</tr>
<tr>
<td>MVCC</td>
<td>Undo log + hidden columns</td>
<td>xmin&#x2F;xmax + heap tuple</td>
</tr>
<tr>
<td>表膨胀</td>
<td>自动管理页空间</td>
<td>容易膨胀，需要 vacuum</td>
</tr>
<tr>
<td>查询优化</td>
<td>聚簇索引优化范围查询</td>
<td>多依赖索引，或者全表扫描</td>
</tr>
</tbody></table>
<p>因为pg的存储结构导致访问数据，多了许多随机io：从索引到数据文件。导致pg的查询性能不如innnodb</p>
<h3 id="pg的一些优化"><a href="#pg的一些优化" class="headerlink" title="pg的一些优化"></a>pg的一些优化</h3><h4 id="CLUSTER-命令（物理重排）"><a href="#CLUSTER-命令（物理重排）" class="headerlink" title="CLUSTER 命令（物理重排）"></a>CLUSTER 命令（物理重排）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLUSTER t USING idx_id;</span><br></pre></td></tr></table></figure>
<p>把表物理顺序按照索引顺序重排 —— 效果类似 InnoDB 聚簇索引。<br>缺点：</p>
<ul>
<li>是离线操作；</li>
<li>之后新插入的行会破坏顺序（除非周期性 recluster）</li>
</ul>
<h4 id="索引仅扫描（Index-Only-Scan）"><a href="#索引仅扫描（Index-Only-Scan）" class="headerlink" title="索引仅扫描（Index Only Scan）"></a>索引仅扫描（Index Only Scan）</h4><p>如果查询的字段都在索引里且可见性检查通过（可见性 map 中标记为 all-visible），可以不访问堆表，直接从索引返回结果。</p>
<h4 id="BRIN-索引"><a href="#BRIN-索引" class="headerlink" title="BRIN 索引"></a>BRIN 索引</h4><p>BRIN 全称是 Block Range INdex，是一种 非常轻量级的索引，设计理念与 B-Tree 不同：<br>不是存储每一行的索引它只存储堆表的一段范围（block range）内的最小值和最大值等摘要信息。每个 BRIN 索引条目覆盖 多个物理数据页（例如 128 个 8KB 页面 &#x3D; 1MB 的行数据）。<br>通过这些范围信息，可以快速排除不可能匹配的块，再去 heap 查找具体 tuple。<br>简单理解：BRIN 是“粗粒度索引”，通过块范围（block range）而非单行建立索引<br>非常适合 大表 + 顺序或局部相关数据：大表 + 顺序或局部相关数据：</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>TPCC</title>
    <url>/2025/06/04/database/TPCC/</url>
    <content><![CDATA[<ol>
<li>ER digram:<br><img src="/images/TPCC/823c7b37-30c8-4241-a074-f1f603c396af.png" alt="TPCC"></li>
</ol>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>install_oceanbase</title>
    <url>/2025/11/11/database/install-oceanbase/</url>
    <content><![CDATA[<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>To build OceanBase from source code, you need to install the C++ toolchain in your development environment first. If the C++ toolchain is not installed yet, you can follow the instructions in this document for installation.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install git wget rpm rpm2cpio cpio make build-essential binutils m4</span><br></pre></td></tr></table></figure>

<h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>Clone the source code to your development machine:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oceanbase/oceanbase.git</span><br></pre></td></tr></table></figure>

<h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>Build OceanBase from the source code in debug mode or release mode:</p>
<h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash build.sh debug --init --make</span><br></pre></td></tr></table></figure>
<h3 id="Release-mode"><a href="#Release-mode" class="headerlink" title="Release mode"></a>Release mode</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash build.sh release --init --make</span><br></pre></td></tr></table></figure>

<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>Now that you built the observer binary, you can deploy an OceanBase instance with the obd.sh utility:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./tools/deploy/obd.sh prepare -p /tmp/obtest</span><br><span class="line">./tools/deploy/obd.sh deploy -c ./tools/deploy/single.yaml</span><br></pre></td></tr></table></figure>
<p>You can check the mysql_port in .&#x2F;tools&#x2F;deploy&#x2F;single.yaml file to see the listening port. Normally, if you deploy with the root user, the OceanBase server will listen on port 10000, and the examples below are also based on this port.</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>You can use the official MySQL client to connect to OceanBase:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P10000</span><br></pre></td></tr></table></figure>
<p>Alternatively, you can use the obclient to connect to OceanBase:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">.<span class="operator">/</span>deps<span class="operator">/</span><span class="number">3</span>rd<span class="operator">/</span>u01<span class="operator">/</span>obclient<span class="operator">/</span>bin<span class="operator">/</span>obclient <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P10000 <span class="operator">-</span>uroot <span class="operator">-</span>Doceanbase <span class="operator">-</span>A</span><br></pre></td></tr></table></figure>

<h2 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./tools/deploy/obd.sh destroy --<span class="built_in">rm</span> -n single</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title>File Descriptor Limits</title>
    <url>/2024/10/24/linux/File%20Descriptor%20Limits/</url>
    <content><![CDATA[<p><a href="https://0pointer.net/blog/file-descriptor-limits.html">https://0pointer.net/blog/file-descriptor-limits.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use asan in linux</title>
    <url>/2025/03/16/debug/How-to-use-asan-in-linux/</url>
    <content><![CDATA[<h2 id="1-安装编译工具"><a href="#1-安装编译工具" class="headerlink" title="1. 安装编译工具"></a>1. 安装编译工具</h2><p>ASan 是 GCC 和 Clang 内建的功能，无需额外安装 ASan，只需要你的编译器支持即可。GCC ≥ 4.8 &#x2F; Clang ≥ 3.1 就支持 ASan  </p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@lavm-bar1guved6:~# clang --version</span><br><span class="line">Ubuntu clang version 14.0.0-1ubuntu1.1</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line"></span><br><span class="line">root@lavm-bar1guved6:~# gcc --version</span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="2-how-to-use"><a href="#2-how-to-use" class="headerlink" title="2. how to use"></a>2. how to use</h2><h3 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -g your_file.c -o your_program</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="使用cmake"><a href="#使用cmake" class="headerlink" title="使用cmake"></a>使用cmake</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译阶段（C/C++）加 ASan 插桩</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> -fsanitize=address -fno-omit-frame-pointer -g&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -fsanitize=address -fno-omit-frame-pointer -g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接阶段链接 libasan</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -fsanitize=address&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;</span> -fsanitize=address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">cmake -DCMAKE_C_FLAGS=<span class="string">&quot;-fsanitize=address -fno-omit-frame-pointer -g&quot;</span> \</span><br><span class="line">    -DCMAKE_EXE_LINKER_FLAGS=<span class="string">&quot;-fsanitize=address&quot;</span> \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Debug \</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="使用-Makefile"><a href="#使用-Makefile" class="headerlink" title="使用 Makefile"></a>使用 Makefile</h3><p>可以在 CFLAGS 中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CFLAGS += -fsanitize=address -g -fno-omit-frame-pointer</span><br><span class="line">LDFLAGS += -fsanitize=address</span><br></pre></td></tr></table></figure>
<h3 id="使用-LSAN（泄漏检测）"><a href="#使用-LSAN（泄漏检测）" class="headerlink" title="使用 LSAN（泄漏检测）"></a>使用 LSAN（泄漏检测）</h3><p>GCC 和 Clang 中 ASan 自动包含 LeakSanitizer（LSan），但某些情况下要确保：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fsanitize=address -fno-omit-frame-pointer</span><br></pre></td></tr></table></figure>
<p>加上 -fno-omit-frame-pointer 可以让调用栈更完整。</p>
<h2 id="3-运行程序"><a href="#3-运行程序" class="headerlink" title="3. 运行程序"></a>3. 运行程序</h2><p>编译好的程序可以直接运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./your_program</span><br></pre></td></tr></table></figure>
<h2 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4. 设置环境变量"></a>4. 设置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=detect_leaks=1:halt_on_error=0:symbolize=1:quarantine_size=1024:log_path=/home/postgres/asan/asan.log</span><br></pre></td></tr></table></figure>
<h2 id="5-Example"><a href="#5-Example" class="headerlink" title="5. Example"></a>5. Example</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==791265==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 1024 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7f6fcee65887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145</span><br><span class="line">    #1 0x55adcdfee87a in main /home/postgres/codes/sample/epoll_server.c:54</span><br><span class="line">    #2 0x7f6fcebb1d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 1024 byte(s) leaked in 1 allocation(s).</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 查看指令</title>
    <url>/2024/12/24/debug/gdb-%E6%9F%A5%E7%9C%8B%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="使用-x-命令和内存地址："><a href="#使用-x-命令和内存地址：" class="headerlink" title="使用 x 命令和内存地址："></a>使用 x 命令和内存地址：</h2><p>x (examine) 命令允许你检查内存中的数据。你可以指定要检查的内存地址、格式和单位。</p>
<p>基本语法： x &#x2F;nfu addr</p>
<ul>
<li><p>n：要显示的单位数量。</p>
</li>
<li><p>f：显示格式（例如，x 表示十六进制，t 表示二进制，d 表示十进制）。</p>
</li>
<li><p>u：单位大小（b 表示字节，h 表示半字（16 位），w 表示字（32 位），g 表示巨字（64 位））。</p>
</li>
<li><p>addr：要检查的内存地址。</p>
</li>
</ul>
<p>示例： 假设有一个 32 位整数 val，其地址为 0x12345678，你想以 16 位为单位查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x /2ht 0x12345678</span><br></pre></td></tr></table></figure>

<p>这将显示从 0x12345678 开始的两个半字（16 位）的十六进制值。</p>
<p>结合 p 命令获取地址： 你可以使用 p &amp;变量名 获取变量的地址，然后将其传递给 x 命令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;val = 0x%x\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并用 GDB 调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o <span class="built_in">test</span></span><br><span class="line">gdb ./test</span><br></pre></td></tr></table></figure>
<p>在 GDB 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) p &amp;val</span><br><span class="line"><span class="variable">$1</span> = (int *) 0x7fffffffe0dc</span><br><span class="line">(gdb) x /2ht 0x7fffffffe0dc</span><br><span class="line">0x7fffffffe0dc: 0x5678  0x1234</span><br></pre></td></tr></table></figure>
<p>这里注意字节序，在小端序机器上，低位字节在前，高位字节在后，所以显示为 0x5678 0x1234。<br>如果想要二进制显示，则使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x /2ht 0x7fffffffe0dc</span><br><span class="line">0x7fffffffe0dc: 0101011001111000        0001001000110100</span><br></pre></td></tr></table></figure>

<h2 id="使用表达式和位运算（对于变量值）："><a href="#使用表达式和位运算（对于变量值）：" class="headerlink" title="使用表达式和位运算（对于变量值）："></a>使用表达式和位运算（对于变量值）：</h2><p>如果你只想查看变量的值，而不需要查看内存，可以使用 C 语言的位运算来提取 16 位部分，然后使用 p&#x2F;t 显示。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int val = 0x12345678;</span><br></pre></td></tr></table></figure>
<p>在 GDB 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p/t (val &amp; 0xFFFF) // 获取低 16 位</span><br><span class="line"><span class="variable">$1</span> = 0101011001111000</span><br><span class="line">(gdb) p/t ((val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0</span>xFFFF) // 获取高 <span class="number">16</span> 位</span><br><span class="line"><span class="variable">$2</span> = <span class="number">0001001000110100</span></span><br></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>对于查看内存中的数据（包括变量在内存中的表示），使用 x 命令结合 h (半字) 和 t (二进制) 格式指定符是最直接的方法。<br>对于只查看变量的值，使用位运算提取 16 位部分，然后使用 p&#x2F;t 也是一个有效的选择。<br>选择哪种方法取决于你的具体需求。如果你需要查看变量在内存中的布局（例如，在结构体或数组中），x 命令是更好的选择。如果你只需要查看变量值的不同部分，位运算可能更方便。</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试改变返回值</title>
    <url>/2025/01/23/debug/gdb%E8%B0%83%E8%AF%95%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 GDB 调试时，有时候需要修改返回值，但是返回值有时候无法直接使用p修改，如std::list::empty(); 如何修改标准库的empty函数返回值呢？</p>
<h2 id="修改寄存器值"><a href="#修改寄存器值" class="headerlink" title="修改寄存器值"></a>修改寄存器值</h2><p>函数的返回值通常存储在特定寄存器中（例如，x86-64 架构中是 %rax）。在函数返回之前，你可以修改 %rax 的值。</p>
<p>步骤：</p>
<ol>
<li>在函数返回之前设置断点（如 ret 指令处）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b *func+&lt;offset&gt; # 偏移地址为即将返回的位置</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.运行程序并等待断点触发<br>3.修改返回值所在的寄存器（例如 %rax）：</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2025/08/05/debug/io/</url>
    <content><![CDATA[<h2 id="确认-I-O-是否是瓶颈，需要从多个角度综合判断，-瓶颈可能体现在磁盘、文件系统甚至内核调度上。"><a href="#确认-I-O-是否是瓶颈，需要从多个角度综合判断，-瓶颈可能体现在磁盘、文件系统甚至内核调度上。" class="headerlink" title="确认 I&#x2F;O 是否是瓶颈，需要从多个角度综合判断， 瓶颈可能体现在磁盘、文件系统甚至内核调度上。"></a>确认 I&#x2F;O 是否是瓶颈，需要从多个角度综合判断， 瓶颈可能体现在磁盘、文件系统甚至内核调度上。</h2><h3 id="1-使用系统工具监控-I-O"><a href="#1-使用系统工具监控-I-O" class="headerlink" title="1. 使用系统工具监控 I&#x2F;O"></a>1. 使用系统工具监控 I&#x2F;O</h3><h4 id="Linux-常用："><a href="#Linux-常用：" class="headerlink" title="Linux 常用："></a>Linux 常用：</h4><ol>
<li><p><strong><code>iostat</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>%util</code> 高接近 100% → 磁盘基本饱和。</li>
<li><code>await</code> 高 → 每次 I&#x2F;O 延迟大。</li>
<li><code>r/s</code> 和 <code>w/s</code> → 每秒读写次数，衡量吞吐能力。</li>
</ul>
</li>
<li><p><strong><code>iotop</code></strong></p>
<ul>
<li>实时显示哪个进程在进行 I&#x2F;O 以及占用的 I&#x2F;O 带宽。</li>
<li>可以确认是单个进程占用过多 I&#x2F;O 还是多个进程平均分摊。</li>
</ul>
</li>
<li><p><strong><code>vmstat</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bi</code>&#x2F;<code>bo</code> 字段表示每秒块设备读写量。</li>
<li><code>wa</code> 字段表示 CPU 等待 I&#x2F;O 的百分比，高的话说明 I&#x2F;O 成为 CPU 等待瓶颈。</li>
</ul>
</li>
<li><p><strong><code>dstat</code> &#x2F; <code>perf stat</code></strong></p>
<ul>
<li>更细粒度监控吞吐量、延迟和上下文切换。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-检查磁盘吞吐能力"><a href="#2-检查磁盘吞吐能力" class="headerlink" title="2. 检查磁盘吞吐能力"></a>2. 检查磁盘吞吐能力</h3><ul>
<li><p>测试磁盘最大写入带宽：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/tmp/testfile bs=1M count=1024 oflag=direct</span><br></pre></td></tr></table></figure>

<ul>
<li><code>oflag=direct</code> 避免缓存干扰。</li>
<li>如果测试带宽接近你程序的写入量，磁盘可能就是瓶颈。</li>
</ul>
</li>
<li><p>同理，可以测试并发读写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fio --name=randrw --rw=randrw --bs=4k --size=1G --numjobs=10 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fio</code> 可以模拟多线程读写负载，测出 IOPS 和吞吐量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-观察系统行为"><a href="#3-观察系统行为" class="headerlink" title="3. 观察系统行为"></a>3. 观察系统行为</h3><ul>
<li><p><strong>CPU vs I&#x2F;O 时间</strong>：</p>
<ul>
<li><code>top</code> 或 <code>perf top</code> 中如果 CPU 很空闲，程序主要在等待 I&#x2F;O → I&#x2F;O 瓶颈。</li>
</ul>
</li>
<li><p><strong>延迟累积</strong>：</p>
<ul>
<li>如果程序写入文件很慢，但 CPU 使用低且磁盘高负载 → 瓶颈在 I&#x2F;O。</li>
</ul>
</li>
<li><p><strong>锁与等待</strong>：</p>
<ul>
<li>并发写入时，文件系统锁、页缓存锁也会引入“假 I&#x2F;O 瓶颈”，需要 <code>perf trace</code> 或 <code>blktrace</code> 排查。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 异步调试</title>
    <url>/2024/11/11/debug/nonstop/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> target-async 1 </span><br><span class="line"><span class="built_in">set</span> pagination off </span><br><span class="line"><span class="built_in">set</span> non-stop on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> object on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> static-members on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> demangle on</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> sevenbit-strings off</span><br><span class="line"></span><br><span class="line">python </span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(0,<span class="string">&#x27;/usr/share/gcc-4.8.2/python*) </span></span><br><span class="line"><span class="string">from libstdcxx.v6.printers import register_libstdcxx_printers</span></span><br><span class="line"><span class="string">register_libstdcxx_printers (None)</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>分析tcmalloc 内存增长 —- pprof</title>
    <url>/2024/10/27/debug/pprof/</url>
    <content><![CDATA[<p>有时候程序莫名内存上涨厉害，但不是泄漏，如何定位哪申请使用的大量内存呢？</p>
<p>如果没使用tcmalloc，使用heaptrack工具（git clone <a href="https://github.com/KDE/heaptrack.git%EF%BC%89%EF%BC%9B">https://github.com/KDE/heaptrack.git）；</a></p>
<p>如果使用了tcmalloc，可以通过tcmalloc自带的工具来分析</p>
<h2 id="一-工具"><a href="#一-工具" class="headerlink" title="一 工具"></a>一 工具</h2><ol>
<li>tcmalloc</li>
<li>pprof</li>
</ol>
<p>pprof相当于分析器，阅读器，分析阅读的内容为heap文件，内容包括  </p>
<ul>
<li>每个活跃分配的大小</li>
<li>分配的调用栈</li>
<li>分配次数</li>
</ul>
<h2 id="二-生成heap文件"><a href="#二-生成heap文件" class="headerlink" title="二 生成heap文件"></a>二 生成heap文件</h2><ul>
<li><p>手动<br>在程序的入口或需要开始分析的地方，添加 HeapProfilerStart(“文件路径”)。<br>在程序结束或需要停止分析的地方，添加 HeapProfilerStop()。<br>在需要手动生成快照的地方，添加 HeapProfilerDump(“文件名”)。</p>
</li>
<li><p>自动<br>设置环境变量，动态加载设置环境变量即可，tcmalloc库加载时会读取并解析这个环境变量，从而开启堆分析功能</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HEAP_PROFILE=/tmp/myapp_heap</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是静态加载，需代码中启动：HeapProfilerStart</p>
</blockquote>
</li>
<li><p>补充说明<br>自动生成文件的时机：申请内存超过阈值时会自动生成，阈值可以通过HEAP_PROFILE_ALLOCATION_INTERVAL环境变量来设置</p>
</li>
</ul>
<h2 id="三-分析heap文件（快照）"><a href="#三-分析heap文件（快照）" class="headerlink" title="三 分析heap文件（快照）"></a>三 分析heap文件（快照）</h2><h3 id="单次快照"><a href="#单次快照" class="headerlink" title="单次快照"></a>单次快照</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本格式</span></span><br><span class="line">pprof test_heap --text /tmp/test_heap.0001.heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 火焰图</span></span><br><span class="line">pprof --svg /path/to/my_program.hprof &gt; flamegraph.svg</span><br></pre></td></tr></table></figure>
<h3 id="两次快照："><a href="#两次快照：" class="headerlink" title="两次快照："></a>两次快照：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对比两次快照</span></span><br><span class="line">pprof --inuse_space --base=/tmp/my_app.0001.heap /tmp/my_app.0002.heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成火焰图</span></span><br><span class="line">pprof --svg --inuse_space --base=/tmp/my_app.0001.heap /tmp/my_app.0002.heap &gt; diff_flamegraph.svg</span><br></pre></td></tr></table></figure>
<p>火焰图需要额外安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install graphviz</span><br></pre></td></tr></table></figure>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gperftools/heap-profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HeapProfilerStart(<span class="string">&quot;/tmp/test_heap&quot;</span>);</span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">malloc</span>(<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 分配 16MB</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocated 16MB\n&quot;</span>;</span><br><span class="line">    HeapProfilerDump(<span class="string">&quot;after_alloc&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    HeapProfilerStop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test_heap.cc -ltcmalloc -lpthread -lunwind -o test_heap</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调试</title>
    <url>/2025/08/13/debug/%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>只显示指定进程 <PID> 的所有线程，并实时显示它们的 CPU、内存等使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pstack &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf top -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>查看函数热点，采样一段时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perf record -p &lt;PID&gt; -g -- sleep 10</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure>

<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -ttT -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><ul>
<li><p>安装perf</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common linux-tools-$(uname -r)</span><br></pre></td></tr></table></figure>
</li>
<li><p>采样数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30</span><br></pre></td></tr></table></figure>

<p>  -F 99          每秒采样 99 次<br>  -p <PID>       针对指定进程<br>  -g             采集调用栈（火焰图需要）<br>  – sleep 30    采样 30 秒</p>
</li>
<li><p>生成调用栈</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo perf script &gt; out.perf</span><br></pre></td></tr></table></figure></li>
<li><p>下载 FlameGraph 工具</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">cd FlameGraph</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成火焰图</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stackcollapse-perf.pl ../out.perf &gt; out.folded</span><br><span class="line">./flamegraph.pl out.folded &gt; flamegraph.svg</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="系统io"><a href="#系统io" class="headerlink" title="系统io"></a>系统io</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>
<p>重点关注 await（平均等待时间）和 svctm（服务时间）。如果 await &gt;&gt; svctm，说明队列很长，设备忙不过来。</p>
<h2 id="某个进程io"><a href="#某个进程io" class="headerlink" title="某个进程io"></a>某个进程io</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidstat -d -p &lt;PID&gt; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>python_tricks</title>
    <url>/2022/06/20/python/python-tricks/</url>
    <content><![CDATA[<h2 id="python参数灵活性"><a href="#python参数灵活性" class="headerlink" title="python参数灵活性"></a>python参数灵活性</h2><p>位置参数 + 默认参数 + *args + **kwargs</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>*args</code></td>
<td>收集所有 <strong>位置参数</strong>，组成元组</td>
</tr>
<tr>
<td><code>**kwargs</code></td>
<td>收集所有 <strong>关键字参数</strong>，组成字典</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">2</span>, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, kwargs)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 输出：1 2 &#123;&#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="返回值灵活性"><a href="#返回值灵活性" class="headerlink" title="返回值灵活性"></a>返回值灵活性</h2><p>Python 函数没有固定返回类型。可以返回任意对象：数字、字符串、列表、字典、对象，甚至函数本身。调用方只要按照约定处理即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;negative&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="虚拟环境的使用"><a href="#虚拟环境的使用" class="headerlink" title="虚拟环境的使用"></a>虚拟环境的使用</h2><ul>
<li>创建虚拟环境  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3<span class="number">.14</span> -m venv .venv</span><br></pre></td></tr></table></figure></li>
<li>终端激活虚拟环境  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source .venv/<span class="built_in">bin</span>/activate</span><br><span class="line">python --version</span><br><span class="line">which python</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="导出第三方依赖"><a href="#导出第三方依赖" class="headerlink" title="导出第三方依赖"></a>导出第三方依赖</h2><ul>
<li>激活虚拟环境</li>
<li>使用 pip freeze 导出  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip freeze --local &gt; requirements.txt</span><br></pre></td></tr></table></figure></li>
<li>复现环境  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line"></span><br><span class="line">pyinstaller \</span><br><span class="line">  --windowed \</span><br><span class="line">  --name MyApp \</span><br><span class="line">  main.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>macos  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install create-dmg</span><br><span class="line"></span><br><span class="line">create-dmg \</span><br><span class="line">MyApp.app \</span><br><span class="line">dist/</span><br></pre></td></tr></table></figure>
  生成  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dist/MyApp.dmg</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>Background Writing</title>
    <url>/2025/08/20/postgresql/Background-Writing/</url>
    <content><![CDATA[<p>如果后台进程（backend）需要从缓冲区中驱逐一个脏页（dirty page），它必须将这个页面写入磁盘。这种情况是不希望发生的，因为它会导致等待（例如 I&#x2F;O 阻塞）——更好的方式是在后台异步地执行写入操作。</p>
<p>这一工作部分由 checkpointer 进程完成，但这仍然不够。因此，PostgreSQL 还引入了另一个名为 bgwriter（后台写入进程）的进程，专门用于后台写盘操作。</p>
<p>bgwriter 和驱逐（eviction）使用相同的缓冲区遍历算法，但有两个关键区别：</p>
<p>bgwriter 使用自己独立的时钟指针（clock hand），该指针从不会落后于驱逐的指针，通常还会超过它；<br>在遍历缓冲区时，bgwriter 不会降低页面的 usage count（使用计数）。<br>当一个缓冲页未被固定（unpinned）且其 usage count 为 0 时，如果它是脏的，bgwriter 就会将其刷新到磁盘。换句话说，bgwriter 在驱逐操作发生之前运行，主动地将那些很可能即将被驱逐的页面提前写入磁盘。</p>
<p>这样做的好处是：被选中驱逐的缓冲页很可能已经是干净的（clean），从而提高了驱逐操作的效率，避免了后台进程被迫同步写盘的代价。</p>
<p>总结</p>
<blockquote>
<p>checkpointer 是“周期性清理工”，而 bgwriter 是“持续扫地工”。</p>
</blockquote>
<p>checkpointer 负责最终的数据落盘一致性，而 bgwriter 提前清理“潜在垃圾”，让后台线程少“踩雷”。二者配合，保障了 PostgreSQL 的高并发性能和写入平滑性。</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Statistics</title>
    <url>/2025/12/18/postgresql/Basic-Statistics/</url>
    <content><![CDATA[<p>基本的 relation-level统计信息存储在系统目录的 pg_class 表中，包含以下数据：</p>
<ul>
<li>relation中的元组（记录）数量（reltuples）</li>
<li>relation的大小，以页（page）为单位（relpages）</li>
<li>在可见性映射（visibility map）中被标记的页数（relallvisible）</li>
</ul>
<p>下面是 flights 表对应的这些值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>     <span class="number">2624</span> <span class="operator">|</span>          <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>如果查询未施加任何过滤条件，则 reltuples 的值将作为基数（cardinality）估计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4772</span><span class="number">.67</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">214867</span> width<span class="operator">=</span><span class="number">63</span>)</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>统计信息是在表分析（无论是手动还是自动）过程中收集的。此外，由于基本统计信息至关重要，这些数据也会在其他操作中计算（如 VACUUM FULL 和 CLUSTER，以及 CREATE INDEX 和 REINDEX），并在常规 VACUUM 过程中进一步精化。</p>
<p>为了分析目的，会从表中随机抽取 300 × <em>default_statistics_target</em> 行进行采样。为了构建具有特定精度的统计信息，所需的样本量与被分析数据的总体量关系不大，因此表的大小不会被考虑在内。</p>
<p>抽样行是从同样数量的随机页（300 × <em>default_statistics_target</em> 页）中选出的。显然，如果表本身较小，则可能读取的页数更少，选取用于分析的行数也会相应减少。</p>
<p>对于大表，统计信息收集不会包含所有行，因此估算值可能与实际值存在偏差。这是完全正常的：如果数据在不断变化，统计信息本身也不可能始终准确。通常，只要估算精度在数量级上足够，即可用来选择合理的查询执行计划。</p>
<p>我们创建一个 flights 表的副本，并禁用 autovacuum，这样我们就可以控制自动分析（autoanalysis）的启动时间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> flights_copy(<span class="keyword">LIKE</span> flights) <span class="keyword">WITH</span> (autovacuum_enabled <span class="operator">=</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>目前新表没有统计信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible</span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">        −<span class="number">1</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>             <span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>当 reltuples &#x3D; −1 时，用于区分尚未分析的表和真正没有行的空表。</p>
<p>表创建后，很可能会马上插入一些行。由于优化器无法获知表的当前实际状态，它会假设该表包含 10 个页：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights_copy (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.14</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">410</span> width<span class="operator">=</span><span class="number">170</span>) </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>行数的估算是基于单行的大小（在执行计划中显示为 width）。行宽通常是在分析过程中计算的平均值，但由于此时尚未收集任何统计信息，这里只是根据列的数据类型做出的近似估算。</p>
<p>现在，我们从 flights 表拷贝数据同时完成分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; INSERT INTO flights_copy SELECT * FROM flights; INSERT 0 214867</span><br><span class="line">=&gt; ANALYZE flights_copy;</span><br></pre></td></tr></table></figure>

<p>收集到的统计信息反映了实际的行数（表足够小，分析器可以对所有数据收集统计信息）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>     <span class="number">2624</span> <span class="operator">|</span>             <span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>relallvisible 值用于估算 index-only scan 的成本。该值由 VACUUM 更新：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> VACUUM flights_copy;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line">relallvisible </span><br><span class="line">−−−−−−−−−−−−−−−</span><br><span class="line">          <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们将行数翻倍，但不更新统计信息，检查查询计划中的基数估算：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> flights_copy <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights; </span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights_copy;</span><br><span class="line"> count </span><br><span class="line">−−−−−−−−</span><br><span class="line"><span class="number">429734</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights_copy (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.9545</span><span class="number">.34</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">429734</span> width<span class="operator">=</span><span class="number">63</span>) </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>尽管 pg_class 中的数据已经过时，估算结果仍然准确：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>    <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>问题在于，如果优化器发现 relpages 与实际文件大小之间存在差距，它可以通过比例调整 reltuples 的值来提高估算精度。由于文件大小相比 relpages 翻了一倍，优化器会调整估算的行数，同时假设数据密度保持不变：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples <span class="operator">*</span></span><br><span class="line">(pg_relation_size(<span class="string">&#x27;flights_copy&#x27;</span>) <span class="operator">/</span> <span class="number">8192</span>) <span class="operator">/</span> relpages <span class="keyword">AS</span> tuples</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> tuples</span><br><span class="line">−−−−−−−−</span><br><span class="line"> <span class="number">429734</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>当然，这种调整并不总是有效（例如，如果删除了一些行，估算值将保持不变），但在某些情况下，它可以让优化器在下一次分析触发之前仍然保持合理的估算。</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
        <tag>statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer Bulk Eviction</title>
    <url>/2024/12/31/postgresql/Buffer-Bulk-Eviction/</url>
    <content><![CDATA[<p>If bulk reads or writes are performed, there is a risk that one-time data can quickly oust useful pages from the buffer cache.</p>
<p>As a precaution, bulk operations use rather small buffer rings, and eviction is performed within their boundaries, without affecting other buffers.</p>
<p>A buffer ring of a particular size consists of an array of buffers that are used one after another. At first, the buffer ring is empty, and individual buffers join it one by one, after being selected from the buffer cache in the usual manner. Then eviction comes into play,but only within the ring limits</p>
<p>Buffers added into a ring are not excluded from the buffer cache and can still be used by other operations. So if the buffer to be reused turns out to be pinned, or its usage count is higher than one, it will be simply detached from the ring and replaced by another buffer.<br>PostgreSQL supports three eviction strategies.</p>
<table>
<thead>
<tr>
<th><strong>strategy</strong></th>
<th>trigger</th>
<th>buffer ring</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bulk reads</strong></td>
<td>sequential scans of large tables if their size exceeds 1&#x2F;4 of the buffer cache(128MB：16384 page）</td>
<td>256KB(32 page)</td>
</tr>
<tr>
<td><strong>Bulk writes</strong></td>
<td>applied by Copy from, create table as select , and create materialized view commands, as well as by those alter table  flavors that cause table rewrites.</td>
<td>default: 16MB(2048 page)</td>
</tr>
<tr>
<td><strong>Vacuuming</strong></td>
<td>full table scan without taking the visibility map into account</td>
<td>256KB(32 page)</td>
</tr>
</tbody></table>
<p>Buffer rings do not always prevent undesired eviction. If UPDATE or DELETE commands affect a lot of rows, the performed table scan applies the bulk reads strategy, but since the pages are constantly being modified, buffer rings virtually become useless.</p>
<p>Another example worth mentioning is storing oversized data in TOAST tables. In spite of a potentially large volume of data that has to be read, toasted values are always accessed via an index, so they bypass buffer rings.</p>
<p>Let’s take a closer look at the bulk reads strategy. For simplicity, we will create a table in such a way that an inserted row takes the whole page. By default, the buffer cache size is 16,384 pages, 8 kb each. So the table must take more than 4096 pages for the scan to use a buffer ring.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">SHOW</span> shared_buffers;</span><br><span class="line"> shared_buffers </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">128</span>MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> big(</span><br><span class="line">test(# id <span class="type">integer</span> <span class="keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>, s <span class="type">char</span>(<span class="number">1000</span>)</span><br><span class="line">test(# ) <span class="keyword">WITH</span> (fillfactor <span class="operator">=</span> <span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">INSERT INTO</span> big(s)</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">SELECT</span> <span class="string">&#x27;FOO&#x27;</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">4096</span><span class="operator">+</span><span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">4097</span></span><br><span class="line">test<span class="operator">=</span># ANALYZE big;</span><br><span class="line">ANALYZE</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> relname, relfilenode, relpages <span class="keyword">FROM</span> pg_class</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHERE</span> relname <span class="keyword">IN</span> (<span class="string">&#x27;big&#x27;</span>, <span class="string">&#x27;big_pkey&#x27;</span>);</span><br><span class="line"> relname  <span class="operator">|</span> relfilenode <span class="operator">|</span> relpages </span><br><span class="line"><span class="comment">----------+-------------+----------</span></span><br><span class="line"> big      <span class="operator">|</span>       <span class="number">16487</span> <span class="operator">|</span>     <span class="number">4097</span></span><br><span class="line"> big_pkey <span class="operator">|</span>       <span class="number">16492</span> <span class="operator">|</span>       <span class="number">14</span></span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big;</span><br><span class="line">                 QUERY PLAN                 </span><br><span class="line"><span class="comment">--------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> big (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">4097</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache</span><br><span class="line"><span class="keyword">WHERE</span> relfilenode <span class="operator">=</span> pg_relation_filenode(<span class="string">&#x27;big&#x27;</span>::regclass);</span><br><span class="line"> count </span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">    <span class="number">32</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Checkpoint</title>
    <url>/2025/04/03/postgresql/Checkpoint/</url>
    <content><![CDATA[<p>要在发生故障后恢复数据一致性（即执行恢复操作），PostgreSQL 需要向前回放 WAL 日志，并将其中表示丢失变更的记录应用到相应的数据页上。为了确定哪些变更丢失了，系统会将磁盘上数据页的 LSN（日志序列号）与 WAL 记录的 LSN 进行比较。但问题是，我们应该从哪里开始恢复？如果恢复起点选得太晚，那么在此之前已经写入磁盘的数据页将无法接收到所有应有的变更，最终导致无法修复的数据损坏。而从日志的起始位置开始恢复又不现实：不仅无法长期保存如此巨量的数据，也无法接受过长的恢复时间。因此，我们需要一个不断向前推进的检查点（checkpoint），从而可以从这个位置安全地开始恢复，同时删除所有更早的 WAL 记录。</p>
<p>创建检查点最直接的方式是：定期暂停系统所有操作，并将所有脏页强制刷新到磁盘。但这种方式显然是不可接受的，因为系统会因此暂停不定但相当长的时间。</p>
<p>正因为如此，PostgreSQL 将检查点的过程分摊到一段时间内完成，实际上构成了一个“区间”（interval）。检查点的执行是由一个特殊的后台进程负责的，这个进程叫做 checkpointer（检查点进程）</p>
<h2 id="检查点开始（Checkpoint-start）："><a href="#检查点开始（Checkpoint-start）：" class="headerlink" title="检查点开始（Checkpoint start）："></a>检查点开始（Checkpoint start）：</h2><p>checkpointer 进程会将所有可以立即写入磁盘的内容进行刷新，包括：</p>
<ul>
<li>CLOG（提交日志）中的事务状态信息，</li>
<li>子事务的元数据，</li>
<li>以及其他一些结构。</li>
</ul>
<h2 id="检查点执行过程（Checkpoint-execution）："><a href="#检查点执行过程（Checkpoint-execution）：" class="headerlink" title="检查点执行过程（Checkpoint execution）："></a>检查点执行过程（Checkpoint execution）：</h2><p>检查点执行的大部分时间都耗费在将 脏页（dirty pages）刷新到磁盘上。</p>
<p>首先，在检查点开始时，所有当时处于“脏”状态的缓冲区（buffer）的页头会被打上一个特殊标记（tag）。这个过程非常迅速，因为它不涉及任何 I&#x2F;O 操作，只是内存中的标记设置。</p>
<p>随后，checkpointer 会遍历所有缓冲区，并将带有该标记的页写入磁盘。这些页不会被驱逐出缓存（即它们仍然保留在缓冲池中），只是被刷盘，因此在这个过程中可以忽略使用计数（usage count）和 pin 计数（pin count）。</p>
<p>页面按 ID 顺序处理，以尽可能避免随机写入。为实现更好的负载均衡，PostgreSQL 会在多个表空间之间交替进行写入（因为它们可能位于不同的物理设备上）。</p>
<p>后端进程（backend）也可以将打了标记的缓冲页写入磁盘 —— 如果它们先访问到了这些页的话。无论由谁写入，缓冲区的标记都会在这个阶段被清除，因此每个缓冲页在此次检查点中只会被写一次。  </p>
<p>很自然地，在 checkpoint 进行期间，缓冲区中的页面仍然可能被修改。但由于这些新的脏页没有被打上标记，checkpointer 会忽略它们。</p>
<h2 id="检查点完成："><a href="#检查点完成：" class="headerlink" title="检查点完成："></a>检查点完成：</h2><p>当在检查点开始时被标记为脏的所有缓冲页都已经写入磁盘后，检查点就被视为完成。从现在起（但不是在此之前！），本次检查点的起始位置将被作为恢复操作的新起点。在这个点之前写入的所有 WAL 日志都不再需要了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time →</span><br><span class="line">LSN：</span><br><span class="line">      ┌──────────────────────────────────────────────────────────────────────┐</span><br><span class="line">      │                                                                      │</span><br><span class="line">  0 ──┴─────┬───────────────────────────────────────────┬────────────┬───────┘</span><br><span class="line">            │                                           │            │</span><br><span class="line">            ▼                                           ▼            ▼</span><br><span class="line">            1                                           2            3</span><br><span class="line">✔ 若 3 写入成功：恢复可从 2 开始（即 redo = 2）</span><br><span class="line">✘ 若 3 写入失败：恢复只能从 1 开始（上次 checkpoint）</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 1：上一次 checkpoint 的起始 LSN（redo）</span><br><span class="line">- 2：本次 checkpoint 开始时wallog最大LSN（新的redo点）</span><br><span class="line">- 3：本次 checkpoint 完成后写入 WAL 的记录（记录了 redo=2）</span><br></pre></td></tr></table></figure>
<p>最后，checkpointer 进程会创建一条表示检查点完成的 WAL 记录，并在其中标明此次检查点的起始 LSN。由于检查点在开始时不会写入任何日志，因此这个起始 LSN 可以是任意类型的 WAL 记录所属的 LSN。<br>此外，PGDATA&#x2F;global&#x2F;pg_control 文件也会被更新，以指向最近完成的检查点。（在此过程完成之前，pg_control 始终保留着上一个检查点的信息。）</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">UPDATE</span> big <span class="keyword">SET</span> s <span class="operator">=</span> <span class="string">&#x27;FOO&#x27;</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache <span class="keyword">WHERE</span> isdirty;</span><br><span class="line">count </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">4119</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line">pg_current_wal_insert_lsn</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF7E0 (<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> CHECKPOINT;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> pg_buffercache <span class="keyword">WHERE</span> isdirty;</span><br><span class="line">count </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line">pg_current_wal_insert_lsn </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF890 </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>最新的 WAL 条目与检查点完成有关（CHECKPOINT_ONLINE）。该检查点的起始 LSN 出现在 redo 之后；这个位置对应的是检查点开始时最新插入的 WAL 条目。</p>
<p>同样的信息也可以在 pg_control 文件中找到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres$ <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>bin<span class="operator">/</span>pg_controldata \</span><br><span class="line"><span class="operator">-</span>D <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>data <span class="operator">|</span> egrep <span class="string">&#x27;Latest.*location&#x27;</span> Latest checkpoint location: <span class="number">0</span><span class="operator">/</span><span class="number">3E7</span>EF818</span><br><span class="line">Latest checkpoint<span class="string">&#x27;s REDO location: 0/3E7EF7E0</span></span><br></pre></td></tr></table></figure>

<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Distinct_Values</title>
    <url>/2025/12/22/postgresql/Distinct-Values/</url>
    <content><![CDATA[<p>pg_stats 视图中的 n_distinct 字段表示某一列中不同取值（distinct values）的数量。</p>
<p>如果 n_distinct 为负数，其绝对值表示该列中不同取值所占的比例，而不是实际的不同值个数。例如，−1 表示该列中所有值都是唯一的；−3 表示平均而言，每个不同的值大约出现在 3 行中。当估计的不同值数量超过表中总行数的 10% 时，分析器（analyzer）会使用这种“比例”的表示方式。</p>
<p>如果预期数据是均匀分布的，则会直接使用不同值的数量。例如，在估算 column &#x3D; expression 这种条件的基数（cardinality）时，如果在规划阶段无法确定表达式的具体取值，查询规划器会假设该表达式可以以相同的概率取列中的任意一个值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> airport_code</span><br><span class="line">	<span class="keyword">FROM</span> airports</span><br><span class="line">	<span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;Saint Petersburg&#x27;</span></span><br><span class="line">);</span><br><span class="line">                          QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">30.56</span>.<span class="number">.5340</span><span class="number">.40</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2066</span> width<span class="operator">=</span><span class="number">63</span>) </span><br><span class="line">	<span class="keyword">Filter</span>: (departure_airport <span class="operator">=</span> $<span class="number">0</span>)</span><br><span class="line">	InitPlan <span class="number">1</span> (<span class="keyword">returns</span> $<span class="number">0</span>)</span><br><span class="line">		−<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> airports_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.30</span><span class="number">.56</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> wi... </span><br><span class="line">			<span class="keyword">Filter</span>: ((city −<span class="operator">&gt;&gt;</span> lang()) <span class="operator">=</span> <span class="string">&#x27;Saint Petersburg&#x27;</span>::text)</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>Extended_Query_Protocol</title>
    <url>/2025/12/16/postgresql/Extended-Query-Protocol/</url>
    <content><![CDATA[<p>当使用简单查询协议时，每个命令（即使重复多次）都必须经历上述所有阶段：</p>
<ol>
<li>parsing</li>
<li>transformation </li>
<li>planning</li>
<li>execution</li>
</ol>
<p>但是，一次又一次地解析相同的查询是没有意义的。重复解析仅在常量上不同的查询也没有多大意义——解析树结构仍然保持不变。</p>
<p>简单查询协议的另一个缺点是客户端会立即收到整个结果，无论它可能包含多少行。</p>
<p>一般来说，使用 SQL 命令可以克服这些限制。要处理第一种情况，您可以在运行 EXECUTE 命令之前PREPARE查询；第二个问题可以通过使用 DECLARE 创建游标并通过 FETCH 返回行来解决。但在这种情况下，这些新创建的对象的命名必须由客户端处理，而服务器则需要解析额外命令的额外开销</p>
<p>扩展的客户端—服务器协议提供了一种替代方案，使得可以在协议本身的命令级别上，对各个算子执行阶段进行精确控制。</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><p>在准备阶段，查询会像往常一样被解析并进行转换，但生成的解析树会保存在后端的内存中。</p>
<p>PostgreSQL 并不存在全局的查询缓存。这种架构的缺点是显而易见的：即使同一条查询已经被其他后端进程解析过，每个后端仍然必须重新解析其接收到的所有查询。但与此同时，这种设计也带来了一些好处。全局缓存由于需要加锁，很容易成为系统瓶颈。一个客户端如果频繁执行大量相似但不完全相同的小查询（例如仅常量不同的查询），会产生大量缓存访问流量，从而对整个实例的性能造成负面影响。在 PostgreSQL 中，查询是在各个后端本地解析的，因此不会对其他进程产生影响。</p>
<p>一条预处理（prepared）的查询可以带参数化。下面是一个使用 SQL 命令的简单示例（尽管这与协议层的预处理不完全相同，但最终效果是一样的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">PREPARE</span> plane(text) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> $<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所有命名的预处理语句都显示在 pg_prepared_statements 视图中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, statement, parameter_types</span><br><span class="line"><span class="keyword">FROM</span> pg_prepared_statements \gx</span><br><span class="line">−[ RECORD <span class="number">1</span> ]−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">name            <span class="operator">|</span> plane</span><br><span class="line">statement       <span class="operator">|</span> <span class="keyword">PREPARE</span> plane(text) <span class="keyword">AS</span> <span class="operator">+</span></span><br><span class="line">                <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> $<span class="number">1</span>; </span><br><span class="line">parameter_types <span class="operator">|</span> &#123;text&#125;</span><br></pre></td></tr></table></figure>
<p>这里不会显示任何未命名语句（即使用扩展查询协议或 PL&#x2F;pgSQL 的语句）。其他后端准备的语句也不会显示：因为无法访问其他会话的内存。</p>
<h2 id="Parameter-Binding"><a href="#Parameter-Binding" class="headerlink" title="Parameter Binding"></a>Parameter Binding</h2><p>在预处理语句被执行之前，必须先绑定实际的参数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;733&#x27;</span>);</span><br><span class="line">aircraft_code <span class="operator">|</span> model <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−− </span><br><span class="line"><span class="number">733</span>            <span class="operator">|</span> Boeing <span class="number">737</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">4200</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>在预处理语句中绑定参数，相比将字面量直接拼接到查询字符串中，其优势在于可以彻底杜绝 SQL 注入：绑定的参数值无法以任何方式修改已经构建完成的解析树。若不使用预处理语句而想达到同等的安全级别，就必须对来自不可信来源的每一个值进行非常谨慎的转义处理。</p>
<h2 id="Planning-and-Execution"><a href="#Planning-and-Execution" class="headerlink" title="Planning and Execution"></a>Planning and Execution</h2><p>在执行预处理语句时，查询规划会基于实际的参数值来进行；随后生成的执行计划会交由执行器处理。</p>
<p>由于不同的参数值可能对应不同的最优执行计划，因此在规划阶段准确考虑具体参数值是非常重要的。举例来说，在查询价格较高的预订记录时，规划器会假定符合条件的行数不多，从而选择使用索引扫描。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> bookings(total_amount);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> bookings</span><br><span class="line"><span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">1000000</span>;</span><br><span class="line">								QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Bitmap Heap Scan <span class="keyword">on</span> bookings (cost<span class="operator">=</span><span class="number">86.49</span>.<span class="number">.9245</span><span class="number">.82</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4395</span> wid... </span><br><span class="line">	Recheck Cond: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;1000000&#x27;</span>::<span class="type">numeric</span>)</span><br><span class="line">	−<span class="operator">&gt;</span> Bitmap Index Scan <span class="keyword">on</span> bookings_total_amount_idx (cost<span class="operator">=</span><span class="number">0.00</span>....</span><br><span class="line">Index Cond: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;1000000&#x27;</span>::<span class="type">numeric</span>) </span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>但如果给定的条件对所有预订记录都成立，那么使用索引就没有意义了，因为最终仍然需要扫描整张表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> bookings</span><br><span class="line"><span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line">							QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> bookings (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.39835</span><span class="number">.88</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2111110</span> width<span class="operator">=</span><span class="number">21</span>) <span class="keyword">Filter</span>: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;100&#x27;</span>::<span class="type">numeric</span>)</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在某些情况下，规划器可能会同时保留解析树和查询计划，以避免重复进行规划。由于这种计划不会考虑具体的参数值，因此被称为通用计划（generic plan），以区别于基于实际参数值生成的定制计划（custom plan）。</p>
<p>参数化预处理语句的前五次执行，优化过程始终依赖于实际的参数值；规划器会基于这些参数值计算定制计划（custom plan）的平均成本。从第六次执行开始，如果通用计划（generic plan）在平均意义上比定制计划更高效（同时考虑到每次都需要重新生成定制计划的额外开销），规划器就会保留通用计划并继续使用它，从而跳过后续的优化阶段。</p>
<p>一个显而易见的场景是：当查询不包含任何参数时，数据库可以使用通用计划而不会对性能造成影响</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;763&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;773&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;319&#x27;</span>);</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> <span class="string">&#x27;319&#x27;</span>::text) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p> 在第五次执行之后，规划器会切换为通用计划（generic plan）：该计划与之前的定制计划并无差别，成本也相同，但后端只需构建一次即可，并且可以跳过优化阶段，从而降低规划开销。此时，EXPLAIN 命令显示参数是通过位置来引用的，而不再显示其具体取值。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;320&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;321&#x27;</span>);</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> $<span class="number">1</span>) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“优化阶段”特指每次执行时基于参数值重新生成执行计划的那一部分工作。</p>
</blockquote>
<p> 我们可以很容易想象这样一种不利情况：前几次生成的 custom plan 比 generic plan 更昂贵；随后可能出现的更高效的 custom plan 却完全不会被考虑。此外，规划器比较的是估算成本而非实际执行成本，这也可能导致误判。</p>
<p>不过，如果规划器的自动决策出现偏差，你可以通过设置 plan_cache_mode 参数来覆盖自动选择，从而强制使用 generic plan 或 custom plan</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SET</span> plan_cache_mode <span class="operator">=</span> <span class="string">&#x27;force_custom_plan&#x27;</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;CN1&#x27;</span>);</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> <span class="string">&#x27;CN1&#x27;</span>::text) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>除了其他信息之外，pg_prepared_statements 视图还显示了所选计划的统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; SELECT name, generic_plans, custom_plans</span><br><span class="line">FROM pg_prepared_statements;</span><br><span class="line">name   | generic_plans | custom_plans </span><br><span class="line">−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−− </span><br><span class="line">plane  | 1             | 6</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="Getting-the-Results"><a href="#Getting-the-Results" class="headerlink" title="Getting the Results"></a>Getting the Results</h2><p>扩展查询协议允许按批次而不是一次性检索数据。SQL 游标（cursor）几乎具有相同效果（唯一的区别是服务器需要做一些额外处理，而且规划器只会优化前 <em>cursor_tuple_fraction</em> 行的获取，而不是整个结果集）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> aircrafts</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> aircraft_code;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">FETCH</span> <span class="number">3</span> <span class="keyword">FROM</span> cur;</span><br><span class="line">aircraft_code  <span class="operator">|</span> model           <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−</span><br><span class="line"><span class="number">319</span>            <span class="operator">|</span> Airbus A319−<span class="number">100</span> <span class="operator">|</span> <span class="number">6700</span></span><br><span class="line"><span class="number">320</span>            <span class="operator">|</span> Airbus A320−<span class="number">200</span> <span class="operator">|</span> <span class="number">5700</span></span><br><span class="line"><span class="number">321</span>            <span class="operator">|</span> Airbus A321−<span class="number">200</span> <span class="operator">|</span> <span class="number">5600</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">FETCH</span> <span class="number">2</span> <span class="keyword">FROM</span> cur;</span><br><span class="line">aircraft_code  <span class="operator">|</span> model          <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−− </span><br><span class="line"><span class="number">733</span>            <span class="operator">|</span> Boeing <span class="number">737</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">4200</span> </span><br><span class="line"><span class="number">763</span>            <span class="operator">|</span> Boeing <span class="number">767</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">7900</span></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>) </span><br></pre></td></tr></table></figure>

<p>如果查询返回大量行，且客户端需要获取所有行，那么系统吞吐量高度依赖于批量大小（batch size）。批量包含的行数越多，每次访问服务器并获取响应时产生的通信开销就越小。然而，随着批量大小继续增加，这种优势会逐渐减弱：例如，将行一条条取出与每批取 10 行的差别非常明显，但将每批取 100 行与每批取 1000 行相比，性能提升就不那么显著了</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>GiST framework</title>
    <url>/2025/12/01/postgresql/GiST/</url>
    <content><![CDATA[<p>Gist（Generalized Search Tree，广义搜索树）是一种访问方法(是一个索引框架)，本质上是对支持值之间相对位置关系的数据类型的平衡搜索树的一种泛化。B-tree 只能用于可排序的数据类型，即那些支持比较操作（比如大于、小于等）。对于这类类型，B-tree 的支持是非常高效的。而 Gist 则更为通用，它的操作符类（operator class）允许用户定义任意的数据分布规则，从而控制树的构造方式。因此，Gist 索引可以用于实现不同的数据结构，例如：</p>
<ul>
<li>R-tree（二维&#x2F;多维空间数据）</li>
<li>RD-tree（集合之间的相似性度量）</li>
<li>签名树（类似 Bloom filter 的结构，用于快速过滤模糊匹配，比如文本）</li>
</ul>
<p>由于 PostgreSQL 的可扩展性，你可以通过实现索引引擎的接口，从零开始创建一个新的访问方法（access method）。但是，除了设计索引逻辑之外，你还需要定义页面布局、高效的锁策略，以及其它底层支持功能。这一切都需要强大的编程能力和大量的实现工作。Gist 简化了这项任务，它处理了所有低层次的技术细节，并提供了搜索算法的基础框架。如果你想让某个新的数据类型支持 Gist 方法，你只需要添加一个新的操作符类（operator class），其中包含大约十几个支持函数（support functions）。与 B-tree 的“简单”操作符类不同，Gist 的操作符类承载了主要的索引逻辑。因此，从这个角度看，Gist 可以被认为是构建新访问方法的一个框架。</p>
<p>每个属于叶子节点的条目（称为“叶子条目”）都包含一个谓词（逻辑条件）和一个指向堆中元组（heap tuple）的引用。索引键（index key）必须满足这个谓词；至于这个键是否直接出现在条目中并不重要。（叶子节点中每一项不是“具体的值”，而是“某种条件”——这个条件是能覆盖实际数据的逻辑表达式。）</p>
<p>每个内部节点中的条目（称为“内部条目”）也包含一个谓词，以及一个指向子节点的引用；子树中所有的数据都必须满足这个谓词。换句话说，内部节点条目的谓词是其所有子节点谓词的“并集”。GiST 的这个重要特性（即“内部节点的谓词是子节点谓词的并集”）实现了类似于 B-tree 中的简单排序（simple ranking）功能（GiST 通过组织谓词的包含关系，实现了类似于 B-tree 按顺序剪枝的搜索效率）。</p>
<p>GiST 树的搜索依赖于 一致性函数（consistency function），它是由操作符类（operator class）定义的一种支持函数。</p>
<p>一致性函数会在某个索引项上被调用，用来判断这个条目的谓词是否与搜索条件一致（即与“索引列的操作符表达式”是否可能匹配）。对于内部节点的条目，一致性函数用于判断是否需要进入对应的子树；对于叶子节点的条目，它用于判断这个索引键是否满足查询条件</p>
<p>搜索从根节点开始，这是树形结构中常见的做法。一致性函数（consistency function）决定哪些子节点需要继续遍历，哪些可以被跳过。然后对选中的每个子节点重复这一过程；与 B-tree 不同，GiST 可能会同时有多个符合条件的子节点。被一致性函数选中的叶子节点条目将作为查询结果返回</p>
<p>GiST 的搜索始终是深度优先的：算法会尽可能尽快到达叶子页面。这种策略对返回前几条结果（Top-N 查询）尤其有利。</p>
<p>在向 GiST 树中插入一个新值时，无法使用一致性函数（consistent()），因为我们需要精确选择一个子节点进行插入。插入逻辑依赖于 penalty() 函数，去评估每个候选子节点“因插入新值而造成的扩展代价”；最终选择 penalty 最小的子节点 来插入。</p>
<p>和B树索引一样，叶子结点没有空间会造成页面分裂（split），split需要两个函数，一个负责在新老节点之间分布数据，另一个函数则对两个谓词进行并集操作，以更新父节点的谓词</p>
<p>随着新值不断插入，已有的谓词会不断扩大，而这些谓词通常只有在页面分裂或整个索引重建时才会被缩小。因此，频繁更新 GiST 索引可能会导致其性能下降</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Install postgres from codes in linux</title>
    <url>/2024/06/30/postgresql/Install-postgres-from-codes-in-linux/</url>
    <content><![CDATA[<p>First, we need to create a postgres user and add it to the sudo group</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -aG <span class="built_in">sudo</span> postgres <span class="comment"># 注意安全，云主机不要这么设置</span></span><br></pre></td></tr></table></figure>

<h2 id="Get-codes"><a href="#Get-codes" class="headerlink" title="Get codes"></a>Get codes</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://git.postgresql.org/git/postgresql.git</span><br></pre></td></tr></table></figure>
<p>Compile after installing dependencies</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">  build-essential \</span><br><span class="line">  libreadline-dev \</span><br><span class="line">  zlib1g-dev \</span><br><span class="line">  flex \</span><br><span class="line">  bison \</span><br><span class="line">  libxml2-dev \</span><br><span class="line">  libxslt1-dev \</span><br><span class="line">  libssl-dev \</span><br><span class="line">  libpam0g-dev \</span><br><span class="line">  libedit-dev \</span><br><span class="line">  libldap2-dev \</span><br><span class="line">  libicu-dev \</span><br><span class="line">  tcl-dev \</span><br><span class="line">  uuid-dev \</span><br><span class="line">  python3-dev \</span><br><span class="line">  libperl-dev \</span><br><span class="line">  llvm-dev \</span><br><span class="line">  clang \</span><br><span class="line">  libperl-dev \</span><br><span class="line">  libpython3-dev \</span><br><span class="line">  libossp-uuid-dev \</span><br><span class="line">  systemtap-sdt-dev \</span><br><span class="line">  pkg-config</span><br><span class="line">./configure --enable-debug <span class="string">&#x27;CFLAGS=-O0 -g&#x27;</span> --enable-cassert --enable-depend --enable-dtrace --without-icu --with-llvm --prefix</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="Modify-environment-variables"><a href="#Modify-environment-variables" class="headerlink" title="Modify environment variables"></a>Modify environment variables</h2><p>create a configure file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.pg_env</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前使用的 PostgreSQL 安装路径</span></span><br><span class="line"><span class="built_in">export</span> PG_HOME=<span class="variable">$HOME</span>/pgsql</span><br><span class="line"><span class="built_in">export</span> PGDATA=<span class="variable">$HOME</span>/pgdata</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PG_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PG_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：显示当前 PostgreSQL 版本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🔧 Loaded PG env: <span class="subst">$(pg_config --version)</span>&quot;</span></span><br><span class="line">在 ~/.bashrc 末尾加上这一行：</span><br><span class="line">[ -f ~/.pg_env ] &amp;&amp; <span class="built_in">source</span> ~/.pg_env</span><br></pre></td></tr></table></figure>
<h2 id="initdb"><a href="#initdb" class="headerlink" title="initdb"></a>initdb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R postgres:postgres /usr/local/pgsql</span><br><span class="line">initdb</span><br></pre></td></tr></table></figure>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pg_ctl -D /usr/local/pgsql/data -l logfile start</span><br></pre></td></tr></table></figure>

<h2 id="About-Extensions"><a href="#About-Extensions" class="headerlink" title="About Extensions"></a>About Extensions</h2><p>cd contrib</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>登录你要使用的数据库，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION pageinspect;</span><br><span class="line">\dx</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>LWLock in postgres</title>
    <url>/2025/09/05/postgresql/LWLock-in-postgres/</url>
    <content><![CDATA[<h2 id="一-相关结构体说明"><a href="#一-相关结构体说明" class="headerlink" title="一 相关结构体说明"></a>一 相关结构体说明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LWLock</span></span><br><span class="line">&#123;</span><br><span class="line">    uint16           tranche;       <span class="comment">/* tranche ID */</span></span><br><span class="line">    pg_atomic_uint32 state;         <span class="comment">/* state of exclusive/nonexclusive lockers */</span></span><br><span class="line">    proclist_head    waiters;       <span class="comment">/* list of waiting PGPROCs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCK_DEBUG</span></span><br><span class="line">    pg_atomic_uint32 nwaiters;      <span class="comment">/* number of waiters */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PGPROC</span>    *owner;        <span class="comment">/* last exclusive owner of the lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; LWLock;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>tranche<br>每个 LWLock 都属于某个 tranche，tranche 是一个 int 类型的 ID，代表这把锁的用途</p>
</li>
<li><p>state<br>bit0～23：共享锁状态，实际最多用bit0～17，因为backend最多18位<br>bit24: 排他锁状态<br>bit28：用于锁定等待队列：waiters<br>bit29: 是否允许唤醒等待队列里面的进程，初始状态：LW_FLAG_RELEASE_OK<br>bit30: LW_FLAG_HAS_WAITERS ：是否有waiter</p>
</li>
<li><p>waiters<br>等待队列</p>
</li>
</ul>
<h2 id="二-Interface说明"><a href="#二-Interface说明" class="headerlink" title="二 Interface说明"></a>二 Interface说明</h2><h3 id="2-1-LWLockAcquire"><a href="#2-1-LWLockAcquire" class="headerlink" title="2.1 LWLockAcquire"></a>2.1 LWLockAcquire</h3><p>加锁，失败进入等待队列，直接加上锁的情况，可能会造成等待队列无效唤醒  </p>
<blockquote>
<p>acquire a lightweight lock in the specified mode<br>Side effect: cancel&#x2F;die interrupts are held off until lock release.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == LW_EXCLUSIVE)</span><br><span class="line">&#123;</span><br><span class="line">    lock_free = (old_state &amp; LW_LOCK_MASK) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lock_free)</span><br><span class="line">        desired_state += LW_VAL_EXCLUSIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_free = (old_state &amp; LW_VAL_EXCLUSIVE) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lock_free)</span><br><span class="line">        desired_state += LW_VAL_SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按位判断前25位即可知道此LWLock是否被进程所占</p>
<h3 id="2-2-LWLockRelease"><a href="#2-2-LWLockRelease" class="headerlink" title="2.2 LWLockRelease"></a>2.2 LWLockRelease</h3><p>进行唤醒条件：</p>
<ul>
<li>oldstate &amp; LW_FLAG_HAS_WAITERS：等待队列非空。这个条件确认有进程在等待锁。  </li>
<li>oldstate &amp; LW_FLAG_RELEASE_OK： 允许唤醒。这个标志表示系统在上次唤醒后，已经将再次唤醒其他等待者的权限交给了被唤醒的进程。</li>
<li>(oldstate &amp; LW_LOCK_MASK) &#x3D;&#x3D; 0：锁已空闲。这个条件确认锁当前没有被任何进程占用（无论是独占模式还是共享模式，计数都为零）</li>
</ul>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock</title>
    <url>/2025/09/03/postgresql/Lock/</url>
    <content><![CDATA[<h2 id="全局hash"><a href="#全局hash" class="headerlink" title="全局hash"></a>全局hash</h2><p>LockMethodLockHash：存储LOCK<br>LockMethodProcLockHash：存储PROCLOCK<br>LockMethodLocalHash：存储LOCALLOCK</p>
<p>同一个LOCK资源对象可以被多个不同的 PROCLOCK 持有，而这些 PROCLOCK 又分别属于不同的进程。</p>
<h2 id="LOCKTAG"><a href="#LOCKTAG" class="headerlink" title="LOCKTAG"></a>LOCKTAG</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCKTAG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	uint32		locktag_field1; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint32		locktag_field2; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint32		locktag_field3; <span class="comment">/* a 32-bit ID field */</span></span><br><span class="line">	uint16		locktag_field4; <span class="comment">/* a 16-bit ID field */</span></span><br><span class="line">	uint8		locktag_type;	<span class="comment">/* see enum LockTagType */</span></span><br><span class="line">	uint8		locktag_lockmethodid;	<span class="comment">/* lockmethod indicator */</span></span><br><span class="line">&#125; LOCKTAG;</span><br></pre></td></tr></table></figure>
<ul>
<li>locktag_type<br>标识这个锁是针对哪类资源的。每种 LockTagType 决定了 LOCKTAG 里后面几个字段（locktag_field1 ~ locktag_field4）是怎么解释的，比如：<br>LOCKTAG_TRANSACTION：xid<br>LOCKTAG_RELATION：dbOid + relOid<br>LOCKTAG_TUPLE：dbOid + relOid + blockNum + offNum       </li>
<li>locktag_lockmethodid<ul>
<li>DEFAULT_LOCKMETHOD（id &#x3D; DEFAULT_LOCKMETHOD)<br>  绝大多数用户可见的锁（relation, tuple, transactionid 等）都走它。</li>
<li>USER_LOCKMETHOD（id &#x3D; USER_LOCKMETHOD)<br>  提供给 pg_advisory_lock() 一类的 advisory lock，用于用户自定义锁。</li>
</ul>
</li>
</ul>
<h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LOCKTAG		tag;			</span><br><span class="line">	LOCKMASK	grantMask;		</span><br><span class="line">	LOCKMASK	waitMask;		</span><br><span class="line">	dlist_head	procLocks;		</span><br><span class="line">	dclist_head     waitProcs;		</span><br><span class="line">	<span class="type">int</span>		requested[MAX_LOCKMODES];	</span><br><span class="line">	<span class="type">int</span>		nRequested;		</span><br><span class="line">	<span class="type">int</span>		granted[MAX_LOCKMODES]; </span><br><span class="line">	<span class="type">int</span>		nGranted;		</span><br><span class="line">&#125; LOCK;</span><br></pre></td></tr></table></figure>
<ul>
<li>waitProcs<br>等待本LOCK的PGPROC链表</li>
<li>procLocks<br>等待本LOCK的PROCLOCK链表</li>
<li>waitMask<br>该资源上等待的锁类型</li>
<li>grantMask<br>该资源上已经授予的锁类型</li>
</ul>
<h2 id="LOCKMODE"><a href="#LOCKMODE" class="headerlink" title="LOCKMODE"></a>LOCKMODE</h2><p>每种资源支持8种锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NoLock					0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessShareLock			1	<span class="comment">/* SELECT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowShareLock			2	<span class="comment">/* SELECT FOR UPDATE/FOR SHARE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowExclusiveLock		3	<span class="comment">/* INSERT, UPDATE, DELETE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareUpdateExclusiveLock 4	<span class="comment">/* VACUUM (non-FULL), ANALYZE, CREATE</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * INDEX CONCURRENTLY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareLock				5	<span class="comment">/* CREATE INDEX (WITHOUT CONCURRENTLY) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareRowExclusiveLock	6	<span class="comment">/* like EXCLUSIVE MODE, but allows ROW</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * SHARE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ExclusiveLock			7	<span class="comment">/* blocks ROW SHARE/SELECT...FOR UPDATE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessExclusiveLock		8	<span class="comment">/* ALTER TABLE, DROP TABLE, VACUUM FULL,</span></span></span><br><span class="line"><span class="comment"><span class="meta">									 * and unqualified LOCK TABLE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLockMode				8	<span class="comment">/* highest standard lock mode */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="冲突矩阵"><a href="#冲突矩阵" class="headerlink" title="冲突矩阵"></a>冲突矩阵</h2><table>
<thead>
<tr>
<th>Requested Lock Mode</th>
<th>ACCESS SHARE</th>
<th>ROW SHARE</th>
<th>ROW EXCL.</th>
<th>SHARE UPDATE EXCL.</th>
<th>SHARE</th>
<th>SHARE ROW EXCL.</th>
<th>EXCL.</th>
<th>ACCESS EXCL.</th>
</tr>
</thead>
<tbody><tr>
<td>ACCESS SHARE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>ROW SHARE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ROW EXCL.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE UPDATE EXCL.</td>
<td></td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>SHARE ROW EXCL.</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>EXCL.</td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ACCESS EXCL.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.postgresql.org/docs/17/explicit-locking.html">postgres官方文档</a>  </p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Logging</title>
    <url>/2025/02/27/postgresql/Logging/</url>
    <content><![CDATA[<p>在发生故障（例如停电、操作系统错误或数据库服务器崩溃）时，RAM 中的所有内容都将丢失；只有写入磁盘的数据会保留下来。要在故障后启动服务器，您必须恢复数据一致性。如果磁盘本身已损坏，则必须通过备份恢复来解决相同的问题。</p>
<p>理论上，您可以始终保持磁盘上的数据一致性。但实际上，这意味着服务器必须不断地将随机页面写入磁盘（尽管顺序写入成本更低），并且此类写入的顺序必须保证在任何特定时刻都不会损害一致性（这很难实现，尤其是当您处理复杂的索引结构时）。</p>
<p>与大多数数据库系统一样，PostgreSQL 采用了一种不同的方法。</p>
<p>服务器运行时，部分当前数据仅存在于 RAM 中，其写入永久存储的操作被推迟。因此，服务器运行时存储在磁盘上的数据始终是不一致的，因为页面从不会一次性全部刷新。但是，RAM 中发生的每个更改（例如在缓冲区缓存中执行的页面更新）都会被记录下来：PostgreSQL 会创建一个日志条目，其中包含在需要时重复此操作所需的所有基本信息。</p>
<p>页面修改相关的日志条目必须先于修改后的页面本身写入磁盘。这就是日志名称的由来：预写式日志（write-ahead log），简称 WAL。这项要求保证了在发生故障时，PostgreSQL 可以从磁盘读取 WAL 条目并重放它们，以重复那些已完成但结果仍在 RAM 中且在崩溃前未写入磁盘的操作。</p>
<p>保留预写式日志通常比将随机页面写入磁盘更高效。WAL 条目构成一个连续的数据流，即使是硬盘驱动器 (HDD) 也能很好地处理。此外，WAL 条目通常比页面大小更小。</p>
<p>为了在发生故障时避免数据不一致，所有可能破坏数据一致性的操作都需要记录下来。具体来说，以下操作会记录在 预写式日志 (WAL) 中：</p>
<ul>
<li>WAL 记录的操作</li>
</ul>
<ol>
<li>缓冲区缓存中的页面修改：由于写入是延迟的，这些修改需要记录下来以备恢复。</li>
<li>事务提交和回滚：事务状态的变化发生在 CLOG 缓冲区中，不会立即写入磁盘，因此需要记录。</li>
<li>文件操作：当添加或删除表时，文件和目录的创建与删除等操作必须与数据更改同步，所以也要记录。</li>
</ol>
<ul>
<li>WAL 不记录的操作</li>
</ul>
<ol>
<li>unlogged表相关操作</li>
<li>临时表上的操作：由于临时表的生命周期仅限于创建它们的会话，所以它们的操作不会被记录。<blockquote>
<p>在 PostgreSQL 10 之前，哈希索引的操作也不会被记录。它们的主要目的是将哈希函数与不同的数据类型匹配。</p>
</blockquote>
</li>
</ol>
<p>除了用于崩溃恢复之外，WAL 还可以用于从备份进行时间点恢复以及数据复制。</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>NULL VALUES</title>
    <url>/2025/12/19/postgresql/NULL-VALUES/</url>
    <content><![CDATA[<p>虽然理论学家对此不以为然，但 NULL 值在关系型数据库中仍然扮演着重要角色：它提供了一种方便的方式来表示某个值要么未知，要么不存在。</p>
<p>然而，特殊的值需要特殊处理。除了理论上的不一致性之外，还有许多实际问题需要考虑。常规的布尔逻辑被三值逻辑取代，因此 NOT IN 的行为可能出乎意料。对于 NULL 值应该被视为大于还是小于普通值也不明确（因此存在用于排序的 NULLS FIRST 和 NULLS LAST 子句）。是否需要在聚合函数中考虑 NULL 值也并不十分明显。严格来说，NULL 根本不是一个值，因此优化器在处理它们时需要额外的信息。</p>
<p>除了在表级收集的最基本的统计信息之外，分析器还会为表的每一列收集统计信息。这些数据存储在系统目录的 <em>pg_statistic</em> 表中，但你也可以通过 pg_stats 视图访问，这个视图以更方便的格式提供这些信息。<br>列级统计信息中包括 NULL 值的比例；在分析过程中计算，并以 null_frac 属性表示。<br>例如，当我们查询尚未起飞的航班时，可以依赖它们的起飞时间未定义（NULL）这一事实：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">							QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4772</span><span class="number">.67</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">16702</span> width<span class="operator">=</span><span class="number">63</span>) <span class="keyword">Filter</span>: (actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>为了估算结果，优化器将表的总行数乘以 NULL 值的比例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> round(reltuples <span class="operator">*</span> s.null_frac) <span class="keyword">AS</span> <span class="keyword">rows</span> <span class="keyword">FROM</span> pg_class</span><br><span class="line"><span class="keyword">JOIN</span> pg_stats s <span class="keyword">ON</span> s.tablename <span class="operator">=</span> relname <span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;actual_departure&#x27;</span>;</span><br><span class="line"> <span class="keyword">rows</span> </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">16702</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>以下是实际的行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"> count </span><br><span class="line">−−−−−−− </span><br><span class="line"> <span class="number">16348</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
  </entry>
  <entry>
    <title>Query Execution Stages</title>
    <url>/2025/12/07/postgresql/Query-Execution-Stages/</url>
    <content><![CDATA[<h2 id="1-Demo-Database"><a href="#1-Demo-Database" class="headerlink" title="1. Demo Database"></a>1. Demo Database</h2><p>前面章节中的示例都是基于只有几行数据的简单表。本章以及后面的章节要处理查询执行，在这方面对数据要求更高：我们需要行数多得多、彼此有关联的表。为了不在每个示例中都重新发明一个新的数据集，我选用了一个现成的演示数据库，它展示了俄罗斯的客运航空交通情况。这个数据库有多个版本；我们将使用 2017 年 8 月 15 日创建的较大版本。要安装这个版本，你需要从压缩包中解压出包含数据库副本的文件，然后在 psql 中运行这个文件。</p>
<p>在开发这个演示数据库时，我们尝试让它的模式（schema）足够简单，以便无需额外说明就能理解；同时，我们也希望它足够复杂，能够用来编写有意义的查询。数据库填充了贴近真实场景的数据，这使得示例更加全面，也更有趣味性。</p>
<p>这里我只会简要介绍主要的数据库对象；如果你想查看整个模式(schema)，可以参阅脚注中引用的完整描述。</p>
<p>主要的实体(entity)是 预订（<strong>booking</strong>），它对应于 bookings 表。一个预订可以包含多个乘客，每个乘客都有单独的电子机票（对应 tickets 表）。乘客本身不构成独立的实体；在我们的实验中，我们假设所有乘客都是唯一的</p>
<p>每张机票包含一个或多个航段（对应 ticket_flights 表）。一张机票之所以可能有多个航段，主要有两种情况：要么它是往返票，要么它包含联程航班。虽然数据库模式中没有相应的约束，但我们假设同一个预订（booking）中的所有机票都拥有相同的航段。</p>
<p>每个航班（flights 表）都从一个机场（airports 表）飞往另一个机场。具有相同航班号的航班拥有相同的出发地和目的地，但起飞日期不同。</p>
<p>routes 视图基于 flights 表构建；它展示的是与具体航班日期无关的航线信息。</p>
<p>在值机时，每位乘客都会被发放一张带有座位号的登机牌（boarding_passes 表）。乘客只能为机票中包含的航班办理值机。航班 + 座位 的组合必须唯一，因此不可能为同一个座位发放两张登机牌。</p>
<p>飞机上的座位数量（seats 表）以及这些座位在不同舱位之间的分布，取决于执行该航班的具体机型（aircrafts 表）。我们假设每一种机型只能有一种客舱布局。</p>
<p>有些表使用了代理主键（surrogate primary key），而另一些表使用了自然主键（natural key）（其中有些还是复合主键）。这样设计纯粹是为了演示，绝不是推荐的实践方式。</p>
<p>这个演示数据库可以看作是真实系统的一份转储：其中包含了某个过去时间点的数据快照。要查看这个时间，可以调用 bookings.now() 函数。在需要使用 now() 的真实查询场景中，你可以在演示查询里使用这个函数。</p>
<p>机场、城市和机型的名称存储在 airports_data 和 aircrafts_data 表中，并提供了两种语言：英文和俄文。为了构建本章的示例，我通常会查询实体关系图中显示的 airports 和 aircrafts 这两个视图；这些视图会根据 bookings.lang 参数的值来选择输出语言。不过在查询计划中，有些底层表的名称仍然可能会出现。</p>
<h2 id="2-Simple-Query-Protoco"><a href="#2-Simple-Query-Protoco" class="headerlink" title="2. Simple Query Protoco"></a>2. Simple Query Protoco</h2><p>一种简单版本的客户端–服务器协议即可实现 SQL 查询的执行：客户端将查询文本发送给服务器，而服务器则返回完整的执行结果——无论结果包含多少行。发送到服务器的查询会经过几个阶段：解析（parse）→ 转换（transform）→ 计划（plan）→ 执行（execute）。</p>
<p><img src="/images/QES/qes1.png" alt="qes1"></p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>首先，PostgreSQL 必须对查询文本进行<strong>解析（parse）</strong>，以便理解需要执行的内容。</p>
<p><strong>Lexical and syntactic analysis</strong> 词法分析器（lexer）会把查询文本拆分成一组词法单元（lexemes），例如关键字、字符串字面量、数字字面量等；而<strong>语法分析器（parser）</strong>会根据 SQL 的语言语法规则对这组词法单元进行验证。PostgreSQL 使用的是标准的解析工具，即 Flex 和 Bison。</p>
<p>解析后的查询会以<strong>抽象语法树（AST）</strong>的形式存储在后端进程的内存中。</p>
<p>例如，让我们来看下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br></pre></td></tr></table></figure>
<p>词法分析器从中识别出了 5 个关键字、5 个标识符、1 个字符串字面量，以及 3 个单字符词素（一个逗号、一个等号和一个分号）。语法分析器则使用这些词素来构建解析树，下面的插图展示了一个高度简化的解析树。树中每个节点旁的文字说明表示该节点对应查询中的哪一部分：</p>
<p><img src="/images/QES/qes2.png" alt="qes2"></p>
<p>一个比较晦涩的缩写 RTE 代表 Range Table Entry（范围表项）。PostgreSQL 的源代码中使用 range table（范围表） 这个术语来指代表、子查询、连接结果——换句话说，指代 任何可以被 SQL 运算符处理的行集（set of rows）</p>
<p><strong>语义分析（Semantic analysis）</strong> 的目的在于确认数据库中是否存在该查询按名称引用的表或其他对象，并检查用户是否拥有访问这些对象的权限。语义分析所需的全部信息都存储在 系统目录（system catalog） 中。</p>
<p>在获得解析树之后，语义分析器会对其进行进一步的重组，这包括：为解析树添加对具体数据库对象、数据类型以及其他信息的引用。</p>
<p>如果你启用了参数 debug_print_parse，就可以在服务器日志中看到完整的解析树，但这通常没有太大的实际意义。</p>
<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>在下一阶段，查询会被<strong>转换（重写，rewrite）</strong>。</p>
<p>PostgreSQL 核心在多个场景下会使用查询转换。其中之一就是：<br>将解析树中 视图（view） 的名称替换为该视图底层查询（base query）对应的子树。</p>
<p>另一个使用转换的场景是行级安全（Row-Level Security, RLS） 的实现。<br>另外，递归查询中的 <strong>SEARCH</strong> 和 <strong>CYCLE</strong> 子句也会在此阶段被转换。</p>
<p>在上面的示例中，pg_tables 是一个视图；如果我们把它的定义直接展开写进查询文本，它将会是下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> (<span class="comment">-- pg_tables</span></span><br><span class="line">    <span class="keyword">SELECT</span> n.nspname <span class="keyword">AS</span> schemaname,</span><br><span class="line">        c.relname <span class="keyword">AS</span> tablename,</span><br><span class="line">        pg_get_userbyid(c.relowner) <span class="keyword">AS</span> tableowner,</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">FROM</span> pg_class c</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_namespace n <span class="keyword">ON</span> n.oid <span class="operator">=</span> c.relnamespace</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t <span class="keyword">ON</span> t.oid <span class="operator">=</span> c.reltablespace</span><br><span class="line">    <span class="keyword">WHERE</span> c.relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="keyword">ARRAY</span>[<span class="string">&#x27;r&#x27;</span>::<span class="type">char</span>, <span class="string">&#x27;p&#x27;</span>::<span class="type">char</span>])</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename；</span><br></pre></td></tr></table></figure>

<p>不过，服务器并不会处理查询的文本表示；所有操作都在解析树（parse tree）上完成。下图展示的是一个简化后的重写树（如果启用 debug_print_rewritten 参数，你可以在服务器日志中看到其完整版本）。</p>
<p>解析树只反映了查询的语法结构，但并不包含任何关于操作执行顺序的信息。</p>
<p>此外，PostgreSQL 还支持自定义转换，用户可以通过 rewrite rule（重写规则）系统来实现自己的查询重写逻辑。</p>
<p><img src="/images/QES/qes3.png" alt="qes3"></p>
<blockquote>
<p>规则系统（rule system）的支持曾被宣称为 Postgres 开发的主要目标之一；在最初实现规则系统时，Postgres 还只是一个学术项目，但之后规则系统已经多次被重新设计。规则系统非常强大，但也相当难以理解和调试。甚至有人提议直接把规则系统从 PostgreSQL 中移除，但这一想法并未得到一致认可。在大多数情况下，使用 触发器（trigger） 会比使用规则更加安全且容易。</p>
</blockquote>
<h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><p>SQL 是一种声明式语言：查询只说明要取什么数据，而不说明如何取。</p>
<p>任何查询都可以有多种执行路径。解析树中的每个操作都可能有多种完成方式：<br>例如，结果既可以通过全表扫描（读取整张表并过滤掉不需要的数据）得到，也可以通过索引扫描来找到所需行。数据集在连接时总是两两结合（pairwise joins），这意味着连接顺序存在大量组合，从而产生数量巨大的候选执行方案。此外，还有多种连接算法（join algorithms）：例如，执行器可以扫描第一个数据集的每一行，并在第二个数据集中查找匹配行；或者，先对两个数据集进行排序，再执行合并连接（merge join）。对每一种算法，都能找到其优于其他算法的使用场景。</p>
<p>最优计划与非最优计划的执行时间可能相差几个数量级，因此用于对解析后的查询进行优化的 计划器（planner） 是系统中最复杂的组件之一</p>
<p><strong>Plan tree</strong>  执行计划同样以树结构表示，但其节点处理的是物理数据操作，而不是逻辑操作。</p>
<p>如果你想查看完整的计划树，可以启用 debug_print_plan 参数，将计划树输出到服务器日志中。但在实际工作中，通常只需要查看 EXPLAIN 命令显示的文本形式的执行计划就足够了。</p>
<p>下图突出展示了执行计划树中的主要节点。正是这些节点会出现在下面 EXPLAIN 命令的输出中。</p>
<p>暂时我们先关注以下两点：</p>
<ul>
<li>这棵计划树中只包含了三个被查询表中的两个：规划器发现其中一个表对获取结果并非必需，于是将其从计划树中移除了。</li>
<li>对于计划树中的每个节点，规划器都会给出估算的成本（cost）以及预计要处理的行数（rows）。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br><span class="line">QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Sort (cost<span class="operator">=</span><span class="number">21.03</span>.<span class="number">.21</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">  Sort Key: c.relname</span><br><span class="line">  −<span class="operator">&gt;</span> Nested Loop <span class="keyword">Left</span> <span class="keyword">Join</span> (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.21</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">    <span class="keyword">Join</span> <span class="keyword">Filter</span>: (n.oid <span class="operator">=</span> c.relnamespace)</span><br><span class="line">    −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_class c (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.93</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">72</span>)</span><br><span class="line">        <span class="keyword">Filter</span>: ((relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="keyword">AND</span> (pg_g...</span><br><span class="line">    −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_namespace n (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> wid...</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>查询计划中的 Seq Scan 节点表示顺序扫描表数据，<br>而 Nested Loop 节点则表示连接（join）操作。</p>
<p><img src="/images/QES/qes4.png" alt="qes4"></p>
<p><strong>Plan search</strong> PostgreSQL 使用的是基于成本（cost-based）的优化器；它会遍历可能的执行计划，并估算执行这些计划所需的资源，例如 I&#x2F;O 操作或 CPU 周期。这种估算会被归一化为一个数值，称为该计划的 cost（成本）。在所有被考虑的计划中，优化器最终会选择 成本最低的那个计划。</p>
<p>问题在于：潜在可用的执行计划数量会随着参与连接的表数呈指数级增长，因此即使针对相对简单的查询，也不可能把所有计划都枚举一遍。通常，规划器会使用动态规划（dynamic programming）算法并结合一些启发式规则（heuristics）来缩小搜索范围。这种方法使规划器能够在可接受的时间内，为包含大量表的查询找到数学上最优的执行计划。</p>
<blockquote>
<p>准确的解决方案并不能保证所选计划确实是最佳计划，因为规划器使用简化的数学模型，可能缺乏可靠的输入数据</p>
</blockquote>
<p><strong>Managing the order of joins</strong> 查询可以通过某种结构方式来限制优化器的搜索范围（当然，这样做有可能错过最优执行计划）。</p>
<ul>
<li><p>公共表表达式（CTE） 和主查询可以被分别优化；如果你想强制这种行为，可以使用 MATERIALIZED 子句。</p>
</li>
<li><p>在非 SQL 函数内部运行的子查询 总是会被单独优化。（SQL 函数有时可能会被 inline 到主查询中。）</p>
</li>
<li><p>如果你设置了 join_collapse_limit 并在查询中使用显式的 JOIN 语法，那么部分连接顺序会被查询的语法结构所固定；类似地，from_collapse_limit 对子查询有相同的效果。</p>
</li>
</ul>
<p>最后一点可能需要解释一下。让我们来看一个示例：在 FROM 子句中列出表，但没有写任何显式 JOIN 的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b, c, d, e</span><br><span class="line"><span class="keyword">WHERE</span> ..</span><br></pre></td></tr></table></figure>

<p>在这种情况下，规划器必须考虑所有可能的连接（join）组合。该查询会由解析树中的如下部分来表示（示意性展示）。</p>
<p><img src="/images/QES/qes5.png" alt="qes5"></p>
<p>在下一个示例中，连接（join）的结构由 JOIN 子句 明确定义。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ..., d, e</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>解析树会反映出这种结构。</p>
<p><img src="/images/QES/qes6.png" alt="qes6"></p>
<p>规划器通常会将连接树（join tree）扁平化，使其看起来与第一个示例中的结构类似。该算法会递归遍历整棵树，并将每个 JOINEXPR 节点替换为其包含元素的扁平列表。</p>
<p>然而，只有当生成的扁平列表元素数量不超过 <em>join_collapse_limit</em> 时，这种合并操作才会执行。在这个特定的例子中，如果 <em>join_collapse_limit</em> 的值小于五，JOINEXPR 节点将不会被合并。</p>
<p>对于查询优化器而言，这意味着：</p>
<ul>
<li>表 B 必须与表 C 进行连接（或者反过来，C 必须与 B 连接；在这对表中的连接顺序没有限制）。 </li>
<li>表 A、D、E 以及 B 和 C 连接的结果可以按任意顺序进行连接。</li>
</ul>
<p>如果 <em>join_collapse_limit</em>  参数设置为 1，则显式 JOIN 子句中定义的顺序将被保留。</p>
<p>关于 <strong>FULL OUTER JOIN</strong> 的操作数，它们永远不会被合并（collapsed），无论 <em>join_collapse_limit</em>  参数的值是多少。  </p>
<p><em>from_collapse_limit</em> 参数以类似的方式控制子查询的扁平化。虽然子查询看起来不像 JOIN 子句，但在解析树（parse tree）层面上，这种相似性就很明显了</p>
<p>一个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line"><span class="keyword">FROM</span> a,</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> b, c <span class="keyword">WHERE</span> ...</span><br><span class="line">) bc,</span><br><span class="line">d, e </span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>
<p>对应的JOIN树如下所示。这里唯一的区别是，这棵树包含的是 <strong>FROMEXPR</strong> 节点，而不是 <strong>JOINEXPR</strong>（因此参数名如此命名）。</p>
<p><img src="/images/QES/qes7.png" alt="qes7"></p>
<p><strong>遗传查询优化（Genetic query optimization）</strong> 在将查询树扁平化之后，某一层可能包含过多的元素——无论是表还是中间连接结果，这些元素都需要单独进行优化。由于查询计划的生成时间会随着需要连接的数据集数量呈指数增长，因此plan时间可能会超出所有合理的范围。</p>
<p>如果启用了 <em>geqo</em> 参数，并且某一层的元素数量超过 <em>geqo_threshold</em> 的阈值，查询规划器将使用遗传算法来优化查询。相比动态规划，遗传算法的速度要快得多，但它无法保证找到的查询计划一定是最优的。因此，一条经验法则是通过减少需要优化的元素数量来避免使用遗传算法。</p>
<p>遗传算法有若干可配置参数，但在此不作详细介绍。</p>
<p><strong>选择最佳执行计划</strong> 查询计划是否可以被认为是最优的，取决于特定客户端如何使用查询结果。如果客户端需要一次性获取完整结果（例如，用于生成报表），那么计划应当优化所有行的检索效率。但如果优先考虑尽快返回前几行（例如，用于屏幕显示），那么最优计划可能完全不同。</p>
<p>为了做出这个选择，PostgreSQL 会计算成本的两个组成部分：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> schemaname, tablename <span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br><span class="line">                      QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------</span></span><br><span class="line">Sort (cost<span class="operator">=</span><span class="number">21.03</span>.<span class="number">.21</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">    Sort Key: c.relname</span><br><span class="line">    −<span class="operator">&gt;</span> Nested Loop <span class="keyword">Left</span> <span class="keyword">Join</span> (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.21</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">        <span class="keyword">Join</span> <span class="keyword">Filter</span>: (n.oid <span class="operator">=</span> c.relnamespace)</span><br><span class="line">        −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_class c (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.93</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">72</span>)</span><br><span class="line">            <span class="keyword">Filter</span>: ((relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="keyword">AND</span> (pg_g... </span><br><span class="line">        −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_namespace n (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> wid..</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>第一个组成部分（启动成本）表示节点执行前的准备开销；第二个组成部分（总成本）则包括获取查询结果过程中产生的所有开销。</p>
<blockquote>
<p>有时人们会说启动成本是获取结果集第一行的开销，但这种说法并不完全准确。</p>
</blockquote>
<p>为了挑选出首选执行计划，优化器会检查查询是否使用了游标（无论是通过 SQL 中的 DECLARE 命令，还是在 PL&#x2F;pgSQL 中显式声明（<em>explicitly</em>））。如果没有使用游标，则默认客户端需要一次性获取完整结果，优化器会选择总成本最小的计划。</p>
<p>如果查询是通过游标执行的，则所选计划必须优化仅获取所有行中 <em>cursor_tuple_fraction</em> 部分的效率。更准确地说，PostgreSQL 会选择使以下表达式值最小的计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup cost + cursor_tuple_fraction (total cost − startup cost)</span><br></pre></td></tr></table></figure>

<p>** 成本估算概述 ** 要估算一个计划的总成本，必须对计划中的所有节点进行成本估算。节点的成本取决于其类型（显而易见，读取堆表数据的成本与排序操作的成本不同）以及节点处理的数据量（数据量越大，通常成本越高）。虽然节点类型是已知的，但数据量只能根据输入集的预计基数（节点接收的行数）以及节点的选择性（输出中剩余行的比例）来预测。这些计算依赖于收集到的统计信息，例如表的大小以及表列中数据的分布情况。</p>
<p>如果对每个节点的基数估计准确，计算出的成本很可能能够较好地反映实际成本。规划中主要的缺陷通常源于基数和选择性的估计不准确，这可能由以下原因造成：</p>
<ol>
<li>统计信息不准确或过时；</li>
<li>无法使用统计信息；</li>
<li>（程度较轻）规划模型本身的不完善。</li>
</ol>
<p><strong>基数估计（Cardinality estimation）</strong>  要计算节点的基数，优化器必须递归地完成以下步骤：</p>
<ol>
<li>估算每个子节点的基数，并评估该节点将从子节点接收到的输入行数；</li>
<li>估算节点的选择性(Selectivity)，即输出中剩余的输入行所占的比例。</li>
</ol>
<p>节点的基数即这两个值的乘积。</p>
<blockquote>
<p>选择性(Selectivity)用一个介于 0 到 1 之间的数表示。数值越小，选择性越高；反之，数值接近 1 表示选择性较低。乍一看可能不太直观，其含义是：高选择性条件会筛掉几乎所有行，而只排除少量行的条件则选择性低。</p>
</blockquote>
<p>首先，优化器会估算定义数据访问方式的叶子节点的基数。这些计算依赖于收集到的统计信息，例如表的总大小。</p>
<p>过滤条件的选择性取决于条件的类型。在最简单的情况下，可以将其假设为一个常数值，尽管优化器会尽量利用所有可用信息来精确估算。通常，只需要掌握如何估算简单过滤条件即可；如果条件包含逻辑运算，其选择性则按照以下公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sel𝑥 𝑎𝑛𝒅 𝑦 = sel𝑥sel𝑦</span><br><span class="line">sel𝑥 𝑜𝒓 𝑦  = 1−(1−sel𝑥)(1−sel𝑦) = sel𝑥+sel𝑦−sel𝑥sel𝑦</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sel_X：满足条件 X 的行比例  sel_Y：满足条件 Y 的行比例 条件 X AND Y：满足两个条件的行，概率就是两者独立事件概率的乘积;  (1 - sel_X)：不满足 X 的行比例, (1 - sel_Y)：不满足 Y 的行比例, (1 - sel_X)(1 - sel_Y)：同时不满足 X 和 Y 的行比例.所以 1 − (1 − sel_X)(1 − sel_Y) &#x3D; 满足 X 或 Y 的行比例</p>
</blockquote>
<p>不幸的是，上述公式假设谓词 X 和 Y 彼此独立。对于相关（correlated）的谓词，这类估算将不准确。</p>
<p>要估算 连接（join）的基数，优化器必须首先计算笛卡尔积的基数（即两个数据集基数的乘积），然后估算连接条件的选择性，这仍然取决于条件类型。</p>
<p>其他节点（如排序或聚合）的基数估算方式也类似。</p>
<p>需要注意的是：下层节点基数估算不准确，会影响后续所有计算，导致总成本估算不准确，从而选择了不理想的执行计划。更糟糕的是，优化器没有关于连接结果的统计信息，只能依赖表的统计信息。</p>
<p><strong>成本估算</strong> 成本估算的过程同样是递归的。要计算一个子树的成本，需要先计算并累加其所有子节点的成本，然后再加上父节点自身的成本。</p>
<p>在估算节点成本时，PostgreSQL 会根据该节点执行的操作建立数学模型，并以已经估算好的节点基数作为输入。对于每个节点，都会计算 启动成本 和 总成本。</p>
<p>某些操作没有前置条件，因此可以立即执行，这类节点的启动成本为零。</p>
<p>而另一类操作则必须等待一些前置操作完成后才能执行。例如，排序节点通常需要等待其子节点返回所有数据后，才能进行自己的任务。这类节点的启动成本通常大于零：即使上层节点（或客户端）只需要输出中的一行，也必须支付这一成本。</p>
<p>优化器进行的所有计算都是估算值，可能与实际执行时间无关。它们的唯一目的，是在相同条件下对同一查询的不同执行计划进行比较。在其他情况下（尤其是不同查询之间），用成本来比较意义不大。例如，由于统计信息过时，成本可能被低估；在统计信息刷新后，计算出的成本可能上升，但由于估算更准确，服务器会选择更优的执行计划。</p>
<h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><p>在查询优化阶段生成的执行计划现在必须被执行。</p>
<p>执行器（executor）会在后端内存中打开一个 portal，这是一个保存当前正在执行查询状态的对象。这个状态以一棵树的形式表示，结构与执行计划树相同。树中的各节点像流水线一样运作，彼此请求并传递行数据。</p>
<p><img src="/images/QES/qes8.png" alt="qes8"></p>
<p>查询执行从根节点开始。以本例为例，根节点表示 排序（SORT）操作，它从子节点获取数据。在接收到所有行之后，根节点对数据进行排序，并将结果传递给客户端。</p>
<p>某些节点（如图示中的 NESTLOOP 节点）负责将来自不同来源的数据集进行连接。此类节点会从两个子节点拉取数据，并在收到满足连接条件的行对后立即向上层传递结果行（与排序不同，排序必须先获取所有行）。此时，节点的执行会暂停，直到其父节点请求下一行。如果查询只需要部分结果（例如包含 LIMIT 子句），该操作不会执行完整。</p>
<p>树中的两个 SEQSCAN 叶子节点负责表扫描。当父节点请求数据时，这些节点会从对应的表中获取下一行数据。</p>
<p>因此，一些节点不存储任何行，而是立即向上层传递数据；而其他节点（如 SORT）可能需要保留大量数据。为此，后端内存中会为其分配一个 work_mem 内存块；如果内存不足，多余的数据会溢写到磁盘上的临时文件。</p>
<p>一个执行计划可能包含多个需要数据存储的节点，因此 PostgreSQL 可能会分配多个 work_mem 大小的内存块。查询可使用的总 RAM 大小没有任何限制。</p>
<h2 id="翻译来之"><a href="#翻译来之" class="headerlink" title="翻译来之"></a>翻译来之</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
  </entry>
  <entry>
    <title>RD-Trees for Full-Text Search</title>
    <url>/2025/12/06/postgresql/RD-Trees-for-Full-Text-Search/</url>
    <content><![CDATA[<h2 id="关于全文搜索"><a href="#关于全文搜索" class="headerlink" title="关于全文搜索"></a>关于全文搜索</h2><p>全文搜索的目标是从提供的文档集中选择与搜索查询匹配的文档</p>
<p>为了进行搜索，文档会被转换为 tsvector 类型，该类型包含文档中的词素（lexemes）及其在文档中的位置。词素是将单词转换为适合搜索的格式。默认情况下，所有单词都会被标准化为小写，并去除其词尾。</p>
<blockquote>
<p>“并去除其词尾”指的是在全文搜索中，对单词进行词干提取（stemming）或词形归一化（normalization）的过程。具体来说，这是将单词的词尾（如英语中的复数、时态、词性变化等）去除，提取出单词的词干（stem）或基本形式，以便在搜索时能够匹配同一词根的不同变体。例如：单词“running”、“ran”和“runs”都源自同一词根“run”。在全文搜索的处理中，这些单词可能会被归一化为“run”，即去除词尾变化，保留词干。搜索“run”时，系统不仅会匹配“run”，还会匹配“running”、“ran”和“runs”等形式，因为它们都被归一化为相同的词干“run”。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SET</span> default_text_search_config <span class="operator">=</span> english;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(</span><br><span class="line">    <span class="string">&#x27;No one can tell me, nobody knows, &#x27;</span> <span class="operator">||</span></span><br><span class="line">    <span class="string">&#x27;Where the wind comes from, where the wind goes.&#x27;</span></span><br><span class="line">);</span><br><span class="line">                             to_tsvector                              </span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line"> <span class="string">&#x27;come&#x27;</span>:<span class="number">11</span> <span class="string">&#x27;goe&#x27;</span>:<span class="number">16</span> <span class="string">&#x27;know&#x27;</span>:<span class="number">7</span> <span class="string">&#x27;nobodi&#x27;</span>:<span class="number">6</span> <span class="string">&#x27;one&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;tell&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;wind&#x27;</span>:<span class="number">10</span>,<span class="number">15</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>所谓的停用词（如“the”或“from”）会被过滤掉：这些词被认为出现频率过高，搜索它们无法返回有意义的搜索结果。当然，所有这些转换都是可以配置的。</p>
<p>查询由另一种类型表示：tsquery。任何查询都包含一个或多个通过逻辑连接符连接的词素：&amp;（与）、|（或）、!（非）。你还可以使用括号来定义操作符的优先级。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsquery(<span class="string">&#x27;wind &amp; (comes | goes)&#x27;</span>);</span><br><span class="line">         to_tsquery          </span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"> <span class="string">&#x27;wind&#x27;</span> <span class="operator">&amp;</span> ( <span class="string">&#x27;come&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;goe&#x27;</span> )</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>全文搜索中唯一使用的操作符是匹配操作符 @@：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, oprcode::regproc, amopstrategy <span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid <span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily <span class="keyword">JOIN</span> pg_operator opr <span class="keyword">ON</span> opr.oid <span class="operator">=</span> amopopr</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;tsvector_ops&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">       amopopr        <span class="operator">|</span>   oprcode   <span class="operator">|</span> amopstrategy </span><br><span class="line"><span class="comment">----------------------+-------------+--------------</span></span><br><span class="line"> @@(tsvector,tsquery) <span class="operator">|</span> ts_match_vq <span class="operator">|</span>            <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>该操作符判断文档是否满足查询条件。以下是一个示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;Where the wind comes from, where the wind goes&#x27;</span>) @@ to_tsquery(<span class="string">&#x27;wind &amp; coming&#x27;</span>);</span><br><span class="line"> ?<span class="keyword">column</span>? </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>这绝不是对全文搜索的详尽描述，但这些信息应足以理解索引的基础知识。</p>
<h2 id="Indexing-tsvector-Data"><a href="#Indexing-tsvector-Data" class="headerlink" title="Indexing tsvector Data"></a>Indexing tsvector Data</h2><p>为了实现快速的全文搜索，必须使用索引来支持。索引的对象不是文档本身，而是 tsvector 值。这里有两种选择：一种是在表达式上构建索引并进行类型转换，另一种是添加一个单独的 tsvector 类型列并对该列进行索引。第一种方法的优点是不会浪费空间来存储 tsvector 值，因为这些值实际上并不需要直接存储。但这种方法比第二种方法慢，因为索引引擎需要重新检查访问方法返回的所有堆元组。这意味着对于每个重新检查的行，都需要再次计算 tsvector 值，而且正如我们很快会看到的，GiST 索引会重新检查所有行。</p>
<p>让我们构建一个简单的示例。我们将创建一个包含两列的表：第一列存储文档，第二列存储 tsvector 值。我们可以使用触发器来更新第二列，但更方便的做法是直接将该列声明为生成列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> ts(</span><br><span class="line">    doc text,</span><br><span class="line">    doc_tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> (</span><br><span class="line">         to_tsvector(<span class="string">&#x27;pg_catalog.english&#x27;</span>, doc) </span><br><span class="line">    ) STORED</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX ts_gist_idx <span class="keyword">ON</span> ts</span><br><span class="line"><span class="keyword">USING</span> gist(doc_tsv);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的例子中，我使用了带有单一参数的 to_tsvector 函数，通过设置 default_text_search_config 参数来定义全文搜索配置。这种函数变体的波动性（volatility）类别是 STABLE，因为它隐式依赖于参数值。但在这里，我使用了另一种变体，显式指定配置；这种变体是 IMMUTABLE，可以用于生成表达式。</p>
</blockquote>
<p>我们插入几行数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> ts(doc) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some cows&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a moo, there a moo&#x27;</span>), (<span class="string">&#x27;Everywhere a moo moo&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some chicks&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a cluck, there a cluck&#x27;</span>), (<span class="string">&#x27;Everywhere a cluck cluck&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>),(<span class="string">&#x27;And on his farm he had some pigs&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here an oink, there an oink&#x27;</span>),(<span class="string">&#x27;Everywhere an oink oink&#x27;</span>)</span><br><span class="line">RETURNING doc_tsv;</span><br><span class="line">            doc_tsv             </span><br><span class="line"><span class="comment">--------------------------------</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;cow&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;chick&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">4</span> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;pig&#x27;</span>:<span class="number">8</span></span><br><span class="line"> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">(<span class="number">12</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>因此，R 树不适合用于索引文档，因为边界框（bounding box）的概念对文档没有意义。因此，使用了其 RD 树（俄罗斯套娃，Russian Doll）变体。RD 树不使用边界框，而是使用边界集（bounding set），即一个包含其所有子集元素的集合。对于全文搜索，这样的集合包含文档的词素（lexemes），但在一般情况下，边界集可以是任意的。</p>
<p>在索引条目中表示边界集有几种方法。最简单的一种是列举集合中的所有元素。如下图所示</p>
<p><img src="/images/RDTree/rdtree1.png" alt="rdtree1"></p>
<p>为了找到满足 DOC_TSV @@ TO_TSQUERY(‘COW’) 条件的文档，我们需要深入到那些已知包含“cow”词素的子节点的节点。</p>
<p><img src="/images/RDTree/rdtree2.png" alt="rdtree2"></p>
<p>这种表示方式的问题显而易见。文档中的词素数量可能非常庞大，而页面大小是有限的。即使单个文档的独特词素数量不算太多，在树的较高层级中，它们的联合集仍然可能变得过大。</p>
<p>全文搜索使用了另一种解决方案，即更紧凑的签名树（signature tree）。对于那些熟悉布隆过滤器（Bloom filter）的人来说，这种解决方案应该很熟悉。 </p>
<p>每个词素可以由其签名（signature）表示：一个特定长度的位字符串，其中只有一位被置为 1。置为 1 的位由词素的哈希函数决定。 </p>
<p>文档的签名是对该文档中所有词素签名的按位或（bitwise OR）操作结果。</p>
<p><img src="/images/RDTree/rdtree3.png" alt="rdtree3"></p>
<p>这种方法的优点显而易见：索引条目大小相同且相当小，因此索引非常紧凑。但也存在一些缺点。首先，无法执行仅索引扫描（index-only scan），因为索引不再存储索引键，每个返回的 TID（行标识）都必须通过表进行重新检查。此外，准确性也会受到影响：索引可能返回许多误报（false positives），这些误报需要在重新检查阶段过滤掉。</p>
<p><img src="/images/RDTree/rdtree4.png" alt="rdtree4"></p>
<p>让我们再次看看 DOC_TSV @@ TO_TSQUERY(‘COW’) 条件。查询的签名（signature）以与文档相同的方式计算；在这个特定情况下，其签名等于 0000010。一致性函数（consistency function）必须找到所有签名中具有相同位被置位的子节点。</p>
<p><img src="/images/RDTree/rdtree5.png" alt="rdtree5"></p>
<p>与前面的例子相比，这里需要扫描更多的节点，因为存在误报（false-positive）命中。由于签名的容量有限，在大型集合中，某些词素必然会具有相同的签名。在这个例子中，这样的词素是“cow”和“oink”。这意味着一个签名可能匹配多个不同的文档；在这里，查询的签名对应于三个文档。</p>
<p>误报会降低索引的效率，但不会以任何方式影响其正确性：因为假阴性（false negatives）被保证排除，所以不会遗漏所需的值。</p>
<p>显然，签名的实际大小要大得多。默认情况下，签名占用 123 字节（992 位），因此冲突的概率远低于本例中所示。如果需要，可以使用操作符类参数进一步将签名大小增加到大约 2000 字节。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ... <span class="keyword">USING</span> gist(<span class="keyword">column</span> tsvector_ops(siglen <span class="operator">=</span> <span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<p>此外，如果值足够小（略小于页面大小的 1&#x2F;16，对于标准页面大约是 500 字节），tsvector_ops 操作符类会在索引的叶子页面中存储 tsvector 值本身，而不是它们的签名。</p>
<p>为了了解索引在真实数据上的工作方式，我们可以使用 pgsql-hackers 邮件列表存档。该存档包含 356,125 封电子邮件，包括发送日期、主题、作者姓名和正文文本。让我们添加一个 tsvector 类型的列并构建索引。在这里，我将三个值（主题、作者和正文文本）组合成一个单一的向量，以展示文档可以动态生成，而不必存储在单一列中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> mail_messages <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> ( to_tsvector(</span><br><span class="line"><span class="string">&#x27;pg_catalog.english&#x27;</span>, subject<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>author<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>body_plain ) ) STORED;</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored.</span><br><span class="line">...</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored. </span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mail_gist_idx <span class="keyword">ON</span> mail_messages <span class="keyword">USING</span> gist(tsv);</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_gist_idx&#x27;</span>));</span><br><span class="line">pg_size_pretty </span><br><span class="line">−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">127</span> MB </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>在填充该列（tsv）的过程中，一些特别长的词因为长度太大被过滤掉了。但一旦索引构建完成，就可以用于搜索查询了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">27575</span> read<span class="operator">=</span><span class="number">31875</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">75</span> read<span class="operator">=</span><span class="number">4</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>除了满足条件的 898 行之外，访问方法还返回了另外 7852 行，这些行需要后续通过回检（recheck）来过滤。如果我们增加签名容量（signature capacity），准确性（也就是索引效率）会提高，但索引的大小也会随之增加。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">DROP</span> INDEX mail_messages_tsv_idx;</span><br><span class="line"><span class="keyword">DROP</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> mail_messages</span><br><span class="line"><span class="keyword">USING</span> gist(tsv tsvector_ops(siglen<span class="operator">=</span><span class="number">1024</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>));</span><br><span class="line"> pg_size_pretty </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">241</span> MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">25968</span> read<span class="operator">=</span><span class="number">33482</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">3</span> read<span class="operator">=</span><span class="number">2</span> dirtied<span class="operator">=</span><span class="number">1</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>我已经展示了访问方法的属性，其中大多数在所有操作符类中都是相同的。但是下面两个列级别的属性值得一提：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> f</span><br><span class="line"> distance_orderable <span class="operator">|</span> f</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>现在不可能进行 Index-only 扫描了，因为无法从签名中恢复出原始值。<br>不过在这个特定的场景下这是完全可以接受的：<br>tsvector 值只是用于搜索，我们真正需要的是文档本身（也就是实际的数据行）。<br>对于 tsvector_ops 类来说，也没有定义排序操作符</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>Recovery in postgres</title>
    <url>/2025/10/24/postgresql/Recovery/</url>
    <content><![CDATA[<p>服务器启动时，第一个启动的进程是 postmaster（新版本为postgres）。postmaster 接着会生成 startup process（启动进程），startup process 负责在发生故障时进行数据恢复。</p>
<blockquote>
<p>startup process 是一个短暂的、一次性的进程，它的主要职责是在数据库启动时执行崩溃恢复或归档恢复。它完成它的工作后，就会退出。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:/root$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               in production</span><br><span class="line">postgres@lavm-bar1guved6:/root$ </span><br></pre></td></tr></table></figure>
<p>一个正常停止的服务器会处于“已关闭”（shut down）状态；而一个未运行的服务器却显示为“生产中”（in production）状态，则表明发生了故障。在这种情况下，启动进程（startup process）将自动从在同一个 pg_control 文件中找到的最新完成的检查点（checkpoint）**的起始 LSN 处开始进行恢复。</p>
<blockquote>
<p>如果 PGDATA 目录中包含与备份相关的 backup_label 文件，则起始 LSN 位置会从该文件中获取。</p>
</blockquote>
<p>在启动过程中，系统会从指定位置开始，逐一读取WAL（Write-Ahead Log，预写式日志）条目。如果数据页的 LSN（Log Sequence Number，日志序列号）小于当前读取到的 WAL 条目的 LSN，系统会将该 WAL 条目应用到数据页上。如果数据页的 LSN 已经大于 WAL 条目的 LSN，则不应应用该 WAL 条目；事实上，也绝不能应用，因为 WAL 条目被设计为必须严格按顺序重放。</p>
<p>然而，有些 WAL 条目是Full Page Image（FPI）。这类条目可以应用于页面的任何状态，因为它们会完全覆盖页面内容，无论页面原先是什么状态都不重要。因此，这种修改是幂等的（idempotent）——多次应用不会改变结果另一个幂等操作的例子是注册事务状态的变更：每个事务的状态在 CLOG（事务提交日志）中是通过设置特定位来表示的，这种设置不依赖于原来的位值。因此，不需要在 CLOG 页面中记录最近变更的 LSN（日志序列号），因为日志重放时只要设置一次这些位就够了，重复设置也不会有副作用最后，系统会执行一次 checkpoint（检查点），将恢复后的所有修改持久化到磁盘，此时 启动进程（startup process） 的任务就完成了。</p>
<p>WAL 日志条目会被应用到缓冲池（buffer cache）中的页面上，就像正常运行时对数据页的普通修改一样。</p>
<p>文件的恢复也遵循类似方式：例如，若某条 WAL 记录表明某个文件应该存在，但实际却缺失，系统就会重新创建这个文件。<br>一旦恢复完成，所有 unlogged relations会被它们对应的 初始化副本（init fork） 覆盖。</p>
<p>最后，系统会执行一次 checkpoint，将恢复后的所有修改持久化到磁盘，此时 启动进程（startup process） 的任务就完成了<br>在其经典形式中，恢复过程包含两个阶段：</p>
<ul>
<li>roll-forward阶段：重放 WAL 日志，重复执行在崩溃时丢失的操作；</li>
<li>roll-back阶段：服务器中止那些在故障发生时尚未提交的事务。<br>在 PostgreSQL 中，向后回滚是不需要的。恢复完成后，CLOG（事务状态日志）中对未完成事务既没有提交（commit）标记，也没有中止（abort）标记（这在技术上表示该事务处于活动状态），但因为可以确定该事务已经不再运行，所以系统会将其视为已中止（aborted）。</li>
</ul>
<p>我们可以通过强制服务器以“立即模式”（immediate mode）停止来模拟故障：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:/root$ pg_ctl stop -m immediate</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br><span class="line">postgres@lavm-bar1guved6:/root$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               in production</span><br></pre></td></tr></table></figure>
<p>当我们启动服务器时，启动进程会检测到之前发生了故障，因而进入恢复模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2025-08-04 10:23:31.860 CST [487414] LOG:  starting PostgreSQL 19devel on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, 64-bit</span><br><span class="line">2025-08-04 10:23:31.861 CST [487414] LOG:  listening on IPv4 address &quot;127.0.0.1&quot;, port 5432</span><br><span class="line">2025-08-04 10:23:31.878 CST [487414] LOG:  listening on Unix socket &quot;/tmp/.s.PGSQL.5432&quot;</span><br><span class="line">2025-08-04 10:23:31.920 CST [487420] LOG:  database system was interrupted; last known up at 2025-08-01 09:36:11 CST</span><br><span class="line">2025-08-04 10:23:32.098 CST [487420] LOG:  database system was not properly shut down; automatic recovery in progress</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  redo starts at 0/01B75168</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  invalid record length at 0/01B752A8: expected at least 24, got 0</span><br><span class="line">2025-08-04 10:23:32.125 CST [487420] LOG:  redo done at 0/01B75270 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s</span><br><span class="line">2025-08-04 10:23:32.132 CST [487418] LOG:  checkpoint starting: end-of-recovery fast wait</span><br><span class="line">2025-08-04 10:23:32.152 CST [487418] LOG:  checkpoint complete: wrote 0 buffers (0.0%), wrote 3 SLRU buffers; 0 WAL file(s) added, 0 removed, 0 recycled; write=0.006 s, sync=0.005 s, total=0.022 s; sync files=2, longest=0.005 s, average=0.003 s; distance=0 kB, estimate=0 kB; lsn=0/01B752A8, redo lsn=0/01B752A8</span><br><span class="line">2025-08-04 10:23:32.155 CST [487414] LOG:  database system is ready to accept connections</span><br></pre></td></tr></table></figure>
<p>如果服务器正在正常关闭，postmaster 会先断开所有客户端连接，然后执行最后一次检查点操作，将所有脏页（未写入磁盘的修改页面）刷写到磁盘上。</p>
<p>看当前的WAL位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=# SELECT pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line">---------------------------</span><br><span class="line"> 0/01B75358</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<p>我们正常停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_ctl stop</span><br><span class="line">waiting for server to shut down.... done</span><br><span class="line">server stopped</span><br></pre></td></tr></table></figure>
<p>现在的数据库状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_controldata -D /home/postgres/pgdata/ |grep state</span><br><span class="line">Database cluster state:               shut down</span><br></pre></td></tr></table></figure>
<p>在WAL的末尾，我们看到了表示最后一次checkpoint的CHECKPOINT_SHUTDOWN 条目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres@lavm-bar1guved6:~$ pg_waldump  -p /home/postgres/pgdata/pg_wal -s 0/01B75358</span><br><span class="line">rmgr: XLOG        len (rec/tot):    114/   114, tx:          0, lsn: 0/01B75358, prev 0/01B75320, desc: CHECKPOINT_SHUTDOWN redo 0/01B75358; tli 1; prev tli 1; fpw true; wal_level replica; xid 0:758; oid 24576; multi 1; offset 0; oldest xid 746 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</span><br><span class="line">pg_waldump: error: error in WAL record at 0/01B75358: invalid record length at 0/01B753D0: expected at least 24, got 0</span><br><span class="line">postgres@lavm-bar1guved6:~$ </span><br></pre></td></tr></table></figure>
<p>最新的 pg_waldump 消息显示该工具已读取 WAL到末尾。</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL MODES</title>
    <url>/2025/11/01/postgresql/WAL-MODES/</url>
    <content><![CDATA[<p>当数据库服务正常运行时，wal文件持续不断的写入磁盘。这种写入时顺序的（sequential）：几乎没有随机访问，所以即便时hdd硬盘也能处理这样的任务。由于这种负载和典型的数据文件访问非常不一样，值得为WAL文件设置单独的物理存储，并通过符号链接替换PGDATA&#x2F;PG_WAL目录，该目录链接到mount的文件系统中的目录。</p>
<blockquote>
<p>在某些情况下，需要同时写和读取WAL文件。第一种情况是崩溃恢复。第二个是流复制。 Walsender流程直接从文件中读取WALENTRIES。因此，如果必需的页面仍位于主服务器的OS缓冲区中（不在shared_buffer中），replica未接收WAL条目，则必须从磁盘中读取数据。但是访问仍然是顺序而不是随机的。</p>
</blockquote>
<p>wal日志条目写入有以下两种模式：</p>
<ul>
<li><strong>同步模式</strong>：在事务提交之前，必须把所有相关的 WAL 记录写入磁盘，否则不允许继续执行后续操作。</li>
<li><strong>异步模式</strong>：事务提交会立刻返回成功，相关的 WAL 记录则由后台进程稍后再写入磁盘。</li>
</ul>
<p>当前使用的模式由参数：synchronous_commit 确定</p>
<p><strong>同步模式</strong>：为了可靠地记录一次提交，仅仅将WAL条目传递给操作系统是不够的；你必须确保磁盘同步已经成功完成。由于同步涉及实际的I&#x2F;O操作（这相当慢），因此最好尽可能少地执行它。</p>
<p>为此，完成事务并将WAL条目写入磁盘的后端可以进行一次小的暂停，该暂停由commit_delay参数定义。但是，只有当系统中至少有commit_siblings个活跃事务时，这种情况才会发生：在这次暂停期间，其中一些事务可能会完成，而服务器将设法一次性同步所有WAL条目。这很像为某人赶进来而按住电梯门。</p>
<p>默认情况下，没有暂停。仅针对执行大量短时OLTP事务的数据库系统修改commit_delay参数是有意义的。</p>
<p>在可能出现的暂停之后，完成事务的进程会将所有累积的 WAL 条目刷新到磁盘并执行同步操作（关键是要保存提交记录以及与该事务相关的所有前置记录；至于其他记录，则只是顺便写入，因为它们不会增加额外开销）。</p>
<p>从这一刻起，ACID 的持久性要求便得到保证——事务被认为已经可靠提交。这就是为什么默认使用同步模式的原因。</p>
<p>同步提交的缺点在于延迟更长（在同步完成之前，COMMIT 命令不会返回控制权），并且系统吞吐量较低，尤其对于 OLTP loads。</p>
<p><strong>异步模式</strong>：要启用异步模式，必须关闭 synchronous_commit 参数。<br>在异步模式下，WAL 条目由 walwriter 进程写入磁盘，该进程在“工作—休眠”之间交替运行。休眠时长由 wal_writer_delay 参数决定（默认 200ms）。</p>
<p>当 walwriter 从休眠中唤醒时，它会检查缓存中是否存在新的、已经完全填满的 WAL 页面。如果存在，就将这些页面写入磁盘，同时跳过当前未写满的页面；否则，它会写入当前半空的页面，因为既然已经被唤醒了。</p>
<p>这种算法的目的在于避免同一个页面被多次刷盘，这在数据变更频繁的负载下能带来显著的性能提升。</p>
<p>虽然 WAL 缓存采用环形缓冲区（ring buffer）的形式，但 walwriter 在到达缓存的最后一页时会停止；在经过一次休眠后，下一轮写入循环会从缓存的第一页重新开始。因此，在最坏的情况下，walwriter 可能需要 三次循环才能处理某个特定的 WAL 记录：</p>
<p>第一次，它会写出缓存尾部的所有已填满页面；（当前位置之后的所有满块）<br>第二次，它回到开头；（当前位置之前的所有满块）<br>第三次，才会处理包含目标记录的那个未填满页面。<br>不过，在大多数情况下，只需要 一到两次循环 就能完成。</p>
<p>每当写入的数据量达到 wal_writer_flush_after 时，就会执行一次同步操作；在写入循环结束时，也会再次进行同步。</p>
<p>与同步提交相比，异步提交更快，因为它不需要等待物理写入磁盘完成。但可靠性有所下降：在发生故障前的 3 × wal_writer_delay 时间内提交的数据可能会丢失（默认值为 0.6 秒）</p>
<p>在实际应用中，这两种模式是互补的。</p>
<ul>
<li>在 <strong>同步模式</strong> 下，与长事务相关的 WAL 条目仍然可以 异步写入，以释放 WAL 缓冲区。</li>
<li>反之，即使在 <strong>异步模式</strong> 下，如果某个 WAL 条目所在的页即将被 从缓冲区淘汰，该条目也会被 立即刷盘，否则系统无法继续正常操作。<br>在大多数情况下，系统设计者必须在 性能和持久性之间做出权衡。</li>
</ul>
<p>synchronous_commit 参数也可以针对特定事务进行设置。如果能够在应用层将所有事务分类为 绝对关键（如处理财务数据）或 非关键，就可以在只冒非关键事务丢失风险的前提下，提升整体性能</p>
<p>为了了解 异步提交 可能带来的性能提升，我们可以通过 pgbench 测试，比较两种模式下的 延迟（latency）和吞吐量（throughput）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ pgbench <span class="operator">-</span>i test</span><br><span class="line">dropping <span class="keyword">old</span> tables...</span><br><span class="line">NOTICE:  <span class="keyword">table</span> &quot;pgbench_accounts&quot; does <span class="keyword">not</span> exist, skipping</span><br><span class="line">NOTICE:  <span class="keyword">table</span> &quot;pgbench_branches&quot; does <span class="keyword">not</span> exist, skipping</span><br><span class="line">NOTICE:  <span class="keyword">table</span> &quot;pgbench_history&quot; does <span class="keyword">not</span> exist, skipping</span><br><span class="line">NOTICE:  <span class="keyword">table</span> &quot;pgbench_tellers&quot; does <span class="keyword">not</span> exist, skipping</span><br><span class="line">creating tables...</span><br><span class="line">generating data (client<span class="operator">-</span>side)...</span><br><span class="line">vacuuming...                                                                              </span><br><span class="line">creating <span class="keyword">primary</span> keys...</span><br><span class="line">done <span class="keyword">in</span> <span class="number">1.54</span> s (<span class="keyword">drop</span> tables <span class="number">0.11</span> s, <span class="keyword">create</span> tables <span class="number">0.49</span> s, client<span class="operator">-</span>side generate <span class="number">0.54</span> s, vacuum <span class="number">0.18</span> s, <span class="keyword">primary</span> keys <span class="number">0.23</span> s).</span><br><span class="line"> </span><br><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ pgbench <span class="operator">-</span>T <span class="number">30</span> test</span><br><span class="line">pgbench (<span class="number">19</span>devel)</span><br><span class="line">starting vacuum...end.</span><br><span class="line">transaction type: <span class="operator">&lt;</span>builtin: TPC<span class="operator">-</span>B (sort <span class="keyword">of</span>)<span class="operator">&gt;</span></span><br><span class="line">scaling factor: <span class="number">1</span></span><br><span class="line">query mode: simple</span><br><span class="line">number <span class="keyword">of</span> clients: <span class="number">1</span></span><br><span class="line">number <span class="keyword">of</span> threads: <span class="number">1</span></span><br><span class="line">maximum number <span class="keyword">of</span> tries: <span class="number">1</span></span><br><span class="line">duration: <span class="number">30</span> s</span><br><span class="line">number <span class="keyword">of</span> transactions actually processed: <span class="number">3522</span></span><br><span class="line">number <span class="keyword">of</span> failed transactions: <span class="number">0</span> (<span class="number">0.000</span><span class="operator">%</span>)</span><br><span class="line">latency average <span class="operator">=</span> <span class="operator">&lt;</span>strong<span class="operator">&gt;</span><span class="number">8.518</span><span class="operator">&lt;</span><span class="operator">/</span>strong<span class="operator">&gt;</span> ms</span><br><span class="line"><span class="keyword">initial</span> connection <span class="type">time</span> <span class="operator">=</span> <span class="number">4.025</span> ms</span><br><span class="line">tps <span class="operator">=</span> <span class="operator">&lt;</span>strong<span class="operator">&gt;</span><span class="number">117.400485</span><span class="operator">&lt;</span><span class="operator">/</span>strong<span class="operator">&gt;</span> (<span class="keyword">without</span> <span class="keyword">initial</span> connection <span class="type">time</span>)</span><br></pre></td></tr></table></figure>
<p>修改参数后跑异步模式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ psql test</span><br><span class="line">psql (<span class="number">19</span>devel)</span><br><span class="line">Type &quot;help&quot; <span class="keyword">for</span> help.</span><br><span class="line"> </span><br><span class="line">test<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> synchronous_commit <span class="operator">=</span> off;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> pg_reload_conf();</span><br><span class="line"> pg_reload_conf </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"> </span><br><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ pgbench <span class="operator">-</span>T <span class="number">30</span> test</span><br><span class="line">pgbench (<span class="number">19</span>devel)</span><br><span class="line">starting vacuum...end.</span><br><span class="line">transaction type: <span class="operator">&lt;</span>builtin: TPC<span class="operator">-</span>B (sort <span class="keyword">of</span>)<span class="operator">&gt;</span></span><br><span class="line">scaling factor: <span class="number">1</span></span><br><span class="line">query mode: simple</span><br><span class="line">number <span class="keyword">of</span> clients: <span class="number">1</span></span><br><span class="line">number <span class="keyword">of</span> threads: <span class="number">1</span></span><br><span class="line">maximum number <span class="keyword">of</span> tries: <span class="number">1</span></span><br><span class="line">duration: <span class="number">30</span> s</span><br><span class="line">number <span class="keyword">of</span> transactions actually processed: <span class="number">9510</span></span><br><span class="line">number <span class="keyword">of</span> failed transactions: <span class="number">0</span> (<span class="number">0.000</span><span class="operator">%</span>)</span><br><span class="line">latency average <span class="operator">=</span> <span class="operator">&lt;</span>strong<span class="operator">&gt;</span><span class="number">3.154</span><span class="operator">&lt;</span><span class="operator">/</span>strong<span class="operator">&gt;</span> ms</span><br><span class="line"><span class="keyword">initial</span> connection <span class="type">time</span> <span class="operator">=</span> <span class="number">4.383</span> ms</span><br><span class="line">tps <span class="operator">=</span> <span class="operator">&lt;</span>strong<span class="operator">&gt;</span><span class="number">317.038330</span><span class="operator">&lt;</span><span class="operator">/</span>strong<span class="operator">&gt;</span> (<span class="keyword">without</span> <span class="keyword">initial</span> connection <span class="type">time</span>)</span><br></pre></td></tr></table></figure>
<p>在 <strong>异步模式</strong> 下，这个简单的基准测试显示出 显著更低的延迟（latency）和更高的吞吐量（tps）。当然，每个具体系统的数值会根据当前负载有所不同，但可以清楚地看出，对于 短事务，性能提升是相当明显的。</p>
<p>恢复参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ psql test</span><br><span class="line">psql (<span class="number">19</span>devel)</span><br><span class="line">Type &quot;help&quot; <span class="keyword">for</span> help.</span><br><span class="line"> </span><br><span class="line">test<span class="operator">=</span># <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> RESET synchronous_commit;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> pg_reload_conf();</span><br><span class="line"> pg_reload_conf </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL Structure(Logical-Structure)</title>
    <url>/2025/07/30/postgresql/WAL-Structure-Logical-Structure/</url>
    <content><![CDATA[<p>从wal逻辑结构来看，WAL 可被描述为变长日志条目流。每个条目都包含有关特定操作的一些数据，并以标准标头作为前缀。该标头提供的信息包括但不限于：</p>
<ul>
<li>与条目（entry）相关的事务 ID </li>
<li>解释条目的资源管理器</li>
<li>用于检测数据损坏的校验和</li>
<li>条目长度</li>
<li>对前一个 WAL 条目的引用<blockquote>
<p>WAL 通常是按正向读取的，但某些工具（例如 pg_rewind）可能会反向扫描它</p>
</blockquote>
</li>
</ul>
<p>WAL 数据本身可以具有不同的格式和含义。例如，它可能是一段页片段（page fragment），需要替换某个页面中指定偏移处的一部分内容。相应的资源管理器（resource manager）必须知道如何解析并重放这一特定条目。针对表、各种索引类型、事务状态以及其他实体，PostgreSQL 都有独立的资源管理器来处理它们各自的 WAL。</p>
<p>WAL 文件会占用服务器共享内存中的特殊缓冲区。用于 WAL 的缓存大小由参数 wal_buffers 决定。默认情况下，这个大小会自动设为总缓冲区缓存（buffer cache）大小的 1&#x2F;32。</p>
<p>WAL 缓存与缓冲区缓存（buffer cache）非常相似，但它通常以环形缓冲区（ring buffer）的方式运行：新的日志条目被添加到缓冲区的头部，而旧的条目则从尾部开始写入磁盘。如果 WAL 缓存太小，就会比必要的更频繁地进行磁盘同步操作。</p>
<p>在系统负载较低的情况下，插入位置（即缓冲区的头部）几乎总是与已经写入磁盘的条目位置（即缓冲区的尾部）保持一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_lsn <span class="operator">|</span> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">--------------------+---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDC2CD8         <span class="operator">|</span> <span class="number">1</span><span class="operator">/</span>EBDC2CD8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在PostgreSQL 10之前，所有函数名称都包含XLOG首字母缩写词，而不是WAL。</p>
</blockquote>
<p>为了引用某个特定的日志条目，PostgreSQL 使用一种特殊的数据类型：pg_lsn（日志序列号，Log Sequence Number，简称 LSN）。它表示从 WAL 起始位置开始，以字节为单位的 64 位偏移量。LSN 通常以两个十六进制数字表示，中间用斜杠（&#x2F;）分隔。</p>
<p>我们创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> wal(id <span class="type">integer</span>);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> wal <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">启动一个事务，并记录下当前 WAL 插入位置的 LSN。</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA4F8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>现在执行一个任意命令，例如，更新一行数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">UPDATE</span> wal <span class="keyword">SET</span> id <span class="operator">=</span> id <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>页面的修改是在 RAM 中的缓冲区缓存（buffer cache）中进行的。这个更改也会记录在位于 RAM 中的 WAL 页面中。因此，插入的 LSN 会向前推进。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA5E8</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>为了确保修改后的数据页是在对应的 WAL 条目之后才被刷新到磁盘，数据页的页头会存储该页最新相关的 WAL 条目的 LSN。你可以使用 pageinspect 插件查看这个 LSN。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> lsn <span class="keyword">FROM</span> page_header(get_raw_page(<span class="string">&#x27;wal&#x27;</span>,<span class="number">0</span>));</span><br><span class="line">    lsn     </span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDA5B0</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>整个数据库集群只有一个 WAL，并且新的条目会不断地追加到其中。因此，存储在数据页中的 LSN 可能会比 之前某个时刻 pg_current_wal_insert_lsn() 返回的 LSN 更小。但如果系统中没有发生任何操作，这两个数值将会相同。</p>
<p>现在提交这个事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span><span class="operator">*</span># <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">commit</span>操作同样被日志记录，同时<span class="keyword">insert</span> lsn再次改变</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_current_wal_insert_lsn();</span><br><span class="line"> pg_current_wal_insert_lsn </span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"> <span class="number">1</span><span class="operator">/</span>EBDDC500</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>为了确保某个 CLog 页在对应的 WAL 条目写入磁盘之前不会被刷新到磁盘，必须追踪该页所对应的最新 WAL 条目的 LSN。但这种 LSN 信息是保存在内存（RAM）中的，而不是存在 CLog 页本身</p>
<p>某个时刻，WAL 日志条目会被写入磁盘；此时，才能把对应的 CLOG 和数据页从缓存中淘汰（evict）。如果必须更早淘汰这些缓存页，那么系统会发现这一点，并会先强制将对应的 WAL 条目写入磁盘。<br>如果你知道两个 LSN（日志序列号）的位置，就可以通过简单地相减计算这两者之间的 WAL 日志大小（以字节为单位）。只需将它们转换为 pg_lsn 类型即可进行减法运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># demo<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="string">&#x27;1/EBDDC500&#x27;</span>::pg_lsn <span class="operator">-</span> <span class="string">&#x27;1/EBDDA4F8&#x27;</span>::pg_lsn;</span><br><span class="line"> ?<span class="keyword">column</span>? </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">     <span class="number">8200</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>在这个具体案例中，更新（update）和提交（commit）操作相关的 WAL 条目大约占用了几千字节。可以用相同的方法，估算某个工作负载在单位时间内产生的 WAL 日志量。<br>这些信息对设置检查点（checkpoint）参数非常重要。</p>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL Structure(Physical-Structure)</title>
    <url>/2025/07/29/postgresql/WAL-Structure-Physical-Structure/</url>
    <content><![CDATA[<p>在磁盘上，WAL 被存储在 PGDATA&#x2F;pg_wal 目录中，以单独的文件（或称为段）的形式存在。它们的大小由只读参数 wal_segment_size 指示。</p>
<p>对于高负载系统，增加段大小可能是有意义的，因为这可以减少开销。但这个设置只能在集群初始化时修改（通过 initdb –wal-segsize）。</p>
<p>WAL 记录会写入当前文件，直到该文件空间耗尽；此时 PostgreSQL 会开始写入一个新文件。</p>
<p>我们可以确定某条记录位于哪个文件中，以及它在该文件起始位置的偏移量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> file_name, <span class="built_in">upper</span>(to_hex(file_offset)) file_offset <span class="keyword">FROM</span> pg_walfile_name_offset(<span class="string">&#x27;1/EBDDC500&#x27;</span>);</span><br><span class="line">        file_name         <span class="operator">|</span> file_offset </span><br><span class="line"><span class="comment">--------------------------+-------------</span></span><br><span class="line"> <span class="number">0000000100000001000000</span>EB <span class="operator">|</span> DDC500</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>该文件的名称由两部分组成。最高的八位十六进制数字（4个字节）表示用于从备份中恢复的时间线（timeline），而其余部分（8个字节）表示 LSN（日志序列号）的高位比特（LSN 的低位比特则体现在 file_offset 字段中）。</p>
<p>要查看当前的 WAL 文件，可以调用以下函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> pg_ls_waldir()</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;0000000100000001000000EB&#x27;</span>;</span><br><span class="line">           name           <span class="operator">|</span>   size   <span class="operator">|</span>      modification      </span><br><span class="line"><span class="comment">--------------------------+----------+------------------------</span></span><br><span class="line"> <span class="number">0000000100000001000000</span>EB <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span> <span class="number">2025</span><span class="number">-07</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">41</span>:<span class="number">49</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>现在让我们使用 pg_waldump 工具查看新创建的 WAL 记录的头部信息。该工具既可以按 LSN 范围（就像这个例子中那样）过滤 WAL 记录，也可以按特定的事务 ID 过滤。</p>
<p>pg_waldump 工具应以 postgres 用户身份运行，因为它需要访问磁盘上的 WAL 文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ pg_waldump <span class="operator">-</span>p <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>pgsql<span class="operator">/</span>data<span class="operator">/</span>pg_wal <span class="operator">-</span>s  <span class="number">1</span><span class="operator">/</span>EBDDA4F8 <span class="operator">-</span>e <span class="number">1</span><span class="operator">/</span>EBDDC500</span><br><span class="line">rmgr: XLOG        len (rec<span class="operator">/</span>tot):     <span class="number">49</span><span class="operator">/</span>   <span class="number">109</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA4F8, prev <span class="number">1</span><span class="operator">/</span>EBDDA4C0, <span class="keyword">desc</span>: FPI_FOR_HINT , blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">376833</span> blk <span class="number">0</span> FPW</span><br><span class="line">rmgr: Heap        len (rec<span class="operator">/</span>tot):     <span class="number">69</span><span class="operator">/</span>    <span class="number">69</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA568, prev <span class="number">1</span><span class="operator">/</span>EBDDA4F8, <span class="keyword">desc</span>: HOT_UPDATE old_xmax: <span class="number">961</span>, old_off: <span class="number">1</span>, old_infobits: [], flags: <span class="number">0x40</span>, new_xmax: <span class="number">0</span>, new_off: <span class="number">2</span>, blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">376833</span> blk <span class="number">0</span></span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">54</span><span class="operator">/</span>    <span class="number">54</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA5B0, prev <span class="number">1</span><span class="operator">/</span>EBDDA568, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">960</span> oldestRunningXid <span class="number">961</span>; <span class="number">1</span> xacts: <span class="number">961</span></span><br><span class="line">rmgr: XLOG        len (rec<span class="operator">/</span>tot):     <span class="number">49</span><span class="operator">/</span>  <span class="number">7777</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDA5E8, prev <span class="number">1</span><span class="operator">/</span>EBDDA5B0, <span class="keyword">desc</span>: FPI_FOR_HINT , blkref #<span class="number">0</span>: rel <span class="number">1663</span><span class="operator">/</span><span class="number">32814</span><span class="operator">/</span><span class="number">2691</span> blk <span class="number">19</span> FPW</span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">54</span><span class="operator">/</span>    <span class="number">54</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC468, prev <span class="number">1</span><span class="operator">/</span>EBDDA5E8, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">960</span> oldestRunningXid <span class="number">961</span>; <span class="number">1</span> xacts: <span class="number">961</span></span><br><span class="line">rmgr: Transaction len (rec<span class="operator">/</span>tot):     <span class="number">34</span><span class="operator">/</span>    <span class="number">34</span>, tx:        <span class="number">961</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC4A0, prev <span class="number">1</span><span class="operator">/</span>EBDDC468, <span class="keyword">desc</span>: <span class="keyword">COMMIT</span> <span class="number">2025</span><span class="number">-07</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">04</span>:<span class="number">55.325979</span> CST</span><br><span class="line">rmgr: Standby     len (rec<span class="operator">/</span>tot):     <span class="number">50</span><span class="operator">/</span>    <span class="number">50</span>, tx:          <span class="number">0</span>, lsn: <span class="number">1</span><span class="operator">/</span>EBDDC4C8, prev <span class="number">1</span><span class="operator">/</span>EBDDC4A0, <span class="keyword">desc</span>: RUNNING_XACTS nextXid <span class="number">962</span> latestCompletedXid <span class="number">961</span> oldestRunningXid <span class="number">962</span></span><br><span class="line">postgres<span class="variable">@lavm</span><span class="operator">-</span>bar1guved6:<span class="operator">/</span>root$ </span><br></pre></td></tr></table></figure>
<ol>
<li>FPI_FOR_HINT（全页镜像，为 Hint Bit）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: XLOG len (rec/tot): 49/109, tx: 0, lsn: 1/EBDDA4F8, prev 1/EBDDA4C0, desc: FPI_FOR_HINT , blkref #0: rel 1663/32814/376833 blk 0 FPW</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: XLOG：表示这是 XLOG（日志）资源管理器记录。</li>
<li>FPI_FOR_HINT：全页镜像用于设置 Hint bit。为了避免 Hint bit 修改没有日志而导致数据页 checksum 校验失败，PostgreSQL 会把整个页面写入 WAL（FPW, Full Page Write）。</li>
<li>rel 1663&#x2F;32814&#x2F;376833 blk 0：指的是某个表的第 0 页（block 0），文件标识符是：数据库OID&#x3D;32814，表OID&#x3D;376833。</li>
<li>tx: 0：不是某个事务产生的，而是后台 hint bit 的写入。</li>
<li>FPW：全页写入。</li>
</ul>
<ol start="2">
<li>HOT_UPDATE（堆表中的更新） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Heap len (rec/tot): 69/69, tx: 961, lsn: 1/EBDDA568, prev 1/EBDDA4F8, desc: HOT_UPDATE old_xmax: 961, old_off: 1, old_infobits: [], flags: 0x40, new_xmax: 0, new_off: 2, blkref #0: rel 1663/32814/376833 blk 0</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: Heap：这是 Heap 表的更新记录。</li>
<li>HOT_UPDATE：表示使用了“Heap-Only Tuple”优化，即更新没有修改索引字段，所以新旧 tuple 都在一个页里。</li>
<li>tx: 961：由事务 961 发起。</li>
<li>old_off: 1 -&gt; new_off: 2：第 1 个 tuple 更新为第 2 个位置的 tuple。</li>
<li>old_xmax: 961：原始 tuple 的删除者是当前事务。</li>
<li>new_xmax: 0：新 tuple 尚未被删除。</li>
<li>rel 1663&#x2F;32814&#x2F;376833 blk 0：仍然是这个表第 0 页</li>
</ul>
<ol start="3">
<li>RUNNING_XACTS（记录活跃事务信息） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 54/54, tx: 0, lsn: 1/EBDDA5B0, prev 1/EBDDA568, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 960 oldestRunningXid 961; 1 xacts: 961</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>rmgr: Standby：这是为备机记录活跃事务信息。</li>
<li>nextXid: 962：下一个将被分配的事务 ID。</li>
<li>latestCompletedXid: 960：最后一个完成的事务。</li>
<li>oldestRunningXid: 961：最老的活跃事务。</li>
<li>1 xacts: 961：当前只有一个活跃事务 961。<br>  这类记录有助于逻辑解码和备机恢复时判断哪些事务是已提交、未提交。</li>
</ul>
<ol start="4">
<li>FPI_FOR_HINT（另一个 hint bit 的全页写入） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: XLOG len (rec/tot): 49/7777, tx: 961, lsn: 1/EBDDA5E8, prev 1/EBDDA5B0, desc: FPI_FOR_HINT , blkref #0: rel 1663/32814/2691 blk 19 FPW</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>又是一个 FPI_FOR_HINT，但这次是针对：<br>  rel 1663&#x2F;32814&#x2F;2691 blk 19：另外一个表的第 19 页。</li>
<li>注意这次记录总长度达到了 7777 字节，很可能是完整的数据页写入（通常 8KB）。</li>
</ul>
<ol start="5">
<li><p>RUNNING_XACTS（再次记录活跃事务）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 54/54, tx: 0, lsn: 1/EBDDC468, prev 1/EBDDA5E8, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 960 oldestRunningXid 961; 1 xacts: 961</span><br></pre></td></tr></table></figure>
<p> 和之前类似，再次记录活跃事务 961。</p>
</li>
<li><p>COMMIT（事务提交）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Transaction len (rec/tot): 34/34, tx: 961, lsn: 1/EBDDC4A0, prev 1/EBDDC468, desc: COMMIT 2025-07-28 16:04:55.325979 CST</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>事务 961 正式提交。</li>
<li>提交时间 是 2025-07-28 16:04:55。</li>
</ul>
<ol start="7">
<li>RUNNING_XACTS（提交后活跃事务清空） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmgr: Standby len (rec/tot): 50/50, tx: 0, lsn: 1/EBDDC4C8, prev 1/EBDDC4A0, desc: RUNNING_XACTS nextXid 962 latestCompletedXid 961 oldestRunningXid 962</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>事务 961 已完成，现在没有活跃事务了。</li>
<li>nextXid 为 962，准备分配给下一个事务。</li>
</ul>
<p>查看日志文件路径  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">demo=# SELECT pg_relation_filepath(&#x27;wal&#x27;);</span><br><span class="line"> pg_relation_filepath </span><br><span class="line">----------------------</span><br><span class="line"> base/32814/376833</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>WAL设置</title>
    <url>/2025/11/03/postgresql/WAL%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置checkpoint"><a href="#配置checkpoint" class="headerlink" title="配置checkpoint"></a>配置checkpoint</h2><p>checkpoint持续时间（更准确地说，是将脏缓冲区写入磁盘所需的时间）由参数 checkpoint_completion_target 决定。该参数的值表示checkpoint 期间的 I&#x2F;O 分布目标，是一个比例。避免将该参数设置为 1：否则可能会导致下一个checkpoint启动时，上一个checkpoint尚未完成。虽然不会发生灾难性的后果（因为同一时间只能执行一个checkpoint），但正常运行可能仍会受到干扰。</p>
<p>在配置其他参数时，我们可以采用以下方法。首先，确定在两个相邻checkpoint之间应存储的 WAL 文件的合理体积。这个体积越大，系统开销就越小，但它仍然会受到可用磁盘空间和可接受的恢复时间的限制。</p>
<p>为了估算在正常负载下生成这一体积所需的时间，你需要记录初始的 insert LSN，并定期检查它与当前 insert 位置之间的差值</p>
<p>我们将前面计算出的数值视为checkpoint之间的典型间隔，因此将其用作 checkpoint_timeout 参数的值。默认设置往往偏小，通常会将其增加，例如设置为 30 分钟。</p>
<p>但也很可能（甚至可以说是很常见）负载会在某些时候升高，从而导致在这个时间间隔内生成的 WAL 文件体积过大。在这种情况下，必须更频繁地执行checkpoint。为了设置这样的触发机制，我们通过 max_wal_size 参数来限制恢复时所需的 WAL 文件总量。当超过这个阈值时，服务器会额外执行一次checkpoint。</p>
<p>恢复所需的 WAL 文件包含了上一个已完成checkpoint和当前尚未完成检查点的所有记录。因此，为了估算这些文件的总体积，应将计算出的检查点之间的 WAL 大小乘以<br>1 + checkpoint_completion_target。</p>
<blockquote>
<p>在 PostgreSQL 11 版本之前，系统会保留两个已完成checkpoint所对应的 WAL 文件，因此估算恢复所需 WAL 总体积的倍数是：2 + checkpoint_completion_target</p>
</blockquote>
<p>按照这种方式，大多数checkpoint会按计划执行，即按照 checkpoint_timeout 设置的时间间隔执行一次；但如果系统负载增加，导致生成的 WAL 文件大小超过 max_wal_size 的设定值，就会提前触发一次checkpoint。</p>
<p>系统还会定期将实际进度与预期数值进行比较，以监控写入进度是否达标。</p>
<p>实际进度由已处理的缓存页所占的比例来定义。</p>
<p>按时间计算的预期进度是指已过去的时间占比，其前提假设是checkpoint必须在 checkpoint_timeout × checkpoint_completion_target 的时间内完成。</p>
<p>按大小计算的预期进度是指已写入的 WAL 文件所占的比例，其总量根据 max_wal_size × checkpoint_completion_target 来估算。</p>
<p>如果脏页提前写入磁盘，checkpointer 进程会暂停一段时间；如果在时间或数据大小的任何一个参数上出现延迟，它会尽快赶上进度。由于同时考虑了时间和数据大小，PostgreSQL 能够用同一套机制来管理定时checkpoint和按需checkpoint。</p>
<p>一旦checkpoint完成，不再需要用于恢复的 WAL 文件将被删除；不过，系统会保留若干文件（总大小不超过 min_wal_size），用于重复利用，并通过重命名的方式保留。</p>
<p>这种重命名机制减少了频繁创建和删除文件所带来的开销；如果你不需要这个功能，可以通过参数 wal_recycle 将其关闭。</p>
<p>下图展示了在正常情况下，磁盘上 WAL 文件大小的变化趋势</p>
<p><img src="/./images/wal.png" alt="wal"></p>
<p>需要注意的是，磁盘上实际的 WAL 文件大小可能会超过 max_wal_size 的设定值，原因包括：</p>
<ul>
<li>max_wal_size 参数只是一个期望目标值，而不是严格限制。如果负载突然上升，写入速度可能会落后于计划，导致 WAL 文件积压。</li>
<li>尚未被复制或归档的 WAL 文件，服务器无权删除。如果启用了流复制或持续归档功能，必须持续监控这些机制，否则非常容易导致磁盘空间耗尽。</li>
<li>你可以通过配置 wal_keep_size 参数来预留一定的磁盘空间用于存储 WAL 文件，以避免这些问题带来的风险。</li>
</ul>
<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>an_example_of_using_pageinspect</title>
    <url>/2025/11/13/postgresql/an-example-of-using-pageinspect/</url>
    <content><![CDATA[<h2 id="准备表数据"><a href="#准备表数据" class="headerlink" title="准备表数据"></a>准备表数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">create table</span> users(id <span class="type">int</span> generated always <span class="keyword">as</span> <span class="keyword">identity</span> <span class="keyword">primary key</span>, name text);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> oid, relname, relfilenode <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line">  oid  <span class="operator">|</span> relname <span class="operator">|</span> relfilenode </span><br><span class="line"><span class="comment">-------+---------+-------------</span></span><br><span class="line"> <span class="number">40980</span> <span class="operator">|</span> users   <span class="operator">|</span>       <span class="number">40980</span></span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> c.oid, c.relname, i.indisprimary <span class="keyword">from</span> pg_class c <span class="keyword">join</span> pg_index i <span class="keyword">on</span> c.oid <span class="operator">=</span> i.indexrelid <span class="keyword">where</span> i.indrelid <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>::regclass <span class="keyword">and</span> i.indisprimary;</span><br><span class="line">  oid  <span class="operator">|</span>  relname   <span class="operator">|</span> indisprimary </span><br><span class="line"><span class="comment">-------+------------+--------------</span></span><br><span class="line"> <span class="number">40986</span> <span class="operator">|</span> users_pkey <span class="operator">|</span> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">ERROR:  block number <span class="number">0</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">for</span> relation &quot;users&quot;</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">ERROR:  block number <span class="number">1</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span></span><br><span class="line">test<span class="operator">=</span># <span class="operator">^</span>C</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="insert-values"><a href="#insert-values" class="headerlink" title="insert values"></a>insert values</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">insert into</span> users(name) <span class="keyword">values</span>(<span class="string">&#x27;jeffrey&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_len <span class="operator">|</span>           t_data           </span><br><span class="line"><span class="comment">----+--------+----------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>     <span class="number">36</span> <span class="operator">|</span> \x01000000116a656666726579</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> itemoffset <span class="operator">|</span> ctid  <span class="operator">|</span> itemlen <span class="operator">|</span> nulls <span class="operator">|</span> vars <span class="operator">|</span>          data           <span class="operator">|</span> dead <span class="operator">|</span> htid  <span class="operator">|</span> tids </span><br><span class="line"><span class="comment">------------+-------+---------+-------+------+-------------------------+------+-------+------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> page_header(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">    lsn     <span class="operator">|</span> checksum <span class="operator">|</span> flags <span class="operator">|</span> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize <span class="operator">|</span> version <span class="operator">|</span> prune_xid </span><br><span class="line"><span class="comment">------------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span><span class="operator">/</span><span class="number">03</span>F5E7A0 <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span>    <span class="number">28</span> <span class="operator">|</span>  <span class="number">8152</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>         <span class="number">0</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">insert into</span> users(name) <span class="keyword">values</span>(<span class="string">&#x27;Ethan&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> page_header(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">    lsn     <span class="operator">|</span> checksum <span class="operator">|</span> flags <span class="operator">|</span> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize <span class="operator">|</span> version <span class="operator">|</span> prune_xid </span><br><span class="line"><span class="comment">------------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span><span class="operator">/</span><span class="number">03</span>F62810 <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span>    <span class="number">32</span> <span class="operator">|</span>  <span class="number">8112</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>         <span class="number">0</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_len <span class="operator">|</span>           t_data           </span><br><span class="line"><span class="comment">----+--------+----------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>     <span class="number">36</span> <span class="operator">|</span> \x01000000116a656666726579</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>     <span class="number">34</span> <span class="operator">|</span> \x020000000d457468616e</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> itemoffset <span class="operator">|</span> ctid  <span class="operator">|</span> itemlen <span class="operator">|</span> nulls <span class="operator">|</span> vars <span class="operator">|</span>          data           <span class="operator">|</span> dead <span class="operator">|</span> htid  <span class="operator">|</span> tids </span><br><span class="line"><span class="comment">------------+-------+---------+-------+------+-------------------------+------+-------+------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> </span><br><span class="line">          <span class="number">2</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span> </span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】不要给 PostgreSQL 分配过多内存</title>
    <url>/2025/12/25/postgresql/dont-give-postgres-too-much-memory/</url>
    <content><![CDATA[<blockquote>
<p>本文为英文技术博客《Don’t give Postgres too much memory》的中文翻译。<br>原文作者：Tomas Vondra<br>原文链接：<a href="https://vondra.me/posts/dont-give-postgres-too-much-memory/">https://vondra.me/posts/dont-give-postgres-too-much-memory/</a><br>本文接近原文直译，仅做结构整理与术语统一，所有观点归原作者所有。</p>
</blockquote>
<hr>
<h2 id="背景：一次“批处理”性能排查的经历"><a href="#背景：一次“批处理”性能排查的经历" class="headerlink" title="背景：一次“批处理”性能排查的经历"></a>背景：一次“批处理”性能排查的经历</h2><p>我时不时会被拉去排查一些与<strong>批处理（batch processing）</strong>相关的问题。<br>最近越来越常见的一种情况是：这些批处理进程会使用<strong>非常大的内存限制</strong>，尤其是：</p>
<ul>
<li><code>maintenance_work_mem</code></li>
<li><code>work_mem</code></li>
</ul>
<p>我猜不少 DBA 的思路是：</p>
<blockquote>
<p><strong>“内存越大越好。”</strong></p>
</blockquote>
<p>但他们往往没有意识到，这样做<strong>实际上可能会明显拖慢性能</strong>。</p>
<hr>
<h2 id="一个触发问题的实际案例"><a href="#一个触发问题的实际案例" class="headerlink" title="一个触发问题的实际案例"></a>一个触发问题的实际案例</h2><p>我用一个在测试 <strong>GIN 索引并行构建修复</strong> 时遇到的例子来说明这个问题。</p>
<p>这个 bug 本身并不复杂，也不算特别有意思，但它需要一个<strong>相当高的 <code>maintenance_work_mem</code></strong> 才能复现 —— 最初的报告里使用了 <strong>20GB</strong>。</p>
<p>为了验证修复是否有效，我在：</p>
<ul>
<li>不同的 <code>maintenance_work_mem</code> 设置</li>
<li>不同数量的并行 worker</li>
</ul>
<p>组合下，反复执行 <code>CREATE INDEX</code>。</p>
<p>本来的目标只是检查是否还会失败，但我同时也记录了执行时间，并将结果画成了一张图。</p>
<p><img src="/images/workmem/image.png" alt="mem"></p>
<hr>
<h2 id="测试环境说明"><a href="#测试环境说明" class="headerlink" title="测试环境说明"></a>测试环境说明</h2><p>测试运行在 Azure 上的一台 <strong>D96v4 实例</strong>：</p>
<ul>
<li><strong>CPU</strong>：Xeon Platinum 8573C  </li>
<li><strong>内存</strong>：384GB  </li>
<li><strong>存储</strong>：6 块 NVMe 组成 RAID0</li>
</ul>
<p>这意味着：</p>
<ul>
<li>数据基本全部命中缓存</li>
<li>瓶颈主要在 <strong>CPU，而不是磁盘 I&#x2F;O</strong></li>
</ul>
<hr>
<h2 id="并行化的效果（符合预期）"><a href="#并行化的效果（符合预期）" class="headerlink" title="并行化的效果（符合预期）"></a>并行化的效果（符合预期）</h2><p>并行化确实带来了明显收益：</p>
<ul>
<li><p>使用 <strong>2 个 worker（包括 leader）</strong><br>→ 性能提升约 <strong>1.8 倍</strong><br>→ 接近理想加速比（因为索引构建的最后阶段仍然是串行的）</p>
</li>
<li><p>随着 worker 数量继续增加：</p>
<ul>
<li>加速比逐渐下降  </li>
<li>例如 <strong>8 个 worker 只有约 4.5 倍</strong></li>
</ul>
</li>
</ul>
<p>这完全符合预期。</p>
<hr>
<h2 id="反直觉的现象：内存越大，反而越慢"><a href="#反直觉的现象：内存越大，反而越慢" class="headerlink" title="反直觉的现象：内存越大，反而越慢"></a>反直觉的现象：内存越大，反而越慢</h2><p>真正令人意外的是图中展示的另一个趋势：</p>
<blockquote>
<p><strong><code>maintenance_work_mem</code> 越大，索引构建反而越慢。</strong></p>
</blockquote>
<p>具体表现为：</p>
<ul>
<li>从 <strong>64MB</strong> 增加到 <strong>16GB</strong></li>
<li>索引构建时间增加了 <strong>约 30%</strong></li>
<li>并且 <strong>无论使用多少并行 worker，这一趋势都一致</strong></li>
</ul>
<p>为什么会这样？</p>
<hr>
<h2 id="原因概览"><a href="#原因概览" class="headerlink" title="原因概览"></a>原因概览</h2><p>这很可能是多种因素共同作用的结果。<br>下面我解释两个我认为<strong>最重要的原因</strong>：</p>
<ol>
<li><strong>L3 Cache 的大小限制</strong></li>
<li><strong>Linux 脏页（dirty page）回写机制</strong></li>
</ol>
<hr>
<h2 id="原因一：L3-Cache-的大小限制"><a href="#原因一：L3-Cache-的大小限制" class="headerlink" title="原因一：L3 Cache 的大小限制"></a>原因一：L3 Cache 的大小限制</h2><p>系统中的内存并不是“同一种速度”。</p>
<p>在 CPU 内部，存在一小块<strong>极快的缓存（L3 Cache）</strong>，访问延迟非常低。<br>但这部分内存通常只有 <strong>32MB～128MB</strong>。</p>
<p>相比之下：</p>
<ul>
<li>主内存（RAM）容量巨大</li>
<li>但访问延迟要高一个数量级</li>
</ul>
<hr>
<h3 id="索引构建中的内存访问模式"><a href="#索引构建中的内存访问模式" class="headerlink" title="索引构建中的内存访问模式"></a>索引构建中的内存访问模式</h3><p>在索引构建过程中，通常会经历以下流程：</p>
<ol>
<li>将数据累积到一个内存缓冲区</li>
<li>缓冲区“满了”之后进行处理</li>
<li>再合并到最终的索引结构中</li>
</ol>
<p>对于 <strong>GIN 索引</strong> 来说，这一步会把条目插入到一个<strong>哈希表</strong>中，这意味着：</p>
<blockquote>
<p><strong>大量随机内存访问</strong></p>
</blockquote>
<hr>
<h3 id="Cache-Miss-的代价"><a href="#Cache-Miss-的代价" class="headerlink" title="Cache Miss 的代价"></a>Cache Miss 的代价</h3><p>一旦这个哈希表的大小超过 <strong>L3 Cache</strong>，CPU 就不得不频繁访问主内存。</p>
<p>大致的访问代价是：</p>
<ul>
<li><strong>L3 Cache</strong>：约 <strong>20 个 CPU cycle</strong></li>
<li><strong>主内存</strong>：约 <strong>200 个 CPU cycle</strong></li>
</ul>
<p>也就是说，<strong>慢了一个数量级</strong>。</p>
<hr>
<h3 id="更优的策略"><a href="#更优的策略" class="headerlink" title="更优的策略"></a>更优的策略</h3><p>因此：</p>
<ul>
<li>将数据拆分成更小的批次处理</li>
<li>让工作集尽量能够放进 L3 Cache</li>
</ul>
<p>往往是更优的策略。</p>
<p>即使需要处理更多批次，<strong>总体上仍然可能更快</strong>。</p>
<p><strong>推荐阅读</strong>：<br>Ulrich Drepper，《<em>What Every Programmer Should Know About Memory</em>》（2007）<br>虽然年代久远，但内存层级的基本原理至今没有变化。</p>
<hr>
<h2 id="原因二：Linux-脏页（dirty-page）回写机制"><a href="#原因二：Linux-脏页（dirty-page）回写机制" class="headerlink" title="原因二：Linux 脏页（dirty page）回写机制"></a>原因二：Linux 脏页（dirty page）回写机制</h2><p>除了 CPU Cache，还有操作系统层面的因素。</p>
<p>当 GIN 的哈希表超过 <code>maintenance_work_mem</code> 限制时，数据会被写入<strong>临时文件</strong>。<br>这些文件不需要持久化保证，因此写入时只进入 <strong>page cache</strong>。</p>
<hr>
<h3 id="Linux-的脏页控制机制"><a href="#Linux-的脏页控制机制" class="headerlink" title="Linux 的脏页控制机制"></a>Linux 的脏页控制机制</h3><p>Linux 内核通过两个阈值控制脏页数量：</p>
<ul>
<li><code>vm.dirty_background_ratio</code>  <ul>
<li>达到后，后台开始异步回写</li>
</ul>
</li>
<li><code>vm.dirty_ratio</code>  <ul>
<li>达到后，<strong>所有写入变成同步写</strong>（非常致命）</li>
</ul>
</li>
</ul>
<p>理想状态下：</p>
<blockquote>
<p>后台回写足够快，永远不会触及 <code>vm.dirty_ratio</code></p>
</blockquote>
<hr>
<h3 id="大批量写入的问题"><a href="#大批量写入的问题" class="headerlink" title="大批量写入的问题"></a>大批量写入的问题</h3><p>问题在于：<br><strong>内核是否有“时间”去完成这些回写。</strong></p>
<p>假设构建哈希表需要累积 <strong>8GB 数据，用时 1 分钟</strong>：</p>
<h4 id="情况-A：一次性写出"><a href="#情况-A：一次性写出" class="headerlink" title="情况 A：一次性写出"></a>情况 A：一次性写出</h4><ul>
<li>1 分钟内几乎不写</li>
<li>最后一次性写出 8GB</li>
<li>短时间内产生大量脏页</li>
<li>极易触发同步写</li>
</ul>
<h4 id="情况-B：分批写出"><a href="#情况-B：分批写出" class="headerlink" title="情况 B：分批写出"></a>情况 B：分批写出</h4><ul>
<li>每 <strong>64MB</strong> 写一次</li>
<li>写操作均匀分布</li>
<li>内核有足够时间后台回写</li>
</ul>
<p>显然后者对系统更加友好。</p>
<hr>
<h2 id="总结（原文结论）"><a href="#总结（原文结论）" class="headerlink" title="总结（原文结论）"></a>总结（原文结论）</h2><p>以上所有分析，**同样适用于 <code>work_mem</code>**。</p>
<p>唯一的区别在于：</p>
<ul>
<li><code>maintenance_work_mem</code>  <ul>
<li>用于维护操作（<code>CREATE INDEX</code>、<code>VACUUM</code> 等）</li>
</ul>
</li>
<li><code>work_mem</code>  <ul>
<li>用于普通查询（<code>hash join</code>、<code>hash aggregate</code>、<code>sort</code> 等）</li>
</ul>
</li>
</ul>
<p>但底层原理完全一致：</p>
<ul>
<li>哈希表超过 L3 Cache → 性能下降</li>
<li>大块内存写入 → 脏页压力 → 可能触发同步写</li>
</ul>
<hr>
<h2 id="作者建议"><a href="#作者建议" class="headerlink" title="作者建议"></a>作者建议</h2><p>我并不知道 <code>maintenance_work_mem</code> 或 <code>work_mem</code> 的“最佳值”是多少，这也不是这篇文章的重点。</p>
<p>重点在于：</p>
<blockquote>
<p><strong>盲目把内存参数调得很大，可能会显著伤害性能。</strong></p>
</blockquote>
<p>我的建议是：</p>
<ul>
<li>从<strong>比较保守的值</strong>开始（例如 <strong>64MB</strong>）</li>
<li>只有在你能<strong>明确证明存在收益</strong>的情况下，才逐步调高</li>
</ul>
<hr>
<h2 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a>原文信息</h2><ul>
<li>原文作者：Tomas Vondra  </li>
<li>原文地址：<a href="https://vondra.me/posts/dont-give-postgres-too-much-memory/">https://vondra.me/posts/dont-give-postgres-too-much-memory/</a></li>
</ul>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>Performance</tag>
        <tag>work_mem</tag>
        <tag>maintenance_work_mem</tag>
        <tag>GIN</tag>
      </tags>
  </entry>
  <entry>
    <title>page</title>
    <url>/2025/08/11/postgresql/page/</url>
    <content><![CDATA[<p>Each page has a certain inner layout that usually consists of the following parts:<br>page header</p>
<ul>
<li>page header</li>
<li>an array of item pointers</li>
<li>free space</li>
<li>items (row versions)</li>
<li>special space</li>
</ul>
<h2 id="Page结构示意图："><a href="#Page结构示意图：" class="headerlink" title="Page结构示意图："></a>Page结构示意图：</h2><img src="/images/page.png" alt="page.png" style="zoom:100%;" />

<h2 id="pageinspect-extension"><a href="#pageinspect-extension" class="headerlink" title="pageinspect extension"></a>pageinspect extension</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE</span> EXTENSION pageinspect;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> accounts;</span><br><span class="line"> id <span class="operator">|</span> client  <span class="operator">|</span> amount </span><br><span class="line"><span class="comment">----+---------+--------</span></span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span> bob     <span class="operator">|</span> <span class="number">100.00</span></span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span> bob     <span class="operator">|</span> <span class="number">900.00</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span> alice   <span class="operator">|</span> <span class="number">800.00</span></span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span> charlie <span class="operator">|</span> <span class="number">100.00</span></span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> lower, upper, special, pagesize <span class="keyword">FROM</span> page_header(get_raw_page(<span class="string">&#x27;accounts&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize </span><br><span class="line"><span class="comment">-------+-------+---------+----------</span></span><br><span class="line">    <span class="number">40</span> <span class="operator">|</span>  <span class="number">8032</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">FROM</span> heap_page_items(get_raw_page(<span class="string">&#x27;accounts&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_off <span class="operator">|</span> lp_flags <span class="operator">|</span> lp_len <span class="operator">|</span> t_xmin <span class="operator">|</span> t_xmax <span class="operator">|</span> t_field3 <span class="operator">|</span> t_ctid <span class="operator">|</span> t_infomask2 <span class="operator">|</span> t_infomask <span class="operator">|</span> t_hoff <span class="operator">|</span> t_bits <span class="operator">|</span> t_oid <span class="operator">|</span>                t_data                </span><br><span class="line"><span class="comment">----+--------+----------+--------+--------+--------+----------+--------+-------------+------------+--------+--------+-------+--------------------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>   <span class="number">8152</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">758</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">4</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">1282</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b0081e803</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>   <span class="number">8112</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">5</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">2306</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0200000009626f620b00816400</span><br><span class="line">  <span class="number">3</span> <span class="operator">|</span>   <span class="number">8072</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">757</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">6</span>)  <span class="operator">|</span>       <span class="number">16387</span> <span class="operator">|</span>       <span class="number">2306</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000009626f620b00818403</span><br><span class="line">  <span class="number">4</span> <span class="operator">|</span>   <span class="number">8032</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">758</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">7</span>)  <span class="operator">|</span>       <span class="number">49155</span> <span class="operator">|</span>      <span class="number">10498</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b00812003</span><br><span class="line">  <span class="number">5</span> <span class="operator">|</span>   <span class="number">7992</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">5</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0200000009626f620b00816300</span><br><span class="line">  <span class="number">6</span> <span class="operator">|</span>   <span class="number">7952</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">37</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">6</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000009626f620b00818303</span><br><span class="line">  <span class="number">7</span> <span class="operator">|</span>   <span class="number">7912</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">39</span> <span class="operator">|</span>    <span class="number">802</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">7</span>)  <span class="operator">|</span>       <span class="number">32771</span> <span class="operator">|</span>      <span class="number">10754</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x010000000d616c6963650b00811f03</span><br><span class="line">  <span class="number">8</span> <span class="operator">|</span>   <span class="number">7864</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">41</span> <span class="operator">|</span>    <span class="number">809</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">8</span>)  <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>       <span class="number">2562</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0300000011636861726c69650b00816400</span><br><span class="line">  <span class="number">9</span> <span class="operator">|</span>   <span class="number">7816</span> <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span>     <span class="number">41</span> <span class="operator">|</span>    <span class="number">811</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">9</span>)  <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>       <span class="number">2050</span> <span class="operator">|</span>     <span class="number">24</span> <span class="operator">|</span>        <span class="operator">|</span>       <span class="operator">|</span> \x0400000011636861726c69650b00816400</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * disk page organization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * space management information generic to any page</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		pd_lsn		- identifies xlog record for last change to this page.</span></span><br><span class="line"><span class="comment"> *		pd_checksum - page checksum, if set.</span></span><br><span class="line"><span class="comment"> *		pd_flags	- flag bits.</span></span><br><span class="line"><span class="comment"> *		pd_lower	- offset to start of free space.</span></span><br><span class="line"><span class="comment"> *		pd_upper	- offset to end of free space.</span></span><br><span class="line"><span class="comment"> *		pd_special	- offset to start of special space.</span></span><br><span class="line"><span class="comment"> *		pd_pagesize_version - size in bytes and page layout version number.</span></span><br><span class="line"><span class="comment"> *		pd_prune_xid - oldest XID among potentially prunable tuples on page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The LSN is used by the buffer manager to enforce the basic rule of WAL:</span></span><br><span class="line"><span class="comment"> * &quot;thou shalt write xlog before data&quot;.  A dirty buffer cannot be dumped</span></span><br><span class="line"><span class="comment"> * to disk until xlog has been flushed at least as far as the page&#x27;s LSN.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pd_checksum stores the page checksum, if it has been set for this page;</span></span><br><span class="line"><span class="comment"> * zero is a valid value for a checksum. If a checksum is not in use then</span></span><br><span class="line"><span class="comment"> * we leave the field unset. This will typically mean the field is zero</span></span><br><span class="line"><span class="comment"> * though non-zero values may also be present if databases have been</span></span><br><span class="line"><span class="comment"> * pg_upgraded from releases prior to 9.3, when the same byte offset was</span></span><br><span class="line"><span class="comment"> * used to store the current timelineid when the page was last updated.</span></span><br><span class="line"><span class="comment"> * Note that there is no indication on a page as to whether the checksum</span></span><br><span class="line"><span class="comment"> * is valid or not, a deliberate design choice which avoids the problem</span></span><br><span class="line"><span class="comment"> * of relying on the page contents to decide whether to verify it. Hence</span></span><br><span class="line"><span class="comment"> * there are no flag bits relating to checksums.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pd_prune_xid is a hint field that helps determine whether pruning will be</span></span><br><span class="line"><span class="comment"> * useful.  It is currently unused in index pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The page version number and page size are packed together into a single</span></span><br><span class="line"><span class="comment"> * uint16 field.  This is for historical reasons: before PostgreSQL 7.3,</span></span><br><span class="line"><span class="comment"> * there was no concept of a page version number, and doing it this way</span></span><br><span class="line"><span class="comment"> * lets us pretend that pre-7.3 databases have page version number zero.</span></span><br><span class="line"><span class="comment"> * We constrain page sizes to be multiples of 256, leaving the low eight</span></span><br><span class="line"><span class="comment"> * bits available for a version number.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Minimum possible page size is perhaps 64B to fit page header, opaque space</span></span><br><span class="line"><span class="comment"> * and a minimal tuple; of course, in reality you want it much bigger, so</span></span><br><span class="line"><span class="comment"> * the constraint on pagesize mod 256 is not an important restriction.</span></span><br><span class="line"><span class="comment"> * On the high end, we can only support pages up to 32KB because lp_off/lp_len</span></span><br><span class="line"><span class="comment"> * are 15 bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageHeaderData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* XXX LSN is member of *any* block, not only page-organized ones */</span></span><br><span class="line">	PageXLogRecPtr pd_lsn;		<span class="comment">/* LSN: next byte after last byte of xlog</span></span><br><span class="line"><span class="comment">														 * record for last change to this page */</span></span><br><span class="line">	uint16		pd_checksum;	  <span class="comment">/* checksum */</span></span><br><span class="line">	uint16		pd_flags;		    <span class="comment">/* flag bits, see below */</span></span><br><span class="line">	LocationIndex pd_lower;		<span class="comment">/* offset to start of free space */</span></span><br><span class="line">	LocationIndex pd_upper;		<span class="comment">/* offset to end of free space */</span></span><br><span class="line">	LocationIndex pd_special;	<span class="comment">/* offset to start of special space */</span></span><br><span class="line">	uint16		pd_pagesize_version;</span><br><span class="line">	TransactionId pd_prune_xid; <span class="comment">/* oldest prunable XID, or zero if none */</span></span><br><span class="line">	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; <span class="comment">/* line pointer array */</span></span><br><span class="line">&#125; PageHeaderData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PageHeaderData *PageHeader;</span><br></pre></td></tr></table></figure>

<h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">drop</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> t(</span><br><span class="line">test(# id <span class="type">integer</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>, s text</span><br><span class="line">test(# );</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> t(s);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">INSERT INTO</span> t(s) <span class="keyword">VALUES</span> (<span class="string">&#x27;FOO&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">SELECT</span> pg_current_xact_id();</span><br><span class="line"> pg_current_xact_id </span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line">                <span class="number">766</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span><span class="operator">*</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>))\gx</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">1</span> ]<span class="comment">-------------------</span></span><br><span class="line">lp          <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">lp_off      <span class="operator">|</span> <span class="number">8160</span></span><br><span class="line">lp_flags    <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">lp_len      <span class="operator">|</span> <span class="number">32</span></span><br><span class="line">t_xmin      <span class="operator">|</span> <span class="number">766</span></span><br><span class="line">t_xmax      <span class="operator">|</span> <span class="number">0</span></span><br><span class="line">t_field3    <span class="operator">|</span> <span class="number">0</span></span><br><span class="line">t_ctid      <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">t_infomask2 <span class="operator">|</span> <span class="number">2</span></span><br><span class="line">t_infomask  <span class="operator">|</span> <span class="number">2050</span></span><br><span class="line">t_hoff      <span class="operator">|</span> <span class="number">24</span></span><br><span class="line">t_bits      <span class="operator">|</span> </span><br><span class="line">t_oid       <span class="operator">|</span> </span><br><span class="line">t_data      <span class="operator">|</span> \x0100000009464f4f</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">SELECT</span> <span class="string">&#x27;(0,&#x27;</span><span class="operator">||</span>lp<span class="operator">||</span><span class="string">&#x27;)&#x27;</span> <span class="keyword">AS</span> ctid,</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">CASE</span> lp_flags</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;unused&#x27;</span></span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;redirect to &#x27;</span><span class="operator">||</span>lp_off</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">&#x27;dead&#x27;</span> </span><br><span class="line">test<span class="operator">-</span># <span class="keyword">END</span> <span class="keyword">AS</span> state,</span><br><span class="line">test<span class="operator">-</span># t_xmin <span class="keyword">as</span> xmin,</span><br><span class="line">test<span class="operator">-</span># t_xmax <span class="keyword">as</span> xmax,</span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">256</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmin_committed, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">512</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmin_aborted, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">1024</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmax_committed, </span><br><span class="line">test<span class="operator">-</span># (t_infomask <span class="operator">&amp;</span> <span class="number">2048</span>) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> xmax_aborted</span><br><span class="line">test<span class="operator">-</span># <span class="keyword">FROM</span> heap_page_items(get_raw_page(<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>));</span><br><span class="line"> ctid  <span class="operator">|</span> state  <span class="operator">|</span> xmin <span class="operator">|</span> xmax <span class="operator">|</span> xmin_committed <span class="operator">|</span> xmin_aborted <span class="operator">|</span> xmax_committed <span class="operator">|</span> xmax_aborted </span><br><span class="line"><span class="comment">-------+--------+------+------+----------------+--------------+----------------+--------------</span></span><br><span class="line"> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> normal <span class="operator">|</span>  <span class="number">766</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> f              <span class="operator">|</span> f            <span class="operator">|</span> f              <span class="operator">|</span> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<p>Reference:</p>
<p><a href="https://blog.csdn.net/u010217262/article/details/123879205">【转】AntDB&#x2F;PostgreSQL内部原理：表Page结构解析_postgresql对应antdb的版本-CSDN博客</a></p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use pgbench</title>
    <url>/2025/05/14/postgresql/pgbench-md/</url>
    <content><![CDATA[<p>pgbench is a benchmarking tool bundled with PostgreSQL, designed to simulate a TPC-B-like workload, not a full TPC-C</p>
<h2 id="1-Initialize-the-Test-Database"><a href="#1-Initialize-the-Test-Database" class="headerlink" title="1. Initialize the Test Database"></a>1. Initialize the Test Database</h2><p>This sets up the schema and populates data.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -i -s 10 mydb</span><br></pre></td></tr></table></figure>
<ul>
<li>-i: Initialize the database.</li>
<li>-s 10: Scale factor. Each scale unit ~100,000 rows in the pgbench_accounts table.</li>
<li>mydb: The database to test.</li>
</ul>
<h2 id="2-Run-a-Simple-Benchmark-Test"><a href="#2-Run-a-Simple-Benchmark-Test" class="headerlink" title="2. Run a Simple Benchmark Test"></a>2. Run a Simple Benchmark Test</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -c 10 -j 2 -T 60 mydb</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 10: 10 concurrent clients.</li>
<li>-j 2: 2 threads.</li>
<li>-T 60: Run for 60 seconds.</li>
<li>mydb: Target database.</li>
</ul>
<p>It will output something like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[postgres@iZ2ze4mflpfiplp0evcw8gZ root]$ pgbench -c 10 -j 2 -T 60 mydb</span><br><span class="line">pgbench (18devel)</span><br><span class="line">starting vacuum...end.</span><br><span class="line">transaction type: &lt;builtin: TPC-B (sort of)&gt;</span><br><span class="line">scaling factor: 10</span><br><span class="line">query mode: simple</span><br><span class="line">number of clients: 10</span><br><span class="line">number of threads: 2</span><br><span class="line">maximum number of tries: 1</span><br><span class="line">duration: 60 s</span><br><span class="line">number of transactions actually processed: 12841</span><br><span class="line">number of failed transactions: 0 (0.000%)</span><br><span class="line">latency average = 46.726 ms</span><br><span class="line">initial connection time = 39.072 ms</span><br><span class="line">tps = 214.013767 (without initial connection time)</span><br><span class="line">[postgres@iZ2ze4mflpfiplp0evcw8gZ root]$</span><br></pre></td></tr></table></figure>
<h2 id="3-Run-Custom-SQL-Scripts"><a href="#3-Run-Custom-SQL-Scripts" class="headerlink" title="3. Run Custom SQL Scripts"></a>3. Run Custom SQL Scripts</h2><p>You can benchmark with custom SQL transactions:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -f myscript.sql -c 10 -T 60 mydb</span><br></pre></td></tr></table></figure>
<p>Where myscript.sql contains something like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM pgbench_accounts WHERE aid = :aid;</span><br><span class="line">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>Use :variable for substitution. We can define variables using -D:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pgbench -f myscript.sql -D aid=12345 -D delta=50 -c 10 -T 60 mydb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>R-tree for points</title>
    <url>/2025/12/02/postgresql/r-tree-for-points/</url>
    <content><![CDATA[<p>第一个示例涉及在平面上对点（或其他几何形状）进行索引。常规的B树无法用于这种数据类型，因为点没有定义比较运算符。显然，我们可以自己实现这样的运算符，但几何形状需要索引支持完全不同的操作。我将只讨论其中的两种：搜索特定区域内包含的对象和最近邻搜索。</p>
<p>R树在平面上绘制矩形；这些矩形合起来必须覆盖所有被索引的点。一个索引条目存储边界框，谓词可以定义如下：点位于该边界框内。</p>
<p>R树的根节点包含若干个大矩形（这些矩形可能会有重叠）。子节点包含较小的矩形，这些矩形适合其父节点；它们一起覆盖所有底层的点。</p>
<p>叶节点应该包含被索引的点本身，但GiST要求所有条目具有相同的数据类型；因此，叶节点的条目也由矩形表示，这些矩形被简化为点。</p>
<p>为了更好地可视化这种结构，我们来看一个基于机场坐标构建的R树的三个层次。在这个例子中，我已将演示数据库的机场表扩展到五千行。同时我还降低了fillfactor值使树的层次更深。默认值会给我们一个单层树。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> airports_big <span class="keyword">AS</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> airports_data;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">104</span>     </span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">COPY</span> airports_big <span class="keyword">FROM</span> <span class="string">&#x27;/home/postgres/data/extra_airports.copy&#x27;</span>;</span><br><span class="line"><span class="keyword">COPY</span> <span class="number">5413</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX airports_gist_idx <span class="keyword">ON</span> airports_big <span class="keyword">USING</span> gist(coordinates) <span class="keyword">WITH</span> (fillfactor<span class="operator">=</span><span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br></pre></td></tr></table></figure>
<p>在顶层，所有点都被包含在几个（可能部分重叠的）边界框中。</p>
<p>在下一层，大矩形被分割成较小的矩形。</p>
<p>最后，在树的底层，每个边界框包含的点数量与单个页面所能容纳的数量相同。</p>
<p>该索引使用point_ops操作符类，这是点数据唯一可用的操作符类。</p>
<p>矩形和其他几何形状可以以相同的方式进行索引，但索引存储的不是对象本身，而是其边界框。</p>
<h2 id="Page-Layout"><a href="#Page-Layout" class="headerlink" title="Page Layout"></a>Page Layout</h2><p>可以通过 pageinspect 插件来学习Gist页</p>
<p>和B-Tree索引不同，Gist没有metapage，0号page就是gist的root节点。如果root节点分裂了，老root节点会被move到一个（或多个）单独的页，新root节点取代其位置</p>
<p>root页的内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> ctid, keys <span class="keyword">FROM</span> gist_page_items(get_raw_page(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">0</span>), <span class="string">&#x27;airports_gist_idx&#x27;</span> );</span><br><span class="line">    ctid    <span class="operator">|</span>                                               keys                                               </span><br><span class="line"><span class="comment">------------+--------------------------------------------------------------------------------------------------</span></span><br><span class="line"> (<span class="number">1</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-75.47339630130001,-0.12295600026845932),(-179.876998901,-43.810001373291016)&quot;)</span><br><span class="line"> (<span class="number">2</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-62.919601,-0.14835),(-74.9615020752,-54.93109893798828)&quot;)</span><br><span class="line"> (<span class="number">3</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-39.253101348877,-17.652299880981),(-62.1693,-62.1907997131)&quot;)</span><br><span class="line"> (<span class="number">4</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-14.3937,-0.6994310021400452),(-61.8465003967,-16.706899642899998)&quot;)</span><br><span class="line"> (<span class="number">5</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(22.4692001343,-2.7174999713897705),(10.674076080322266,-34.554901123)&quot;)</span><br><span class="line"> (<span class="number">6</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(63.361,-2.3089799880981445),(22.9993000031,-34.0881601675)&quot;)</span><br><span class="line"> (<span class="number">7</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(177.97799682617188,-31.94029998779297),(115.401596069,-46.8997)&quot;)</span><br><span class="line"> (<span class="number">8</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-79.3834991455,28.20170021057129),(-177.38099670410156,0.9785190224647522)&quot;)</span><br><span class="line"> (<span class="number">9</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-51.0722007751,19.96980094909668),(-78.7492,0.0506640002131)&quot;)</span><br><span class="line"> (<span class="number">10</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(128.707992554,-0.06239889934659004),(8.754380226135254,-30.83810043334961)&quot;)</span><br><span class="line"> (<span class="number">11</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(153.56199646,-0.8918330073356628),(130.6199951171875,-31.8885993958)&quot;)</span><br><span class="line"> (<span class="number">12</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(179.951004028,-0.547458),(154.67300415039062,-31.5382995605)&quot;)</span><br><span class="line"> (<span class="number">13</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-153.7039948,71.285402),(-176.64599609375,51.87799835205078)&quot;)</span><br><span class="line"> (<span class="number">14</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-128.576009,70.33080291750001),(-152.621994019,53.25429916379999)&quot;)</span><br><span class="line"> (<span class="number">15</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-104.26300048828125,39.90879822),(-122.8130035,24.072700500499998)&quot;)</span><br><span class="line"> (<span class="number">16</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-91.149597,37.9275016785),(-103.602996826,25.54949951171875)&quot;)</span><br><span class="line"> (<span class="number">17</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-68.36340332030001,31.9512996674),(-90.25800323486328,18.25149917602539)&quot;)</span><br><span class="line"> (<span class="number">18</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-2.269860029220581,31.9475002289),(-67.14849853515625,4.3790202140808105)&quot;)</span><br><span class="line"> (<span class="number">19</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-115.78199768066,63.20940017700195),(-127.36699676513672,40.1506996155)&quot;)</span><br><span class="line"> (<span class="number">20</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-96.6707992553711,62.462799072265625),(-114.903999329,37.649899)&quot;)</span><br><span class="line"> (<span class="number">21</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-83.29579926,37.24570084),(-95.984596252441,32.30059814)&quot;)</span><br><span class="line"> (<span class="number">22</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-83.3467025756836,48.06570053),(-96.38439941,37.74010086)&quot;)</span><br><span class="line"> (<span class="number">23</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-78.31999969,47.697400654599996),(-83.072998,32.00999832)&quot;)</span><br><span class="line"> (<span class="number">24</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-64.67859649658203,47.990799),(-77.98459625,32.36399841308594)&quot;)</span><br><span class="line"> (<span class="number">25</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-74.5280990600586,79.9946975708),(-126.7979965209961,48.0532989502)&quot;)</span><br><span class="line"> (<span class="number">26</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-13.746399879455566,82.51779937740001),(-72.2656021118164,32.697899)&quot;)</span><br><span class="line"> (<span class="number">27</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(25.3379993439,39.828335),(-9.35523,0.0226000007242)&quot;)</span><br><span class="line"> (<span class="number">28</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(1.7605600357100002,48.069499969499994),(-8.68138980865,40.471926)&quot;)</span><br><span class="line"> (<span class="number">29</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(1.954759955406189,62.0635986328125),(-9.653610229492188,48.447898864746094)&quot;)</span><br><span class="line"> (<span class="number">30</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(173.82899475097656,31.3253993988),(27.221700668300002,0.042386)&quot;)</span><br><span class="line"> (<span class="number">31</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(7.8790798,61.583599090576),(2.040833,32.38410186767578)&quot;)</span><br><span class="line"> (<span class="number">32</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(58.890499114990234,31.989853),(32.2400016784668,10.350000381469727)&quot;)</span><br><span class="line"> (<span class="number">33</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(89.4672012329,31.909400939941406),(60.3820991516,8.30148983002)&quot;)</span><br><span class="line"> (<span class="number">34</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(111.63999939,31.4281005859375),(90.30120086669922,8.09912014008)&quot;)</span><br><span class="line"> (<span class="number">35</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(169.852005,31.919701),(113.069999695,8.178509712219238)&quot;)</span><br><span class="line"> (<span class="number">36</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(17.439699172973633,52.59120178222656),(6.504444,32.6635017395)&quot;)</span><br><span class="line"> (<span class="number">37</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(31.1583003998,52.527000427246094),(17.828399658203125,32.096801757799994)&quot;)</span><br><span class="line"> (<span class="number">38</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(30.60810089111328,57.78390121459961),(6.57944011688,53.0475006104)&quot;)</span><br><span class="line"> (<span class="number">39</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(31.044900894165,78.246101379395),(6.0741000175476,58.0994987487793)&quot;)</span><br><span class="line"> (<span class="number">40</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(42.4826011658,61.88520050048828),(31.9197998046875,32.01139831542969)&quot;)</span><br><span class="line"> (<span class="number">41</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(75.634444,63.566898345947266),(43.025978088378906,32.056098938)&quot;)</span><br><span class="line"> (<span class="number">42</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(98.3414,73.51780700683594),(32.75080108642578,32.1)&quot;)</span><br><span class="line"> (<span class="number">43</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(122.853996,71.97810363769531),(100.0989990234375,32.1506)&quot;)</span><br><span class="line"> (<span class="number">44</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(177.74099731445312,71.697700500488),(123.48300170898438,32.482498)&quot;)</span><br><span class="line">(<span class="number">44</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To extract more detailed information, you can use the gevel extension,which is not included into the standard PostgreSQL distribution.</p>
</blockquote>
<h2 id="Operator-Class"><a href="#Operator-Class" class="headerlink" title="Operator Class"></a>Operator Class</h2><p>This query retrieves the list of support functions used by the point_ops operator class in a GiST (Generalized Search Tree) index within a PostgreSQL database</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amprocnum, amproc::regproc</span><br><span class="line"><span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid</span><br><span class="line"><span class="keyword">JOIN</span> pg_amproc amop <span class="keyword">ON</span> amprocfamily <span class="operator">=</span> opcfamily</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amprocnum;</span><br><span class="line"> amprocnum <span class="operator">|</span>         amproc         </span><br><span class="line"><span class="comment">-----------+------------------------</span></span><br><span class="line">         <span class="number">1</span> <span class="operator">|</span> gist_point_consistent</span><br><span class="line">         <span class="number">2</span> <span class="operator">|</span> gist_box_union</span><br><span class="line">         <span class="number">3</span> <span class="operator">|</span> gist_point_compress</span><br><span class="line">         <span class="number">5</span> <span class="operator">|</span> gist_box_penalty</span><br><span class="line">         <span class="number">6</span> <span class="operator">|</span> gist_box_picksplit</span><br><span class="line">         <span class="number">7</span> <span class="operator">|</span> gist_box_same</span><br><span class="line">         <span class="number">8</span> <span class="operator">|</span> gist_point_distance</span><br><span class="line">         <span class="number">9</span> <span class="operator">|</span> gist_point_fetch</span><br><span class="line">        <span class="number">11</span> <span class="operator">|</span> gist_point_sortsupport</span><br><span class="line">(<span class="number">9</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>必需的函数：</p>
<p>1 consistency function used to traverse the tree during search（检查查询条件是否与索引条目一致）</p>
<p>2 union function that merges rectangles计算边界框的并集）</p>
<p>5 penalty function used to choose the subtree to descend to when inserting an entry （计算插入新条目的代价）</p>
<p>6 picksplit function that distributes entries between new pages after a page split（决定节点分裂方式）</p>
<p>7 same function that checks two keys for equality（比较索引条目是否相同）</p>
<p>point_ops 支持的操作符如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, amopstrategy <span class="keyword">AS</span>  st, oprcode::regproc,</span><br><span class="line"><span class="keyword">left</span>(obj_description(opr.oid, <span class="string">&#x27;pg_operator&#x27;</span>),<span class="number">19</span>) description</span><br><span class="line"><span class="keyword">FROM</span> pg_am am</span><br><span class="line">        <span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid </span><br><span class="line">        <span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily </span><br><span class="line">        <span class="keyword">JOIN</span> pg_operator opr <span class="keyword">ON</span> opr.oid <span class="operator">=</span> amopopr</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">      amopopr      <span class="operator">|</span> st <span class="operator">|</span>       oprcode       <span class="operator">|</span>     description     </span><br><span class="line"><span class="comment">-------------------+----+---------------------+---------------------</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span>(point,point)   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> point_left          <span class="operator">|</span> <span class="keyword">is</span> <span class="keyword">left</span> <span class="keyword">of</span></span><br><span class="line"> <span class="operator">&gt;&gt;</span>(point,point)   <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> point_right         <span class="operator">|</span> <span class="keyword">is</span> <span class="keyword">right</span> <span class="keyword">of</span></span><br><span class="line"> <span class="operator">~</span><span class="operator">=</span>(point,point)   <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> point_eq            <span class="operator">|</span> same <span class="keyword">as</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span><span class="operator">|</span>(point,point)  <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> point_below         <span class="operator">|</span> <span class="keyword">is</span> below</span><br><span class="line"> <span class="operator">|</span><span class="operator">&gt;&gt;</span>(point,point)  <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> point_above         <span class="operator">|</span> <span class="keyword">is</span> above</span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span>(point,point)  <span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> point_distance      <span class="operator">|</span> distance <span class="keyword">between</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,box)     <span class="operator">|</span> <span class="number">28</span> <span class="operator">|</span> on_pb               <span class="operator">|</span> point inside box</span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> <span class="number">29</span> <span class="operator">|</span> point_below         <span class="operator">|</span> deprecated, use <span class="operator">&lt;&lt;</span><span class="operator">|</span></span><br><span class="line"> <span class="operator">&gt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> point_above         <span class="operator">|</span> deprecated, use <span class="operator">|</span><span class="operator">&gt;&gt;</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,polygon) <span class="operator">|</span> <span class="number">48</span> <span class="operator">|</span> pt_contained_poly   <span class="operator">|</span> <span class="keyword">is</span> contained <span class="keyword">by</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,circle)  <span class="operator">|</span> <span class="number">68</span> <span class="operator">|</span> pt_contained_circle <span class="operator">|</span> <span class="keyword">is</span> contained <span class="keyword">by</span></span><br><span class="line">(<span class="number">11</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>操作符的名字通常并不能准确反映其语义，因此这个查询还会显示底层函数的名称和它们的描述。无论具体形式如何，这些操作符都处理几何对象之间的相对位置关系（如在左侧、右侧、上方、下方、包含、被包含）以及它们之间的距离。<br>与 B-tree 相比，GiST 提供了更多的策略（strategy）。一些策略号在多种类型的索引中是通用的，而另一些则是通过公式计算出来的（例如，策略号 28、48 和 68 实际上代表相同的策略：对矩形、多边形和圆形来说都是“被包含”）。此外，GiST 还支持一些已经过时的操作符名称（例如 &lt;&lt;| 和 |&gt;&gt;）。<br>一个操作符类（operator class）可能只实现了部分可用的策略。举个例子：点类型的操作符类不支持“包含”这个策略，但这个策略在那些具有可度量面积的几何体操作符类（如 box_ops、poly_ops 和 circle_ops）中是可用的。</p>
<h2 id="Search-for-Contained-Elements"><a href="#Search-for-Contained-Elements" class="headerlink" title="Search for Contained Elements"></a>Search for Contained Elements</h2><p>一个典型的可以通过索引加速的查询是返回指定区域内的所有点。例如，我们来查找距离莫斯科中心一度以内的所有机场：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> airport_code, airport_name<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">WHERE</span> coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.753220),1.0&gt;&#x27;</span>::circle;</span><br><span class="line"> airport_code <span class="operator">|</span>              ?<span class="keyword">column</span>?              </span><br><span class="line"><span class="comment">--------------+------------------------------------</span></span><br><span class="line"> SVO          <span class="operator">|</span> Sheremetyevo International Airport</span><br><span class="line"> VKO          <span class="operator">|</span> Vnukovo International Airport</span><br><span class="line"> DME          <span class="operator">|</span> Domodedovo International Airport</span><br><span class="line"> BKA          <span class="operator">|</span> Bykovo Airport</span><br><span class="line"> ZIA          <span class="operator">|</span> Zhukovsky International Airport</span><br><span class="line"> CKL          <span class="operator">|</span> Chkalovskiy Air Base</span><br><span class="line"> OSF          <span class="operator">|</span> Ostafyevo International Airport</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (costs off) <span class="keyword">SELECT</span> airport_code</span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">WHERE</span> coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.753220),1.0&gt;&#x27;</span>::circle;</span><br><span class="line">                               QUERY PLAN                                </span><br><span class="line"><span class="comment">-------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> airports_big</span><br><span class="line">   Recheck Cond: (coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.75322),1&gt;&#x27;</span>::circle)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> airports_gist_idx</span><br><span class="line">         Index Cond: (coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.75322),1&gt;&#x27;</span>::circle)</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以通过下图所示的一个简单示例来更仔细地查看这个操作符</p>
<p><img src="/images/RTree/rtree1.png" alt="rtree1"></p>
<p>如果以这种方式选择边界框，索引结构将如下所示：</p>
<p><img src="/images/RTree/rtree2.png" alt="rtree2"></p>
<p>包含操作符 &lt;@ 用于判断某个点是否位于指定矩形内部。对于该操作符，其一致性函数（consistency function）会在索引条目的矩形与指定矩形有任何重合点时返回“是”。这意味着，对于叶子节点中的索引条目（它们通常是退化为点的矩形），该函数实际上是在判断这个点是否被指定的矩形所包含。</p>
<p>例如，假设我们要查找位于矩形 (1,2)–(4,7) 内部的点，该矩形在下图中以阴影表示：</p>
<p><img src="/images/RTree/rtree3.png" alt="rtree3"></p>
<p>搜索从根节点开始。目标矩形与索引项 (0,0)–(3,4) 有重叠，但与 (5,3)–(9,9) 没有重叠，这意味着我们不需要进入第二棵子树。<br>在下一层中，目标矩形与 (0,3)–(3,4) 有重叠，并且与 (0,0)–(3,2) 有接触（边界相交），所以我们需要检查这两个子树。<br>一旦到达叶子节点，我们只需遍历它们包含的所有点，并返回那些满足一致性函数的点</p>
<p><img src="/images/RTree/rtree4.png" alt="rtree4"></p>
<p>B-tree 的搜索总是只选择一个子节点进行查找。而 GiST 的搜索可能需要扫描多个子树，特别是当它们的边界框（bounding boxes）发生重叠时。</p>
<h2 id="Nearest-Neighbor-Search"><a href="#Nearest-Neighbor-Search" class="headerlink" title="Nearest Neighbor Search"></a>Nearest Neighbor Search</h2><p>大多数索引支持的操作符（例如上一个例子中的 &#x3D; 或 &lt;@）通常被称为搜索操作符，因为它们在查询中定义了搜索条件。这类操作符是谓词，即它们返回一个逻辑值（真或假）。</p>
<p>但还有一类是排序操作符，它们返回的是参数之间的距离。这类操作符通常用于 ORDER BY 子句中，并且一般由具有 Distance Orderable 属性的索引所支持。该属性允许你快速找到指定数量的最近邻。这种类型的搜索被称为 k-NN（k 最近邻搜索）。</p>
<p>例如，我们可以查找最接近 Kostroma 的 10 个机场：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> airport_code, airport_name<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.926780,57.767943)&#x27;</span>::point LIMIT <span class="number">10</span>;</span><br><span class="line"> airport_code <span class="operator">|</span>                    ?<span class="keyword">column</span>?                    </span><br><span class="line"><span class="comment">--------------+------------------------------------------------</span></span><br><span class="line"> KMW          <span class="operator">|</span> Kostroma Sokerkino Airport</span><br><span class="line"> IAR          <span class="operator">|</span> Tunoshna Airport</span><br><span class="line"> IWA          <span class="operator">|</span> Ivanovo South Airport</span><br><span class="line"> VGD          <span class="operator">|</span> Vologda Airport</span><br><span class="line"> RYB          <span class="operator">|</span> Staroselye Airport</span><br><span class="line"> GOJ          <span class="operator">|</span> Nizhny Novgorod Strigino International Airport</span><br><span class="line"> CEE          <span class="operator">|</span> Cherepovets Airport</span><br><span class="line"> CKL          <span class="operator">|</span> Chkalovskiy Air Base</span><br><span class="line"> ZIA          <span class="operator">|</span> Zhukovsky International Airport</span><br><span class="line"> BKA          <span class="operator">|</span> Bykovo Airport</span><br><span class="line">(<span class="number">10</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (costs off) <span class="keyword">SELECT</span> airport_code</span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.926780,57.767943)&#x27;</span>::point LIMIT <span class="number">5</span>;</span><br><span class="line">                            QUERY PLAN                             </span><br><span class="line"><span class="comment">-------------------------------------------------------------------</span></span><br><span class="line"> Limit</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> airports_gist_idx <span class="keyword">on</span> airports_big</span><br><span class="line">         <span class="keyword">Order</span> <span class="keyword">By</span>: (coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.92678,57.767943)&#x27;</span>::point)</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>由于索引扫描是逐个返回结果，并且可以在任何时刻停止，因此前几个值可以非常快速地获取到。</p>
<p>如果没有索引支持，要实现高效的搜索将非常困难。我们将不得不先查找某个特定区域内的所有点，然后逐步扩大该区域，直到返回所需数量的结果。<br>这将需要多次索引扫描，更不用说还存在一个难题：如何选择初始区域的大小以及每次扩展的增量。</p>
<p>你可以在系统目录中查看操作符的类型（其中 “s” 表示搜索操作符，”o” 表示排序操作符）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, amoppurpose, amopstrategy <span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid</span><br><span class="line"><span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily <span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">      amopopr      <span class="operator">|</span> amoppurpose <span class="operator">|</span> amopstrategy </span><br><span class="line"><span class="comment">-------------------+-------------+--------------</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">1</span></span><br><span class="line"> <span class="operator">&gt;&gt;</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">5</span></span><br><span class="line"> <span class="operator">~</span><span class="operator">=</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">6</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span><span class="operator">|</span>(point,point)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">10</span></span><br><span class="line"> <span class="operator">|</span><span class="operator">&gt;&gt;</span>(point,point)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">11</span></span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span>(point,point)  <span class="operator">|</span> o           <span class="operator">|</span>           <span class="number">15</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,box)     <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">28</span></span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">29</span></span><br><span class="line"> <span class="operator">&gt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">30</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,polygon) <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">48</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,circle)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">68</span></span><br><span class="line">(<span class="number">11</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>为了支持这类查询，操作符类必须定义一个额外的支持函数：也就是距离函数（distance function），它会在索引项上被调用，用于计算该索引项中存储的值与另一个值之间的距离。</p>
<p>对于表示索引值的叶子节点元素，该函数必须返回与该值之间的距离。<br>如果是点（point）类型，这个距离就是常规的欧几里得距离，计算公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = sqrt((x₂-x₁)²+(y₂-y₁)²)</span><br></pre></td></tr></table></figure>

<p>对于一个内部节点，其距离函数必须返回其所有子叶节点中可能距离的最小值。<br>由于扫描所有子节点的条目代价较高，该函数可以乐观地低估这个距离（以牺牲效率为代价），但绝不能返回一个较大的值——否则将会破坏搜索的正确性</p>
<p>因此，对于一个由边界框（bounding box）表示的内部节点，其与某个点之间的距离可以按照常规数学意义来理解：<br>要么是该点到矩形边界的最小距离；要么是 0（如果该点在矩形内部）。<br>这个值可以在无需遍历矩形中所有子点的情况下轻松计算出来，<br>并且它保证不会大于矩形中任意一个子点与该查询点之间的实际距离</p>
<p>我们考虑一下寻离点（6，8）最近的3个值</p>
<p><img src="/images/RTree/rtree5.png" alt="rtree5"></p>
<p>搜索从根节点开始，根节点包含两个边界框（bounding box）。指定查询点到矩形 (0,0)–(3,4) 的距离被计算为到该矩形的角点 (3,4) 的距离，即 5.0。到另一个矩形 (5,3)–(9,9) 的距离为 0.0。（这里我会将所有的距离值四舍五入保留到小数点后一位，这种精度对于这个示例来说已经足够。）</p>
<p>子节点会按照距离增大的顺序被遍历。因此，我们首先进入右子节点，该节点包含两个矩形：(5,3)–(8,5) 和 (6,6)–(9,9)。到第一个矩形的距离是 3.0，到第二个矩形的距离是 0.0。<br>再次地，我们选择右子树，并进入包含三个点的叶子节点：点 (6,6) 的距离为 2.0，点 (8,9) 的距离为 2.2，点 (9,7) 的距离为 3.2。</p>
<p><img src="/images/RTree/rtree6.png" alt="rtree6"></p>
<p>因此，我们已经找到了前两个点：(6,6) 和 (8,9)。但该节点中的第三个点距离（查询点）要大于矩形 (5,3)–(8,5) 的距离。</p>
<p>所以我们需要进入左子节点，该节点包含两个点。到点 (8,5) 的距离是 3.6， 到点 (5,3) 的距离是 5.1。结果发现，之前那个子节点中的点 (9,7) 比左子树中的任何点都更接近查询点 (6,8)，因此我们可以将它作为第三个返回结果。</p>
<p><img src="/images/RTree/rtree7.png" alt="rtree7"></p>
<p>这个例子说明了内部条目的距离函数必须满足的要求。由于到矩形 (5,3)–(8,5) 的距离减小（3.0 而不是 3.6），导致需要额外扫描一个节点，因此搜索效率下降；不过，算法本身仍然是正确的。</p>
<h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>当向 R 树中插入一个新键时，用于存放该键的节点是由penalty函数决定的：该节点的边界框（bounding box）大小应尽可能少地增加。</p>
<p><img src="/images/RTree/rtree8.png" alt="rtree8"></p>
<p>例如，点 (4,7) 将被插入到矩形 (5,3)–(9,9) 中，因为该矩形的面积只需增加 6 个单位；而如果插入到矩形 (0,0)–(3,4)，则其面积需要增加 12 个单位。在下一层（叶子层），该点也会按照相同的逻辑被加入到矩形 (6,6)–(9,9) 中。</p>
<p>假设一个页面最多可以容纳三个元素，那么当超出这个限制时，它必须被拆分成两个页面，<br>并且这些元素需要在新的页面之间重新分配。在这个示例中，分配结果看起来很明显，但在一般情况下，数据的分布并不那么简单。最重要的是，picksplit 函数会尽量减少边界框（bounding box）之间的重叠，目标是获得更小的矩形以及在页面之间均匀分布点。</p>
<p><img src="/images/RTree/rtree9.png" alt="rtree9"></p>
<h2 id="Exclusion-Constraints"><a href="#Exclusion-Constraints" class="headerlink" title="Exclusion Constraints"></a>Exclusion Constraints</h2><p>GiST 索引也可以用于排除约束（exclusion constraints）。排除约束确保：对任意两条堆表元组来说，它们在某些操作符意义下的指定字段不能彼此匹配。要实现这一点，必须满足以下条件：</p>
<ul>
<li>排除约束（exclusion constraint）必须由索引方法本身支持（即具备 Can Exclude 属性）。</li>
<li>所使用的操作符必须属于该索引方法的操作符类（operator class）；</li>
<li>操作符必须是可交换的：即满足 “a operator b &#x3D; b operator a” 这个条件。</li>
</ul>
<p>对于上面提到的 hash 和 btree 访问方法来说，唯一合适的操作符是等于（&#x3D;）。这实际上使排除约束退化成了唯一约束，因而没有太大实际用途</p>
<p>GiST 方法还支持另外两种适用的策略：</p>
<ul>
<li>重叠（overlapping）：由 &amp;&amp; 操作符表示</li>
<li>相邻（adjacency）：由 -|- 操作符表示（该操作符主要用于区间）</li>
</ul>
<p>我们来试试这个功能：创建一个约束，用于禁止机场之间距离太近。<br>这个条件可以这样表达：以机场坐标为圆心、指定半径的圆形不得彼此重叠。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist (circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Moscow&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span>);</span><br><span class="line">ERROR:  conflicting key <span class="keyword">value</span> violates exclusion <span class="keyword">constraint</span> &quot;airports_data_circle_excl&quot;</span><br><span class="line">DETAIL:  Key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">38.1517</span>,<span class="number">55.5533</span>),<span class="number">0.2</span><span class="operator">&gt;</span>) conflicts <span class="keyword">with</span> existing key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">37.90629959106445</span>,<span class="number">55.40879821777344</span>),<span class="number">0.2</span><span class="operator">&gt;</span>).</span><br></pre></td></tr></table></figure>
<p>当定义一个排除约束（exclusion constraint）时，系统会自动创建一个索引来强制执行该约束。在本例中，这个索引是一个基于表达式的 GiST 索引。</p>
<p>我们来看一个更复杂的例子。假设我们允许机场之间距离很近，但前提是这些机场属于同一个城市。一种可行的解决方案是定义一个新的完整性约束，表达如下：如果两个圆（以机场坐标为圆心）发生重叠（&amp;&amp;），且它们对应的城市名称不同（!&#x3D;），则这种情况是不允许的。</p>
<p>尝试创建这样的约束会导致一个错误，因为对于 text 数据类型并没有可用的操作符类（operator class）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> airports_data_circle_excl;</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist ( circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>,</span><br><span class="line">(city<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span>) <span class="keyword">WITH</span> <span class="operator">!=</span></span><br><span class="line">);</span><br><span class="line">ERROR:  data type text has <span class="keyword">no</span> <span class="keyword">default</span> operator class <span class="keyword">for</span> access <span class="keyword">method</span> &quot;gist&quot;</span><br><span class="line">HINT:  You must specify an operator class <span class="keyword">for</span> the index <span class="keyword">or</span> <span class="keyword">define</span> a <span class="keyword">default</span> operator class <span class="keyword">for</span> the data type.</span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure>
<p>虽然 GiST 原生不支持 text 或 int 等有序类型，但借助 btree_gist 扩展，可以让这些类型也具备使用 GiST 进行等值&#x2F;比较操作的能力，从而用于复杂约束（如排除约束）或混合类型索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> EXTENSION btree_gist;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist ( circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>,</span><br><span class="line">(city<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span>) <span class="keyword">WITH</span> <span class="operator">!=</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure>
<p>该约束已成功创建。现在我们无法添加名为 Zhukovsky 的机场（即使它属于同名城市），<br>因为它与莫斯科的几个机场之间的距离太近，违反了约束条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Zhukovsky&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">);</span><br><span class="line">ERROR:  conflicting key <span class="keyword">value</span> violates exclusion <span class="keyword">constraint</span> &quot;airports_data_circle_expr_excl&quot;</span><br><span class="line">DETAIL:  Key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>), (city <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;en&#x27;</span>::text))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">38.1517</span>,<span class="number">55.5533</span>),<span class="number">0.2</span><span class="operator">&gt;</span>, Zhukovsky) conflicts <span class="keyword">with</span> existing key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>), (city <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;en&#x27;</span>::text))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">37.90629959106445</span>,<span class="number">55.40879821777344</span>),<span class="number">0.2</span><span class="operator">&gt;</span>, Moscow).</span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure>
<p>但是我们可以在莫斯科创建机场</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Moscow&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure>
<p>需要注意的是，尽管 GiST 支持大于、小于和等于等操作符，但 B-tree 在这方面效率要高得多，尤其是在访问一段范围值时。因此，只有当确实有其他合理原因需要使用 GiST 索引时，<br>才有意义使用上面提到的 btree_gist 扩展技巧。</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>访问方法属性（Access Method Properties）以下是 GiST 访问方法的属性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> a.amname, p.name, pg_indexam_has_property(a.oid, p.name) </span><br><span class="line"><span class="keyword">FROM</span> pg_am a, <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;can_order&#x27;</span>, <span class="string">&#x27;can_unique&#x27;</span>, <span class="string">&#x27;can_multi_col&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;can_exclude&#x27;</span>, <span class="string">&#x27;can_include&#x27;</span> </span><br><span class="line">]) p(name)</span><br><span class="line"><span class="keyword">WHERE</span> a.amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span>;</span><br><span class="line"> amname <span class="operator">|</span>     name      <span class="operator">|</span> pg_indexam_has_property </span><br><span class="line"><span class="comment">--------+---------------+-------------------------</span></span><br><span class="line"> gist   <span class="operator">|</span> can_order     <span class="operator">|</span> f</span><br><span class="line"> gist   <span class="operator">|</span> can_unique    <span class="operator">|</span> f</span><br><span class="line"> gist   <span class="operator">|</span> can_multi_col <span class="operator">|</span> t</span><br><span class="line"> gist   <span class="operator">|</span> can_exclude   <span class="operator">|</span> t</span><br><span class="line"> gist   <span class="operator">|</span> can_include   <span class="operator">|</span> t</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>GiST 索引不支持唯一约束（Unique constraints）和排序（sorting）。GiST 索引可以通过额外的 INCLUDE 列来创建。正如我们所知，我们可以在多个列上构建索引，也可以将其用于完整性约束（integrity constraints）。</p>
<p>索引级别属性（Index-level properties）。这些属性是在索引层面定义的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, p.name) </span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;clusterable&#x27;</span>, <span class="string">&#x27;index_scan&#x27;</span>, <span class="string">&#x27;bitmap_scan&#x27;</span>, <span class="string">&#x27;backward_scan&#x27;</span> </span><br><span class="line">]) p(name);</span><br><span class="line">     name      <span class="operator">|</span> pg_index_has_property </span><br><span class="line"><span class="comment">---------------+-----------------------</span></span><br><span class="line"> clusterable   <span class="operator">|</span> t</span><br><span class="line"> index_scan    <span class="operator">|</span> t</span><br><span class="line"> bitmap_scan   <span class="operator">|</span> t</span><br><span class="line"> backward_scan <span class="operator">|</span> f</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>GiST 索引可以用于聚簇（clusterization）操作。在数据检索方式方面，GiST 支持常规（逐行）索引扫描和位图扫描（bitmap scan）。但 GiST 不支持反向扫描（backward scanning）。</p>
<p>列级别属性（Column-level properties）：大多数列属性是在访问方法（access method）级别定义的，并且保持不变。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;orderable&#x27;</span>, <span class="string">&#x27;search_array&#x27;</span>, <span class="string">&#x27;search_nulls&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line"> </span><br><span class="line">     name     <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------+------------------------------</span></span><br><span class="line"> orderable    <span class="operator">|</span> f</span><br><span class="line"> search_array <span class="operator">|</span> f</span><br><span class="line"> search_nulls <span class="operator">|</span> t</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>所有与排序相关的属性都是禁用的。</p>
<p>GiST 索引允许 NULL 值存在，但处理效率并不高。一般认为，NULL 值不会扩展边界框（bounding box），所以这些值会被随机插入某个子树中。因此，在查询时需要遍历整棵 GiST 树来查找这些值。</p>
<p>不过，有少数列级属性是依赖于具体操作符类（operator class）的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> t</span><br><span class="line"> distance_orderable <span class="operator">|</span> t</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>
<p>GiST 索引允许执行索引仅扫描（Index-only scan），因为叶子节点中保留了完整的索引键值。</p>
<p>正如前文所述，某些操作符类（operator class）提供了用于最近邻搜索的距离操作符。<br>对于 NULL 值，距离计算结果为 NULL，这种情况下这些值会排在最后返回（类似 B-tree 中的 NULLS LAST 语法）。</p>
<p>然而，对于范围类型（range types）而言，并不存在“距离操作符”（因为它们表示的是线段，也就是线性几何体，而不是面状几何体）。所以，当索引建立在这些类型上时，上述性质会有所不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> reservations(during tsrange);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> reservations <span class="keyword">USING</span> gist(during);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;reservations_during_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> t</span><br><span class="line"> distance_orderable <span class="operator">|</span> f</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol>
<li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li>
</ol>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>pginternal</tag>
      </tags>
  </entry>
  <entry>
    <title>docker compose</title>
    <url>/2023/11/05/tools/docker-compose/</url>
    <content><![CDATA[<h2 id="一-Docker-Compose-是什么"><a href="#一-Docker-Compose-是什么" class="headerlink" title="一. Docker Compose 是什么"></a>一. Docker Compose 是什么</h2><ul>
<li><p>Docker Compose 是 Docker 官方提供的工具，用于定义和管理多容器应用。</p>
</li>
<li><p>它允许你用一个 YAML 文件 描述整个应用的服务（containers）、网络、卷、环境变量等，然后一条命令就能创建、启动、停止、销毁整个应用。</p>
</li>
<li><p>主要目标是 声明式管理 —— 你只写配置文件，Compose 确保容器状态和配置一致。</p>
</li>
</ul>
<p>简单理解：<br>Docker 是管一个容器，Compose 是管理一堆容器的应用。</p>
<h2 id="二-Compose-的核心概念"><a href="#二-Compose-的核心概念" class="headerlink" title="二. Compose 的核心概念"></a>二. Compose 的核心概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Service（服务）</strong></td>
<td>YAML 文件里定义的一个容器，包括镜像、端口、环境变量、卷挂载等。</td>
</tr>
<tr>
<td><strong>Container（容器）</strong></td>
<td>实际运行的 Docker 实例，由 Service 创建。</td>
</tr>
<tr>
<td><strong>Volume（卷）</strong></td>
<td>持久化数据，用宿主机目录或 Docker 卷存储数据库、缓存、照片等。</td>
</tr>
<tr>
<td><strong>Network（网络）</strong></td>
<td>内部容器间通信网络，自动创建，保证服务可以互相访问。</td>
</tr>
<tr>
<td><strong>Project（项目）</strong></td>
<td>一个 Compose 文件及其相关容器、卷、网络的集合，默认用目录名作为项目名。</td>
</tr>
</tbody></table>
<h2 id="三-Compose-文件结构"><a href="#三-Compose-文件结构" class="headerlink" title="三. Compose 文件结构"></a>三. Compose 文件结构</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span>  <span class="comment"># Compose 文件版本</span></span><br><span class="line"><span class="attr">services:</span>       <span class="comment"># 定义服务</span></span><br><span class="line">  <span class="attr">photoprism:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">photoprism/photoprism:latest</span>  <span class="comment"># 镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">photoprism</span>            <span class="comment"># 容器名字</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span>               <span class="comment"># 自动重启策略</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2342:2342&quot;</span>                       <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">environment:</span>                           <span class="comment"># 环境变量</span></span><br><span class="line">      <span class="attr">PHOTOPRISM_ADMIN_PASSWORD:</span> <span class="string">&quot;密码&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span>                               <span class="comment"># 挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;D:/photoprism/originals:/photoprism/originals&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;D:/photoprism/storage:/photoprism/storage&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">dev:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="comment"># deploy.replicas: 3 </span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">gbase</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">2G</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/home/gbase</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/env.list</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-data:/data/app</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/.gdbinit:/home/gbase/.gdbinit</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/.gitconfig:/home/gbase/.gitconfig</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/.git-credentials:/home/gbase/.git-credentials</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mynet</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="attr">net.ipv6.conf.all.disable_ipv6:</span> <span class="number">0</span> </span><br><span class="line">      <span class="attr">net.ipv6.conf.default.disable_ipv6:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nofile:</span> <span class="number">655360</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mynet:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">enable_ipv6:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="string">&quot;fd00:1234:5678::/64&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="string">&quot;172.20.0.0/24&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">app-data:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 普通 Compose:</span><br><span class="line">docker-compose -p gjf up -d --scale dev=3</span><br><span class="line"># Swarm Compose:</span><br><span class="line">docker stack deploy -c docker-compose.yml gjf</span><br><span class="line">deploy.replicas: 3 生效</span><br></pre></td></tr></table></figure>

<h2 id="四-常用命令"><a href="#四-常用命令" class="headerlink" title="四. 常用命令"></a>四. 常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker compose up -d</code></td>
<td>创建并启动服务（后台模式）</td>
</tr>
<tr>
<td><code>docker compose down</code></td>
<td>停止并删除容器、网络（卷可保留）</td>
</tr>
<tr>
<td><code>docker compose stop</code></td>
<td>停止容器，但不删除</td>
</tr>
<tr>
<td><code>docker compose start</code></td>
<td>启动已存在容器</td>
</tr>
<tr>
<td><code>docker compose restart</code></td>
<td>停止 + 启动</td>
</tr>
<tr>
<td><code>docker compose logs -f</code></td>
<td>查看实时日志</td>
</tr>
<tr>
<td><code>docker compose exec &lt;service&gt; &lt;cmd&gt;</code></td>
<td>进入容器执行命令（类似 <code>docker exec</code>）</td>
</tr>
<tr>
<td><code>docker compose ps</code></td>
<td>查看当前项目的容器状态</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2023/12/17/tools/git/</url>
    <content><![CDATA[<ol>
<li>配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Jeffrey&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;jeffreyfly@icloud.com&quot;</span></span><br><span class="line">git config --global pull.rebase <span class="literal">true</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line">git config --global push.default simple</span><br><span class="line">git config --global -l</span><br></pre></td></tr></table></figure></li>
<li>合并提交（本地未push） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add -u</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure></li>
<li>commit 合并</li>
</ol>
<ul>
<li>方法1:  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br><span class="line"></span><br><span class="line">pick abc123 Commit message 1</span><br><span class="line">pick def456 Commit message 2</span><br><span class="line">pick 789abc Commit message 3</span><br></pre></td></tr></table></figure>
  将你想合并的提交改为 squash 或简写 s，保留第一个 pick 不动：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick abc123 Commit message 1</span><br><span class="line">squash def456 Commit message 2</span><br><span class="line">squash 789abc Commit message 3</span><br></pre></td></tr></table></figure>
  保存退出，Git 会让你编辑最终的 commit message，合并或者修改后保存即可。<br>  强行推送：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin your-branch --force-with-lease</span><br></pre></td></tr></table></figure></li>
<li>方法2  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 回到上一次 push 的状态（或者想作为基准的 commit）</span><br><span class="line">git reset --soft origin/your-branch</span><br><span class="line"># 或者 git reset --soft HEAD~N （如果你想数 N 个提交的话）</span><br><span class="line"></span><br><span class="line"># 将所有改动重新提交为一个 commit</span><br><span class="line">git commit -m &quot;合并后的 commit message&quot;</span><br><span class="line"></span><br><span class="line"># 推送到远程（已 push 的分支需要强制）</span><br><span class="line">git push --force-with-lease</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p>忽略所有名为 build 的目录<br>编辑.gitignore 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保留仓库根目录下的 build/README.md</span><br><span class="line">build/</span><br><span class="line">**/build/*.log</span><br><span class="line"></span><br><span class="line">//任意层级 build 目录下的 README.md</span><br><span class="line">build/</span><br><span class="line">!**/build/</span><br><span class="line">!**/build/README.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>rebase</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git rebase origin/main</span><br><span class="line">git add xxx.cpp</span><br><span class="line">git rebase --<span class="built_in">continue</span> / abort</span><br><span class="line">git push --force-with-lease</span><br><span class="line">git push orign &lt;localbranch&gt;:&lt;remotebranch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把文件回退到它的上一次修改</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout $(git log -n 1 --pretty=format:%H -- path/to/file) -- path/to/file</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/05/11/tools/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="about-draft"><a href="#about-draft" class="headerlink" title="about draft"></a>about draft</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;草稿标题&quot;</span><br><span class="line">hexo server --draft</span><br><span class="line">//xxx不带md后缀</span><br><span class="line">hexo publish post xxx </span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>How to use omnigraffle</title>
    <url>/2025/11/04/tools/how-to-use-omnigraffle/</url>
    <content><![CDATA[<p>Here are some tips for using omnigraffle</p>
<h2 id="Draw-curve"><a href="#Draw-curve" class="headerlink" title="Draw curve"></a>Draw curve</h2><ol>
<li>select pen tool: draw custome sharps</li>
<li>Click one point on the canvas, then click another point — a straight line will appear.</li>
<li>Select the line → double-click the middle of the line → drag the new point: a curved effect will appear.</li>
</ol>
<h2 id="Flexible-Control-Over-Line-Arrows"><a href="#Flexible-Control-Over-Line-Arrows" class="headerlink" title="Flexible Control Over Line Arrows"></a>Flexible Control Over Line Arrows</h2><p>When the endpoint of a line (especially an endpoint with an arrow) is connected to a shape, the default mode is <strong>“Connected Line”</strong> (automatic snapping). In this mode, the endpoint is <strong>“locked”</strong> to the shape’s boundary or center, and <strong>cannot be freely dragged</strong>.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li><strong>Turn on Magnets</strong>   <ul>
<li><strong>Select</strong> the target shape.</li>
<li><strong>Menu Bar</strong> → <strong>Edit</strong> → <strong>Magnets</strong> → <strong>Show Magnets</strong></li>
<li>You will see <strong>small red dots</strong> (magnets) appear around the shape.</li>
<li>These are the <strong>connectable positions</strong>.</li>
<li>Drag the <strong>endpoint of a line</strong> near the red dot, and it will <strong>snap&#x2F;attach</strong> to that point.</li>
</ul>
</li>
</ol>
<h2 id="What-is-Magnet"><a href="#What-is-Magnet" class="headerlink" title="What is Magnet?"></a>What is Magnet?</h2><p>Magnet (magnetic points) are those positions on the shape (Shape) that can attract the end points of the lines.<br>When you draw a line with the Line Tool, endpoints that are close to these magnetic points will “snap” to it.</p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p><img src="/./images/page.png" alt="page"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>omnigraffle</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress</title>
    <url>/2025/07/31/tools/wordpress/</url>
    <content><![CDATA[<h2 id="Ubuntu安装wordpress"><a href="#Ubuntu安装wordpress" class="headerlink" title="Ubuntu安装wordpress"></a>Ubuntu安装wordpress</h2><ul>
<li><p>安装apache：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2 -y</span><br><span class="line">chown -R www-data:www-data /var/www/html</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装php</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y php php-mysql php-json</span><br><span class="line">yum install php php-mysqlnd php-json</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install php libapache2-mod-php php-mysql -y</span><br><span class="line">apt install php-cli php-curl php-gd php-mbstring php-xml php-zip -y</span><br></pre></td></tr></table></figure></li>
<li><p>安装database</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y mariadb-server</span><br><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install mysql-server -y</span><br></pre></td></tr></table></figure>
<p>  修改密码：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;12345&#x27;；</span><br><span class="line"></span><br><span class="line">CREATE DATABASE wordpress_db;</span><br><span class="line">CREATE USER &#x27;wp_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">GRANT ALL PRIVILEGES ON wordpress_db.* TO &#x27;wp_user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装wordpress</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/www/html</span><br><span class="line">wget https://wordpress.org/latest.tar.gz </span><br><span class="line">tar -xvzf latest.tar.gz</span><br><span class="line">chown -R www-data:www-data /var/www/html/wordpress</span><br><span class="line">chmod -R 755 /var/www/html/wordpress</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 Apache 默认虚拟主机配置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>
<p>  找到：<br>  DocumentRoot &#x2F;var&#x2F;www&#x2F;html<br>  改成：<br>  DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress</p>
</li>
<li><p>&#x2F;etc&#x2F;apache2&#x2F;apache2.conf 添加：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www/html/wordpress&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<p>  如果你希望支持 WordPress 的 .htaccess 功能，请保留 AllowOverride All</p>
</li>
<li><p>固定连接</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache2ctl -M | grep rewrite</span><br><span class="line">a2enmod rewrite</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>
<p>  在 WordPress 后台重新保存固定链接</p>
</li>
<li><p>重启服务</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
</search>
