<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuantumRealm</title>
  
  
  <link href="https://jeffrey-fly-github-io.pages.dev/atom.xml" rel="self"/>
  
  <link href="https://jeffrey-fly-github-io.pages.dev/"/>
  <updated>2026-02-10T09:04:39.864Z</updated>
  <id>https://jeffrey-fly-github-io.pages.dev/</id>
  
  <author>
    <name>Jeffrey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Running OpenClaw with Docker</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/02/09/tools/How-to-use-openclaw/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/02/09/tools/How-to-use-openclaw/</id>
    <published>2026-02-09T12:28:44.000Z</published>
    <updated>2026-02-10T09:04:39.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><ul><li><strong>Bypass internet restrictions</strong></li><li>Docker Desktop (or Docker Engine) + Docker Compose v2</li><li>Enough disk for images + logs</li></ul><h2 id="Get-code-from-github"><a href="#Get-code-from-github" class="headerlink" title="Get code from github"></a>Get code from github</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openclaw/openclaw.git</span><br></pre></td></tr></table></figure><h2 id="Containerized-Gateway"><a href="#Containerized-Gateway" class="headerlink" title="Containerized Gateway"></a>Containerized Gateway</h2><p>From repo root:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./docker-setup.sh</span><br></pre></td></tr></table></figure><p>This script: </p><ul><li>builds the gateway image</li><li>runs the onboarding wizard</li><li>prints optional provider setup hints</li><li>starts the gateway via Docker Compose</li><li>generates a gateway token and writes it to .env</li></ul><h2 id="Control-UI-token"><a href="#Control-UI-token" class="headerlink" title="Control UI token"></a>Control UI token</h2><p>If you see “unauthorized” or “disconnected (1008): pairing required”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;gateway&quot;: &#123;</span><br><span class="line">    &quot;controlUi&quot;: &#123; &quot;dangerouslyDisableDeviceAuth&quot;: true &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>By default, OpenClaw requires every connecting device to be “paired” (approved by an administrator). Since the Control UI is running in an “insecure” context<br>(HTTP inside Docker), it cannot generate a persistent device identity. Setting allowInsecureAuth: true tells the gateway to trust the Control UI if it provides<br>the correct token, skipping the pairing requirement.</p><h2 id="Install-feishu-plugin"><a href="#Install-feishu-plugin" class="headerlink" title="Install feishu plugin"></a>Install feishu plugin</h2><p>See URL below：<br><a href="https://docs.openclaw.ai/channels/feishu">Feishu</a></p><h2 id="Install-skill"><a href="#Install-skill" class="headerlink" title="Install skill"></a>Install skill</h2><ol><li><p>goto the following site:<br><a href="https://clawhub.ai/skills">https://clawhub.ai/skills</a></p></li><li><p>look for the skill you need. e.g. sonoscli</p></li><li><p>Execute</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx clawhub@latest install sonoscli</span><br></pre></td></tr></table></figure></li></ol><h2 id="Everything-is-ok"><a href="#Everything-is-ok" class="headerlink" title="Everything is ok"></a>Everything is ok</h2><p> <img src="/images/openclaw/feishu.png" alt="FEISHU"></p><h2 id="Some-problems："><a href="#Some-problems：" class="headerlink" title="Some problems："></a>Some problems：</h2><ol><li>“ plugin feishu: duplicate plugin id detected; later plugin may be overridden” <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node@45122743ed12:/app$ find / -name &quot;openclaw.plugin.json&quot; 2&gt;/dev/null | grep feishu   </span><br><span class="line">/home/node/.openclaw/extensions/feishu/openclaw.plugin.json  </span><br><span class="line">/app/extensions/feishu/openclaw.plugin.json</span><br></pre></td></tr></table></figure> You only need one feishu, delete the other one (I deleted the one under .openclaw, and deleting the one under app will cause the container to fail to start)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Requirements&quot;&gt;&lt;a href=&quot;#Requirements&quot; class=&quot;headerlink&quot; title=&quot;Requirements&quot;&gt;&lt;/a&gt;Requirements&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bypass internet </summary>
      
    
    
    
    <category term="tools" scheme="https://jeffrey-fly-github-io.pages.dev/categories/tools/"/>
    
    
    <category term="AI" scheme="https://jeffrey-fly-github-io.pages.dev/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/02/01/database/CAP%E7%90%86%E8%AE%BA/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/02/01/database/CAP%E7%90%86%E8%AE%BA/</id>
    <published>2026-02-01T01:29:33.000Z</published>
    <updated>2026-02-10T01:38:10.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAP 定理指出，在分布式系统中，系统只能在以下三个属性中同时保证两个：</p><p><strong>一致性（Consistency，C）</strong>：所有节点看到相同的数据。对任一节点的写入操作，其后的所有读取都会返回更新后的值。</p><p><strong>可用性（Availability，A）</strong>：每个发给非故障节点的请求都会得到响应，但不保证响应包含最新数据。</p><p><strong>分区容错性（Partition Tolerance，P）</strong>：即使节点间发生网络分区或消息丢失，系统仍能继续运行。</p><p>在理想情况下（网络永不中断），可以同时拥有 C 和 A。但在实际环境中，网络延迟或中断不可避免，因此 P 通常被视为默认前提。真正的取舍在于 A 与 C：当网络分区发生时，是优先保证一致性，还是优先保证可用性？</p><p><img src="/images/cap/CAP.png" alt="CAP"></p><h2 id="一致性优先场景"><a href="#一致性优先场景" class="headerlink" title="一致性优先场景"></a>一致性优先场景</h2><ul><li><p>票务系统（如 12306）：若两个用户同时预订同一座位，系统必须确保只有一个用户成功，以避免重复分配。</p></li><li><p>账户余额：扣款成功后，用户在任何终端查询余额都应反映扣款后的最新结果</p></li></ul><h2 id="可用性优先场景"><a href="#可用性优先场景" class="headerlink" title="可用性优先场景"></a>可用性优先场景</h2><ul><li><p>社交媒体：用户更新个人信息后，短时间内其他用户可能仍看到旧信息，但系统不会返回错误。</p></li><li><p>OLAP 系统：处理海量报表数据时，由于同步延迟，系统可能无法实时反映最新写入，但仍能提供历史数据查询，保证系统可用性。</p></li></ul><h2 id="一致性的补充说明"><a href="#一致性的补充说明" class="headerlink" title="一致性的补充说明"></a>一致性的补充说明</h2><p>CAP 定理中所指的一致性通常是强一致性，即所有读取操作都反映最新写入。除此之外，还有其他一致性模型：</p><h3 id="强一致性（Strong-Consistency）"><a href="#强一致性（Strong-Consistency）" class="headerlink" title="强一致性（Strong Consistency）"></a>强一致性（Strong Consistency）</h3><p>所有读取均返回最新写入的数据，开销较大，但对银行账户等需要绝对准确性的系统至关重要。</p><h3 id="因果一致性（Causal-Consistency）"><a href="#因果一致性（Causal-Consistency）" class="headerlink" title="因果一致性（Causal Consistency）"></a>因果一致性（Causal Consistency）</h3><ul><li>保证具有因果关系的操作顺序一致，但允许无因果关系的操作顺序不同。</li><li>因果相关操作：如用户先发帖，再有回复，系统保证先看到发帖再看到回复。</li><li>并发无关操作：如不同用户同时点赞不同帖子，其顺序可以在各节点不同。</li></ul><p><strong>特殊实现</strong><br>读己所写（Read-Your-Own-Writes Consistency）：用户在同一会话中总能立即看到自己提交的更新。常用于社交媒体。</p><h3 id="最终一致性（Eventual-Consistency）："><a href="#最终一致性（Eventual-Consistency）：" class="headerlink" title="最终一致性（Eventual Consistency）："></a>最终一致性（Eventual Consistency）：</h3><p>系统在经过一段时间后最终达到一致状态，但短期内可能存在不一致数据。典型应用：ClickHouse、分布式缓存等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;CAP 定理指出，在分布式系统中，系统只能在以下三个属性中同时保证两个：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency，C）</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>Files_in_Clickhouse</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/01/20/database/Files-in-Clickhouse/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/01/20/database/Files-in-Clickhouse/</id>
    <published>2026-01-20T02:57:54.000Z</published>
    <updated>2026-02-10T06:33:01.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理结构图"><a href="#物理结构图" class="headerlink" title="物理结构图"></a>物理结构图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">primary.idx</span><br><span class="line"> ├─ entry 0  -&gt; granule 0</span><br><span class="line"> ├─ entry 1  -&gt; granule 1</span><br><span class="line"> └─ ...</span><br><span class="line"></span><br><span class="line">column.mrk4 (per column)</span><br><span class="line"> ├─ mark 0 -&gt; (compressed_offset, decompressed_offset) of granule 0</span><br><span class="line"> ├─ mark 1 -&gt; (compressed_offset, decompressed_offset) of granule 1</span><br><span class="line"> └─ ...</span><br><span class="line"></span><br><span class="line">data.bin</span><br><span class="line"> ├─ compressed block A</span><br><span class="line"> │    ├─ granule 0</span><br><span class="line"> │    └─ granule 1</span><br><span class="line"> ├─ compressed block B</span><br><span class="line"> │    └─ granule 2</span><br><span class="line"> └─ ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="primary-idx-primary-cidx（主键稀疏索引）"><a href="#primary-idx-primary-cidx（主键稀疏索引）" class="headerlink" title="primary.idx &#x2F; primary.cidx（主键稀疏索引）"></a>primary.idx &#x2F; primary.cidx（主键稀疏索引）</h3><p>主键索引文件，用于按 granule 粒度 进行范围裁剪（range pruning）。</p><p><strong>索引项（entry）生成规则</strong></p><ul><li><p>每当形成一个新的 granule，就会在 primary 索引中生成一个 entry</p></li><li><p>granule 的边界由以下两个条件之一触发（OR 关系）：</p><ul><li>行数达到 index_granularity（默认 8192 行）</li><li>ranule 内累计的 解压后数据大小 达到 index_granularity_bytes（通常约 10MB）</li></ul><p>  重要说明  </p><ul><li>granule 的行数是 上限约束，并非固定值</li><li>当 10MB 条件先触发时，一个 granule 的行数可能 明显小于 8192</li><li>primary 索引是 稀疏索引，只定位到 granule，而非单行</li></ul></li></ul><h3 id="column-mrk-column-mrk4（列级定位信息）"><a href="#column-mrk-column-mrk4（列级定位信息）" class="headerlink" title="column.mrk &#x2F; column.mrk4（列级定位信息）"></a>column.mrk &#x2F; column.mrk4（列级定位信息）</h3><p>对于 每一列，都有一个对应的 mark 文件，用于描述 每个 granule 在该列数据文件中的物理位置。</p><p><strong>mark 的数量关系</strong><br>每个 data part 中：primary.idx 中有多少个 entry，每个列的 .mrk &#x2F; .mrk4 文件中就有多少个 mark。二者在 granule 维度上 一一对应  </p><p>每个 mark 的内容<br>每个 mark 是一对偏移量：<br><strong>compressed_offset</strong> ：granule 所在压缩块在 .bin 文件中的起始字节偏移<br><strong>decompressed_offset</strong>：压缩块解压到内存后，该 granule 在解压后内存块中的起始字节偏移</p><p><strong>补充说明</strong><br>decompressed_offset 是 内存语义，不是磁盘语义。当一个压缩块只包含一个 granule 时，该值通常为 0；当一个压缩块包含多个 granule 时：第一个 granule 的 decompressed_offset &#x3D; 0；后续 granule 的 decompressed_offset 为其在解压后内存块中的字节偏移</p><h3 id="data-bin（列数据文件）"><a href="#data-bin（列数据文件）" class="headerlink" title="data.bin（列数据文件）"></a>data.bin（列数据文件）</h3><p><strong>物理结构</strong></p><p>data.bin 由多个 压缩块（compressed blocks） 顺序组成</p><p><strong>每个压缩块包含：</strong><br>1 个或多个完整 granule；任何一个 granule 都不会跨越压缩块边界</p><p><strong>关系约束</strong><br>一个 granule：必然完全位于某一个压缩块中；一个压缩块：可以包含多个 granule（取决于 granule 大小与压缩策略）</p><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><ol><li><p>columns.txt：描述本 part 中：列名、列类型、列顺序</p></li><li><p>columns_substreams.txt：<br> 描述每个列的 子流（substream）布局。特别是：</p><ul><li>Nullable</li><li>Array</li><li>LowCardinality</li><li>Map</li></ul><p> 决定：一个逻辑列拆成几个 .bin &#x2F; .mrk</p></li><li><p>checksums.txt：记录本 part 中 每个文件的校验和与大小</p></li><li><p>count.txt：记录该 part 中的 行数，相当于 part 级的 “统计元数据”</p></li><li><p>serialization.json：描述 列的序列化 &#x2F; 反序列化方式</p></li><li><p>default_compression_codec.txt：记录该 part 使用的默认压缩算法（如 LZ4、ZSTD）</p></li><li><p>metadata_version.txt:表示该 part 的 metadata 版本</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理结构图&quot;&gt;&lt;a href=&quot;#物理结构图&quot; class=&quot;headerlink&quot; title=&quot;物理结构图&quot;&gt;&lt;/a&gt;物理结构图&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
    <category term="clickhouse" scheme="https://jeffrey-fly-github-io.pages.dev/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>B-Tree vs LSMTree</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/01/16/database/BTree-vs-LSMTree/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/01/16/database/BTree-vs-LSMTree/</id>
    <published>2026-01-16T02:38:58.000Z</published>
    <updated>2026-01-19T05:58:00.155Z</updated>
    
    <content type="html"><![CDATA[<p>B-tree 和 LSM-tree 是数据密集型应用中用于组织和存储数据最广泛的两种数据结构。然而，两者各有优劣。本文旨在通过定量分析的方法对这两种数据结构进行对比。</p><h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h2><p>通常情况下，衡量数据结构性能有三个关键指标：写放大（Write Amplification）、读放大（Read Amplification）和空间放大（Space Amplification）。本节旨在对这些指标进行描述。</p><p>对于机械硬盘（HDD）而言，磁盘寻道成本极高，导致随机读写的性能远不如顺序读写。本文假设使用的是闪存存储（如 SSD），因此我们可以忽略磁盘寻道的成本。</p><h2 id="写放大（Write-Amplification）"><a href="#写放大（Write-Amplification）" class="headerlink" title="写放大（Write Amplification）"></a>写放大（Write Amplification）</h2><p>写放大（Write Amplification）是指写入存储设备的实际数据量与写入数据库的数据量之比。</p><p>例如，如果你向数据库写入了 10 MB 数据，但观察到磁盘实际产生了 30 MB 的写入量（或观测到磁盘写入带宽是数据库写入带宽的 3 倍），那么写放大就是 3</p><h2 id="读放大（Read-Amplification）"><a href="#读放大（Read-Amplification）" class="headerlink" title="读放大（Read Amplification）"></a>读放大（Read Amplification）</h2><p>读放大（Read Amplification）是指每次查询所需的磁盘读取次数。</p><p>例如，如果为了响应一个查询需要读取 5 个页面，那么读放大就是 5。</p><p>请注意，写放大与读放大的单位是不同的。写放大衡量的是实际写入数据量与应用程序预期写入量之间的倍数关系；而读放大计算的是执行一次查询所需的磁盘读取次数。</p><p>读放大针对点查询（Point Query）和范围查询（Range Query）有不同的定义。对于范围查询，范围的长度（即需要获取的行数）是一个重要因素。</p><p>缓存是影响读放大的关键因素。例如，对于冷缓存（Cold-cache）情况下的 B 树，一次点查询需要 O(log_B N)次磁盘读取；而在热缓存（Warm-cache）情况下，B 树的内部节点已被缓存，因此每次查询最多只需要一次磁盘读取。</p><blockquote><p>N：数据库中 记录（keys &#x2F; tuples）的总数量<br>B：一个磁盘页（page &#x2F; block）能容纳的 key 数量</p></blockquote><h2 id="空间放大（Space-Amplification）"><a href="#空间放大（Space-Amplification）" class="headerlink" title="空间放大（Space Amplification）"></a>空间放大（Space Amplification）</h2><p>空间放大（Space Amplification）是指存储设备上占用的实际数据量与数据库中存储的逻辑数据量之比。</p><p>例如，如果您向数据库存入 10 MB 的数据，而该数据库在磁盘上占用了 100 MB，那么空间放大倍数就是 10。</p><p>通常来说，一种数据结构最多只能在读、写和空间放大这三个指标中优化其中的两个。这意味着一种数据结构很难在所有三个指标上都优于另一种。例如，B 树的读放大比 LSM 树小，而 LSM 树的写放大则比 B 树小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>B 树是二叉搜索树（Binary Search Tree）的一种推广，其节点可以拥有两个以上的子节点。B 树中有两类节点：内部节点（Internal nodes）和叶子节点（Leaf nodes）。叶子节点包含实际的数据记录且没有子节点；而内部节点可以在预定义的范围内拥有不同数量的子节点。内部节点可以进行合并或分裂。图 1 展示了一个 B 树的示例。</p><blockquote><p>图 1。根节点位于树的顶部，在本例中恰好包含一个枢轴键（Pivot keys）（20），这表示键值为 k 且满足 k &lt;&#x3D; 20 的记录存储在第一个子节点中，而键值满足 k &gt; 20 的记录存储在第二个子节点中。第一个子节点包含两个枢轴键（11 和 15），这表示键值满足 k &lt;&#x3D; 11 的记录存储在第一个（孙子）节点中，满足 11 &lt; k &lt;&#x3D; 15 的记录存储在第二个节点中，而满足 k &gt; 15 的记录则存储在第三个节点中。最左侧的叶子节点包含三个数值（3、5 和 7）。</p></blockquote><p>“B 树”一词可以指代一种特定的设计，也可以指代一类通用的设计。从狭义上讲，B 树在其内部节点中存储键（Keys），但并不一定在叶子节点的记录中重复存储这些键。B+ 树（B+ tree）是 B 树最著名的变体之一。B+ 树的核心理念是：内部节点仅包含键，且在底部增加了一个包含实际数值的额外层级，该层级的叶子节点相互连接。</p><p>与其他搜索树一样，LSM 树（LSM-tree）也包含键值对（Key-value pairs）。它将数据维护在两个或多个独立的组件中（有时被称为 SSTables），每个组件都针对其对应的底层存储介质进行了优化。低层组件中的数据会以批处理的方式高效地与高层组件中的数据进行合并。图 2 展示了一个 LSM 树的示例。</p><blockquote><p>图 2。LSM 树包含 $k$ 个组件。数据首先进入 $C_0$ 层，随后被合并到 $C_1$ 层。最终，$C_1$ 层的数据会被合并到 $C_2$ 层，以此类推。</p></blockquote><p>LSM 树会定期执行合并（Compaction）操作，将多个 SSTable 合并为一个仅包含“活跃数据”（Live data）的新 SSTable。合并操作有助于 LSM 树回收空间并降低读放大。合并策略主要有两种：大小分级合并策略（STCS）和层级合并策略（LBCS）。STCS 的核心思想是：当 LSM 树积累了足够的短小 SSTable 时，将其合并为中等大小的 SSTable；当中等 SSTable 足够多时，再将其合并为大型 SSTable。而 LBCS 的核心思想是将数据组织进不同的层级（Level），每个层级包含一个有序序列（Sorted run）。一旦某一层积累了足够的数据，该层级的部分数据就会被合并到更高层级中。</p><p>本文讨论 B+ 树和基于层级的（Level-Based）LSM 树的写放大与读放大。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>在 B+ 树中，键（Keys）的副本存储在内部节点中；键与记录（Records）存储在叶子节点中；此外，叶子节点可能还包含指向下一个叶子节点的指针，以提高顺序访问性能。</p><p>为了简化分析，假设树的块大小（Block size）为 $B$（以字节为单位），且键、指针和记录的大小都是固定的，因此每个内部节点包含 $O(B)$ 个子节点，每个叶子节点包含 $O(B)$ 条数据记录。（根节点是一个特例，在某些情况下可能几乎为空。）在上述所有假设下，B+ 树的深度为：$$O(\log_B \frac{N}{B})$$其中 $N$ 是数据库的总大小。</p><p><strong>写放大 (Write Amplification)</strong><br>在最坏情况的插入负载下，每次插入都需要重写包含该记录的整个叶子块，因此写放大为 $B$。</p><p><strong>读放大 (Read Amplification)</strong><br>每次查询的磁盘读取次数最多为 $O(\log_B \frac{N}{B})$，即树的深度</p><h3 id="Level-Based-LSM-tree"><a href="#Level-Based-LSM-tree" class="headerlink" title="Level-Based LSM-tree"></a>Level-Based LSM-tree</h3><p>在基于层级的（Level-based）LSM 树中，数据按层组织。每一层包含一个有序序列。数据始于第 0 层（Level 0），随后被合并到第 1 层的序列中。最终，第 1 层的数据会被合并到第 2 层，以此类推。每一层的大小都受到限制。增长因子（Growth factor） $k$ 定义为每一层数据容量的放大倍数：</p><p>$$\text{level}<em>i &#x3D; \text{level}</em>{i-1} \times k$$</p><p>我们可以对基于层级的 LSM 树进行如下分析：如果增长因子为 $k$，且最小的层级是一个大小为 $B$ 的单个文件，那么层级的数量为：</p><p>$$\Theta(\log_k N&#x2F;B)$$</p><p>其中 $N$ 是数据库的大小。为了简化分析，我们假设数据库规模稳定且随时间增长缓慢，因此数据库的总大小几乎等同于最后一层的大小。</p><p><strong>写放大 (Write Amplification)</strong><br>数据必须从每一层移出一次，但给定层级的数据会与来自前一层的数据不断重复合并。平均而言，每个数据项在首次写入某一层后，会被重新合并回同一层约 $k&#x2F;2$ 次。因此，总的写放大为：$$\Theta(k \times \log_k N&#x2F;B)$$</p><p><strong>读放大 (Read Amplification)</strong> 在冷缓存情况下执行短范围查询时，我们必须在每个层级上进行二分查找。  </p><p>对于最高层级 $\text{level}_i$，数据大小为 $O(N)$，因此执行 $O(\log N&#x2F;B)$ 次磁盘读取。</p><p>对于上一层级 $\text{level}_{i-1}$，数据大小为 $O(N&#x2F;k)$，执行 $O(\log (N&#x2F;kB))$ 次磁盘读取。</p><p>对于 $\text{level}_{i-2}$ 层，数据大小为 $O(N&#x2F;k^2)$，执行 $O(\log (N&#x2F;k^2B))$ 次磁盘读取。</p><p>……</p><p>以此类推。</p><p>因此，磁盘读取的总次数为：$$R &#x3D; O(\log N&#x2F;B) + O(\log (N&#x2F;kB)) + O(\log (N&#x2F;k^2B)) + \dots + 1 &#x3D; O(\frac{\log^2 N&#x2F;B}{\log k})$$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表总结了各种放大指标：</p><table><thead><tr><th>数据结构</th><th>写放大 (Write Amplification)</th><th>读放大 (Read Amplification)</th></tr></thead><tbody><tr><td>B+ 树</td><td>Θ(B)</td><td>O(logB​N&#x2F;B)</td></tr><tr><td>层级 LSM 树</td><td>Θ(klogk​N&#x2F;B)</td><td>Θ(logklog2N&#x2F;B​)</td></tr></tbody></table><p>通过对比 B+ 树与基于层级的 LSM 树的各种放大指标，我们可以得出结论：基于层级的 LSM 树在写入性能上优于 B+ 树，但在读取性能上则逊于 B+ 树。TiKV 选用 LSM 树而非 B 树作为其底层存储引擎的主要原因在于：利用缓存技术来提升读取性能，要比提升写入性能容易得多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;B-tree 和 LSM-tree 是数据密集型应用中用于组织和存储数据最广泛的两种数据结构。然而，两者各有优劣。本文旨在通过定量分析的方法对这两种数据结构进行对比。&lt;/p&gt;
&lt;h2 id=&quot;衡量指标&quot;&gt;&lt;a href=&quot;#衡量指标&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>How to use pg_stat_statements extension</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/01/12/postgresql/how-to-use-pg-stat-statements-extension/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/01/12/postgresql/how-to-use-pg-stat-statements-extension/</id>
    <published>2026-01-12T02:33:28.000Z</published>
    <updated>2026-01-12T01:16:20.771Z</updated>
    
    <content type="html"><![CDATA[<p>pg_stat_statements 不能像 pageinspect 那样只靠 CREATE EXTENSION 就用，原因在于它们在 PostgreSQL 内核中的“级别”完全不同。</p><p>pg_stat_statements 和 pageinspect 的定位完全不同：它是一个 全局统计模块<br>它需要：</p><ol><li>拦截每一条 SQL 的执行<ul><li>使用 executor hooks</li><li>在 query 开始 &#x2F; 结束时采样</li></ul></li><li>shared memory 中维护全局 hash 表<ul><li>跨 backend 共享</li><li>保存长期累计统计</li></ul></li><li>在 backend 启动阶段完成初始化<ul><li>分配 shared memory</li><li>注册 hooks</li></ul></li></ol><p>这些事情 只能在 postmaster 启动时完成。</p><h2 id="启动步骤"><a href="#启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h2><ol><li>修改 postgresql.conf<br> 确认conf位置 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gujinfei=# show config_file;</span><br><span class="line">            config_file</span><br><span class="line">---------------------------------------</span><br><span class="line">/home/gujinfei/pgdata/postgresql.conf</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_preload_libraries = &#x27;pg_stat_statements&#x27;</span><br></pre></td></tr></table></figure></li><li>reboot database <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl restart</span><br></pre></td></tr></table></figure></li><li>进入sql <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> shared_preload_libraries;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION pg_stat_statements;</span><br></pre></td></tr></table></figure></li><li>Test <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t;</span><br><span class="line"><span class="keyword">create table</span> t(a text, b text, c <span class="type">int</span>);</span><br><span class="line"><span class="keyword">SELECT</span> pg_stat_statements_reset() <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AS</span> t;</span><br><span class="line">explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br><span class="line">explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> b;</span><br><span class="line">explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> c;</span><br><span class="line"><span class="keyword">SELECT</span> calls, <span class="keyword">rows</span>, query <span class="keyword">FROM</span> pg_stat_statements <span class="keyword">ORDER</span> <span class="keyword">BY</span> query <span class="keyword">COLLATE</span> &quot;C&quot;;</span><br></pre></td></tr></table></figure> result <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">gujinfei<span class="operator">=</span># <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">gujinfei<span class="operator">=</span># <span class="keyword">create table</span> t(a text, b text, c <span class="type">int</span>);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">gujinfei<span class="operator">=</span># <span class="keyword">SELECT</span> pg_stat_statements_reset() <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AS</span> t;</span><br><span class="line">t</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">gujinfei<span class="operator">=</span># explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br><span class="line">            QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line">HashAggregate</span><br><span class="line">Output: <span class="built_in">count</span>(<span class="operator">*</span>), a</span><br><span class="line"><span class="keyword">Group</span> Key: t.a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> public.t</span><br><span class="line">        Output: a, b, c</span><br><span class="line">Query Identifier: <span class="number">8735661759096201363</span></span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">gujinfei<span class="operator">=</span># explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> b;</span><br><span class="line">            QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line">HashAggregate</span><br><span class="line">Output: <span class="built_in">count</span>(<span class="operator">*</span>), b</span><br><span class="line"><span class="keyword">Group</span> Key: t.b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> public.t</span><br><span class="line">        Output: a, b, c</span><br><span class="line">Query Identifier: <span class="number">8735661759096201363</span></span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">gujinfei<span class="operator">=</span># explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> c;</span><br><span class="line">            QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line">HashAggregate</span><br><span class="line">Output: <span class="built_in">count</span>(<span class="operator">*</span>), c</span><br><span class="line"><span class="keyword">Group</span> Key: t.c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> public.t</span><br><span class="line">        Output: a, b, c</span><br><span class="line">Query Identifier: <span class="number">9219356609107396553</span></span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">gujinfei<span class="operator">=</span># <span class="keyword">SELECT</span> calls, <span class="keyword">rows</span>, query <span class="keyword">FROM</span> pg_stat_statements <span class="keyword">ORDER</span> <span class="keyword">BY</span> query <span class="keyword">COLLATE</span> &quot;C&quot;;</span><br><span class="line">calls <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span>                             query</span><br><span class="line"><span class="comment">-------+------+---------------------------------------------------------------</span></span><br><span class="line">    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">SELECT</span> pg_stat_statements_reset() <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AS</span> t</span><br><span class="line">    <span class="number">2</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a</span><br><span class="line">    <span class="number">1</span> <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> explain(costs off, verbose) <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> c</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">gujinfei<span class="operator">=</span>#</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;pg_stat_statements 不能像 pageinspect 那样只靠 CREATE EXTENSION 就用，原因在于它们在 PostgreSQL 内核中的“级别”完全不同。&lt;/p&gt;
&lt;p&gt;pg_stat_statements 和 pageinspect 的定位完</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/01/11/database/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/01/11/database/%E4%B8%80%E8%87%B4%E6%80%A7hash/</id>
    <published>2026-01-11T11:46:58.000Z</published>
    <updated>2026-01-12T01:12:42.747Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式数据库中，一行数据最终会被写入哪一台机器，取决于系统所采用的数据分布策略。在使用分布键（distribution key）的场景下，这一过程通常由哈希计算精确映射完成。</p><p>这个映射过程通常从一个 <strong>distribution key（分布键）</strong> 开始，经由哈希函数，最终落到某一个具体的数据节点上。</p><p>看似简单的映射关系，在系统扩容或缩容时，却会成为分布式系统设计中的一个核心难题。一致性 Hash，正是为了解决这个问题而出现的。</p><hr><h2 id="从一个分布式表说起"><a href="#从一个分布式表说起" class="headerlink" title="从一个分布式表说起"></a>从一个分布式表说起</h2><p>以一个分布式数据库中的表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">bigint</span>,</span><br><span class="line">    user_id <span class="type">bigint</span>,</span><br><span class="line">    payload jsonb</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> create_distributed_table(<span class="string">&#x27;orders&#x27;</span>, <span class="string">&#x27;user_id&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>user_id</code> 被指定为 <strong>distribution key</strong></li><li>数据库会对 <code>user_id</code> 计算哈希值</li><li>哈希值先映射到某个 <strong>shard</strong></li><li>shard 再映射到具体的 <strong>database node</strong><br>（shard -&gt; databasenode, 在本文后续省略，直接表示为 数据节点id，即database n）</li></ul><p>从这一刻开始，<code>user_id</code> 就决定了这行数据在物理层面“住在哪里”。</p><hr><h2 id="最直观的方案：取模-Hash"><a href="#最直观的方案：取模-Hash" class="headerlink" title="最直观的方案：取模 Hash"></a>最直观的方案：取模 Hash</h2><p>在多数据节点之间，最容易想到的一种数据分布方式是<strong>取模 Hash</strong>。</p><p>其基本思路非常直接：</p><ol><li>对 <code>user_id</code> 计算哈希值</li><li>用哈希值对数据库节点数量取模</li><li>取模结果即为目标数据库节点</li></ol><p>示意图如下：</p><p><img src="/images/hash/hash1.png" alt="hash1"></p><p>对应的算法可以表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database_id = <span class="built_in">hash</span>(user_id) % num_of_dbs</span><br></pre></td></tr></table></figure><p>比如，当数据库集群拥有3个数据节点：</p><p>假设：<br>hash(123) &#x3D; 7<br>hash(456) &#x3D; 12<br>hash(789) &#x3D; 5</p><p>则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user id：123 → 7 % 3  = 1 → Database 1</span><br><span class="line">user id：456 → 12 % 3 = 0 → Database 0</span><br><span class="line">user id：789 → 5 % 3  = 2 → Database 2</span><br></pre></td></tr></table></figure><p>在数据节点数量固定的前提下，这种方式能够较为均匀地分布数据，实现也非常简单。</p><p>但问题很快就会出现。</p><hr><h2 id="问题一：扩容几乎等于“重来一遍”"><a href="#问题一：扩容几乎等于“重来一遍”" class="headerlink" title="问题一：扩容几乎等于“重来一遍”"></a>问题一：扩容几乎等于“重来一遍”</h2><p>随着业务增长，3 台数据节点已经无法承载当前数据量，需要扩容到 4 台。</p><p>算法随之变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database_id = <span class="built_in">hash</span>(user_id) % <span class="number">4</span></span><br></pre></td></tr></table></figure><p>对于<strong>新写入的数据</strong>来说，这个变化影响不大。但对于<strong>已有数据</strong>而言，情况就完全不同了。</p><p>由于取模基数发生变化，几乎所有 <code>user_id</code> 的映射结果都会改变，意味着：</p><blockquote><p><strong>存量数据需要在节点之间进行大规模重分布。</strong></p></blockquote><p>示意如下：</p><p><img src="/images/hash/hash2.png" alt="hash2"></p><p>例如，用户 <code>123</code> 过去映射到 Database 1，但现在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(123) % 4 = 3 （即：7%4）</span><br></pre></td></tr></table></figure><p>这行数据必须从Database 1迁移到 Database 3。</p><p>这种迁移不是个别现象，而是系统性问题，代价极其高昂。</p><blockquote><p>对于取模 Hash，当节点从 n 变为 n+1 时，数据迁移率约为 n&#x2F;(n+1)。这意味着如果从 9 台扩容到 10 台，会有 90% 的数据需要搬家</p></blockquote><hr><h2 id="问题二：缩容同样不可接受"><a href="#问题二：缩容同样不可接受" class="headerlink" title="问题二：缩容同样不可接受"></a>问题二：缩容同样不可接受</h2><p>缩容的情况并不会更好。</p><p>当某个节点被下线时，取模 Hash 同样会导致大规模数据重新分布，带来：</p><ul><li>大量数据迁移</li><li>IO 抖动</li><li>服务不稳定</li></ul><p>问题的本质在于：</p><blockquote><p><strong>节点数量一旦发生变化，整个哈希空间的映射关系就被彻底打乱。</strong></p></blockquote><p>为了解决这一问题，我们需要一种在节点变化时“尽量少动数据”的方案。</p><hr><h2 id="一致性-Hash-的核心思想"><a href="#一致性-Hash-的核心思想" class="headerlink" title="一致性 Hash 的核心思想"></a>一致性 Hash 的核心思想</h2><p>一致性 Hash 的目标很明确：</p><blockquote><p>在添加或删除节点时，尽可能减少需要重新分布的数据量。</p></blockquote><p>其基本做法是：</p><ol><li>将整个哈希值空间组织成一个<strong>虚拟的环</strong></li><li>哈希空间通常是 <code>0 ～ 2³²−1</code></li><li>数据节点和数据本身都映射到这个环上</li><li>数据沿顺时针方向，落到遇到的第一个节点上</li></ol><p>为便于说明，我们将哈希空间简化为 0～100，并假设通过哈希计算，4 个数据库节点在环上大致分布在如下位置：</p><p><img src="/images/hash/hash6.png" alt="hash6"></p><ul><li>DB1 → 0</li><li>DB2 → 25</li><li>DB3 → 50</li><li>DB4 → 75</li></ul><p>当我们对 <code>user_id</code> 计算哈希后：</p><ul><li>不再取模</li><li>而是在环上找到该哈希值</li><li>顺时针查找第一个数据库节点</li></ul><hr><h2 id="扩容时发生了什么？"><a href="#扩容时发生了什么？" class="headerlink" title="扩容时发生了什么？"></a>扩容时发生了什么？</h2><p>现在，我们在环上的位置 65 新增一个数据库节点 DB5。</p><p><img src="/images/hash/hash3.png" alt="hash3"></p><p>此时：</p><ul><li>只有哈希值位于 <code>(50, 65]</code> 区间的数据需要迁移</li><li>其他数据完全不受影响</li></ul><p>相比取模 Hash，数据迁移范围被大幅缩小。</p><hr><h2 id="缩容时的行为"><a href="#缩容时的行为" class="headerlink" title="缩容时的行为"></a>缩容时的行为</h2><p>缩容同样遵循相同的规则。</p><p>如果移除某个节点，其负责的哈希区间会顺延给下一个节点，而不会影响整个系统的映射关系。</p><p><img src="/images/hash/hash4.png" alt="hash4"></p><hr><h2 id="仍然存在的问题：负载不均"><a href="#仍然存在的问题：负载不均" class="headerlink" title="仍然存在的问题：负载不均"></a>仍然存在的问题：负载不均</h2><p>到这里，一致性 Hash 看起来已经非常理想了，但在工程实践中还会遇到一个问题：</p><blockquote><p><strong>节点之间的负载可能严重不均衡。</strong></p></blockquote><p>例如，在移除 DB3 的场景中：</p><p>原本属于 DB3 的全部数据会被顺延给同一个相邻节点</p><p>这可能导致某一台数据库瞬间成为性能瓶颈。</p><hr><h2 id="虚拟节点：工程上的关键改进"><a href="#虚拟节点：工程上的关键改进" class="headerlink" title="虚拟节点：工程上的关键改进"></a>虚拟节点：工程上的关键改进</h2><p>为了解决负载不均的问题，需要引入 <strong>虚拟节点（Virtual Nodes）</strong> 的概念。</p><p>核心思想是：</p><blockquote><p><strong>一个物理节点，在哈希环上不只占据一个位置。</strong></p></blockquote><p>具体做法是：</p><ul><li>对同一数据库节点构造多个不同的标识</li><li>分别计算哈希值</li><li>将这些位置都映射到同一台物理机器</li></ul><p>例如，对于节点 <code>database1</code>，可以构造：</p><ul><li><code>Hash(&quot;database1#1&quot;)</code> -&gt; pos(VDB1#1)</li><li><code>Hash(&quot;database1#2&quot;)</code> -&gt; pos(VDB1#2)</li><li><code>Hash(&quot;database1#3&quot;)</code> -&gt; pos(VDB1#3)</li><li><code>Hash(&quot;database1#4&quot;)</code> -&gt; pos(VDB1#4)</li></ul><p>它们在逻辑上是 4 个独立节点，但在物理上都指向同一台服务器。</p><p>示意如下：</p><p><img src="/images/hash/hash5.png" alt="hash5"></p><p>引入虚拟节点后：</p><ul><li>数据在环上的分布更加均匀</li><li>单个节点的负载波动被显著降低</li><li>扩容、缩容时的数据迁移成本进一步下降</li></ul><p>这是一致性 Hash 能够在工程实践中落地的关键一步。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一致性哈希的价值不在于分布是否更均匀，而在于节点变化时将重映射控制在最小范围</p><p>即：当系统发生变化时，如何控制变化的影响范围</p><table><thead><tr><th>特性</th><th>普通取模哈希</th><th>一致性哈希</th></tr></thead><tbody><tr><td>节点变化影响</td><td>全局映射变化，大规模迁移</td><td>仅影响 hash 环上的局部区间</td></tr><tr><td>扩容&#x2F;缩容</td><td>不支持平滑扩容</td><td>支持在线、低迁移成本扩容</td></tr><tr><td>数据迁移比例</td><td>约为 1 − 1&#x2F;N</td><td>约为 1&#x2F;N</td></tr><tr><td>均衡性</td><td>天然均匀（前提：hash 好）</td><td>原生不均，通过虚拟节点改善</td></tr><tr><td>典型应用</td><td>本地分片、静态分区</td><td>分布式缓存、KV、分布式存储</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在分布式数据库中，一行数据最终会被写入哪一台机器，取决于系统所采用的数据分布策略。在使用分布键（distribution key）的场景下，这一过程通常由哈希计算精确映射完成。&lt;/p&gt;
&lt;p&gt;这个映射过程通常从一个 &lt;strong&gt;distribution key（分布键）</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
    <category term="hash" scheme="https://jeffrey-fly-github-io.pages.dev/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Win11下使用wsl</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2026/01/10/tools/Win11%E4%B8%8B%E4%BD%BF%E7%94%A8wsl/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2026/01/10/tools/Win11%E4%B8%8B%E4%BD%BF%E7%94%A8wsl/</id>
    <published>2026-01-10T01:54:05.000Z</published>
    <updated>2026-01-12T01:12:42.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动、停止"><a href="#启动、停止" class="headerlink" title="启动、停止"></a>启动、停止</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl #如果没有安装，会安装</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h2 id="查看已安装的版本"><a href="#查看已安装的版本" class="headerlink" title="查看已安装的版本"></a>查看已安装的版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\gujinfei&gt; wsl -l -v</span><br><span class="line">  NAME              STATE           VERSION</span><br><span class="line">* Ubuntu            Running         2</span><br><span class="line">  docker-desktop    Stopped         2</span><br><span class="line">PS C:\Users\gujinfei&gt;</span><br></pre></td></tr></table></figure><h2 id="启用主机代理，加速github访问"><a href="#启用主机代理，加速github访问" class="headerlink" title="启用主机代理，加速github访问"></a>启用主机代理，加速github访问</h2><p>进入： %UserProfile% 目录，编辑或者增加 .wslconfig 文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="comment"># 开启镜像网络模式</span></span><br><span class="line"><span class="attr">networkingMode</span>=mirrored</span><br><span class="line"><span class="comment"># 自动代理转发</span></span><br><span class="line"><span class="attr">autoProxy</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="安装rust"><a href="#安装rust" class="headerlink" title="安装rust"></a>安装rust</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y build-essential curl pkg-config libssl-dev</span><br><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><h2 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h2><ol><li>公私钥 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;jeffreyfly@icloud.com&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;启动、停止&quot;&gt;&lt;a href=&quot;#启动、停止&quot; class=&quot;headerlink&quot; title=&quot;启动、停止&quot;&gt;&lt;/a&gt;启动、停止&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="tools" scheme="https://jeffrey-fly-github-io.pages.dev/categories/tools/"/>
    
    
    <category term="wsl" scheme="https://jeffrey-fly-github-io.pages.dev/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【译】不要给 PostgreSQL 分配过多内存</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/25/postgresql/dont-give-postgres-too-much-memory/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/25/postgresql/dont-give-postgres-too-much-memory/</id>
    <published>2025-12-24T16:00:00.000Z</published>
    <updated>2025-12-30T08:39:12.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为英文技术博客《Don’t give Postgres too much memory》的中文翻译。<br>原文作者：Tomas Vondra<br>原文链接：<a href="https://vondra.me/posts/dont-give-postgres-too-much-memory/">https://vondra.me/posts/dont-give-postgres-too-much-memory/</a><br>本文接近原文直译，仅做结构整理与术语统一，所有观点归原作者所有。</p></blockquote><hr><h2 id="背景：一次“批处理”性能排查的经历"><a href="#背景：一次“批处理”性能排查的经历" class="headerlink" title="背景：一次“批处理”性能排查的经历"></a>背景：一次“批处理”性能排查的经历</h2><p>我时不时会被拉去排查一些与<strong>批处理（batch processing）</strong>相关的问题。<br>最近越来越常见的一种情况是：这些批处理进程会使用<strong>非常大的内存限制</strong>，尤其是：</p><ul><li><code>maintenance_work_mem</code></li><li><code>work_mem</code></li></ul><p>我猜不少 DBA 的思路是：</p><blockquote><p><strong>“内存越大越好。”</strong></p></blockquote><p>但他们往往没有意识到，这样做<strong>实际上可能会明显拖慢性能</strong>。</p><hr><h2 id="一个触发问题的实际案例"><a href="#一个触发问题的实际案例" class="headerlink" title="一个触发问题的实际案例"></a>一个触发问题的实际案例</h2><p>我用一个在测试 <strong>GIN 索引并行构建修复</strong> 时遇到的例子来说明这个问题。</p><p>这个 bug 本身并不复杂，也不算特别有意思，但它需要一个<strong>相当高的 <code>maintenance_work_mem</code></strong> 才能复现 —— 最初的报告里使用了 <strong>20GB</strong>。</p><p>为了验证修复是否有效，我在：</p><ul><li>不同的 <code>maintenance_work_mem</code> 设置</li><li>不同数量的并行 worker</li></ul><p>组合下，反复执行 <code>CREATE INDEX</code>。</p><p>本来的目标只是检查是否还会失败，但我同时也记录了执行时间，并将结果画成了一张图。</p><p><img src="/images/workmem/image.png" alt="mem"></p><hr><h2 id="测试环境说明"><a href="#测试环境说明" class="headerlink" title="测试环境说明"></a>测试环境说明</h2><p>测试运行在 Azure 上的一台 <strong>D96v4 实例</strong>：</p><ul><li><strong>CPU</strong>：Xeon Platinum 8573C  </li><li><strong>内存</strong>：384GB  </li><li><strong>存储</strong>：6 块 NVMe 组成 RAID0</li></ul><p>这意味着：</p><ul><li>数据基本全部命中缓存</li><li>瓶颈主要在 <strong>CPU，而不是磁盘 I&#x2F;O</strong></li></ul><hr><h2 id="并行化的效果（符合预期）"><a href="#并行化的效果（符合预期）" class="headerlink" title="并行化的效果（符合预期）"></a>并行化的效果（符合预期）</h2><p>并行化确实带来了明显收益：</p><ul><li><p>使用 <strong>2 个 worker（包括 leader）</strong><br>→ 性能提升约 <strong>1.8 倍</strong><br>→ 接近理想加速比（因为索引构建的最后阶段仍然是串行的）</p></li><li><p>随着 worker 数量继续增加：</p><ul><li>加速比逐渐下降  </li><li>例如 <strong>8 个 worker 只有约 4.5 倍</strong></li></ul></li></ul><p>这完全符合预期。</p><hr><h2 id="反直觉的现象：内存越大，反而越慢"><a href="#反直觉的现象：内存越大，反而越慢" class="headerlink" title="反直觉的现象：内存越大，反而越慢"></a>反直觉的现象：内存越大，反而越慢</h2><p>真正令人意外的是图中展示的另一个趋势：</p><blockquote><p><strong><code>maintenance_work_mem</code> 越大，索引构建反而越慢。</strong></p></blockquote><p>具体表现为：</p><ul><li>从 <strong>64MB</strong> 增加到 <strong>16GB</strong></li><li>索引构建时间增加了 <strong>约 30%</strong></li><li>并且 <strong>无论使用多少并行 worker，这一趋势都一致</strong></li></ul><p>为什么会这样？</p><hr><h2 id="原因概览"><a href="#原因概览" class="headerlink" title="原因概览"></a>原因概览</h2><p>这很可能是多种因素共同作用的结果。<br>下面我解释两个我认为<strong>最重要的原因</strong>：</p><ol><li><strong>L3 Cache 的大小限制</strong></li><li><strong>Linux 脏页（dirty page）回写机制</strong></li></ol><hr><h2 id="原因一：L3-Cache-的大小限制"><a href="#原因一：L3-Cache-的大小限制" class="headerlink" title="原因一：L3 Cache 的大小限制"></a>原因一：L3 Cache 的大小限制</h2><p>系统中的内存并不是“同一种速度”。</p><p>在 CPU 内部，存在一小块<strong>极快的缓存（L3 Cache）</strong>，访问延迟非常低。<br>但这部分内存通常只有 <strong>32MB～128MB</strong>。</p><p>相比之下：</p><ul><li>主内存（RAM）容量巨大</li><li>但访问延迟要高一个数量级</li></ul><hr><h3 id="索引构建中的内存访问模式"><a href="#索引构建中的内存访问模式" class="headerlink" title="索引构建中的内存访问模式"></a>索引构建中的内存访问模式</h3><p>在索引构建过程中，通常会经历以下流程：</p><ol><li>将数据累积到一个内存缓冲区</li><li>缓冲区“满了”之后进行处理</li><li>再合并到最终的索引结构中</li></ol><p>对于 <strong>GIN 索引</strong> 来说，这一步会把条目插入到一个<strong>哈希表</strong>中，这意味着：</p><blockquote><p><strong>大量随机内存访问</strong></p></blockquote><hr><h3 id="Cache-Miss-的代价"><a href="#Cache-Miss-的代价" class="headerlink" title="Cache Miss 的代价"></a>Cache Miss 的代价</h3><p>一旦这个哈希表的大小超过 <strong>L3 Cache</strong>，CPU 就不得不频繁访问主内存。</p><p>大致的访问代价是：</p><ul><li><strong>L3 Cache</strong>：约 <strong>20 个 CPU cycle</strong></li><li><strong>主内存</strong>：约 <strong>200 个 CPU cycle</strong></li></ul><p>也就是说，<strong>慢了一个数量级</strong>。</p><hr><h3 id="更优的策略"><a href="#更优的策略" class="headerlink" title="更优的策略"></a>更优的策略</h3><p>因此：</p><ul><li>将数据拆分成更小的批次处理</li><li>让工作集尽量能够放进 L3 Cache</li></ul><p>往往是更优的策略。</p><p>即使需要处理更多批次，<strong>总体上仍然可能更快</strong>。</p><p><strong>推荐阅读</strong>：<br>Ulrich Drepper，《<em>What Every Programmer Should Know About Memory</em>》（2007）<br>虽然年代久远，但内存层级的基本原理至今没有变化。</p><hr><h2 id="原因二：Linux-脏页（dirty-page）回写机制"><a href="#原因二：Linux-脏页（dirty-page）回写机制" class="headerlink" title="原因二：Linux 脏页（dirty page）回写机制"></a>原因二：Linux 脏页（dirty page）回写机制</h2><p>除了 CPU Cache，还有操作系统层面的因素。</p><p>当 GIN 的哈希表超过 <code>maintenance_work_mem</code> 限制时，数据会被写入<strong>临时文件</strong>。<br>这些文件不需要持久化保证，因此写入时只进入 <strong>page cache</strong>。</p><hr><h3 id="Linux-的脏页控制机制"><a href="#Linux-的脏页控制机制" class="headerlink" title="Linux 的脏页控制机制"></a>Linux 的脏页控制机制</h3><p>Linux 内核通过两个阈值控制脏页数量：</p><ul><li><code>vm.dirty_background_ratio</code>  <ul><li>达到后，后台开始异步回写</li></ul></li><li><code>vm.dirty_ratio</code>  <ul><li>达到后，<strong>所有写入变成同步写</strong>（非常致命）</li></ul></li></ul><p>理想状态下：</p><blockquote><p>后台回写足够快，永远不会触及 <code>vm.dirty_ratio</code></p></blockquote><hr><h3 id="大批量写入的问题"><a href="#大批量写入的问题" class="headerlink" title="大批量写入的问题"></a>大批量写入的问题</h3><p>问题在于：<br><strong>内核是否有“时间”去完成这些回写。</strong></p><p>假设构建哈希表需要累积 <strong>8GB 数据，用时 1 分钟</strong>：</p><h4 id="情况-A：一次性写出"><a href="#情况-A：一次性写出" class="headerlink" title="情况 A：一次性写出"></a>情况 A：一次性写出</h4><ul><li>1 分钟内几乎不写</li><li>最后一次性写出 8GB</li><li>短时间内产生大量脏页</li><li>极易触发同步写</li></ul><h4 id="情况-B：分批写出"><a href="#情况-B：分批写出" class="headerlink" title="情况 B：分批写出"></a>情况 B：分批写出</h4><ul><li>每 <strong>64MB</strong> 写一次</li><li>写操作均匀分布</li><li>内核有足够时间后台回写</li></ul><p>显然后者对系统更加友好。</p><hr><h2 id="总结（原文结论）"><a href="#总结（原文结论）" class="headerlink" title="总结（原文结论）"></a>总结（原文结论）</h2><p>以上所有分析，**同样适用于 <code>work_mem</code>**。</p><p>唯一的区别在于：</p><ul><li><code>maintenance_work_mem</code>  <ul><li>用于维护操作（<code>CREATE INDEX</code>、<code>VACUUM</code> 等）</li></ul></li><li><code>work_mem</code>  <ul><li>用于普通查询（<code>hash join</code>、<code>hash aggregate</code>、<code>sort</code> 等）</li></ul></li></ul><p>但底层原理完全一致：</p><ul><li>哈希表超过 L3 Cache → 性能下降</li><li>大块内存写入 → 脏页压力 → 可能触发同步写</li></ul><hr><h2 id="作者建议"><a href="#作者建议" class="headerlink" title="作者建议"></a>作者建议</h2><p>我并不知道 <code>maintenance_work_mem</code> 或 <code>work_mem</code> 的“最佳值”是多少，这也不是这篇文章的重点。</p><p>重点在于：</p><blockquote><p><strong>盲目把内存参数调得很大，可能会显著伤害性能。</strong></p></blockquote><p>我的建议是：</p><ul><li>从<strong>比较保守的值</strong>开始（例如 <strong>64MB</strong>）</li><li>只有在你能<strong>明确证明存在收益</strong>的情况下，才逐步调高</li></ul><hr><h2 id="原文信息"><a href="#原文信息" class="headerlink" title="原文信息"></a>原文信息</h2><ul><li>原文作者：Tomas Vondra  </li><li>原文地址：<a href="https://vondra.me/posts/dont-give-postgres-too-much-memory/">https://vondra.me/posts/dont-give-postgres-too-much-memory/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为英文技术博客《Don’t give Postgres too much memory》的中文翻译。&lt;br&gt;原文作者：Tomas Vondra&lt;br&gt;原文链接：&lt;a href=&quot;https://vondra.me/posts/dont-give</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="PostgreSQL" scheme="https://jeffrey-fly-github-io.pages.dev/tags/PostgreSQL/"/>
    
    <category term="Performance" scheme="https://jeffrey-fly-github-io.pages.dev/tags/Performance/"/>
    
    <category term="work_mem" scheme="https://jeffrey-fly-github-io.pages.dev/tags/work-mem/"/>
    
    <category term="maintenance_work_mem" scheme="https://jeffrey-fly-github-io.pages.dev/tags/maintenance-work-mem/"/>
    
    <category term="GIN" scheme="https://jeffrey-fly-github-io.pages.dev/tags/GIN/"/>
    
  </entry>
  
  <entry>
    <title>Distinct_Values</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/22/postgresql/Distinct-Values/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/22/postgresql/Distinct-Values/</id>
    <published>2025-12-22T02:52:49.000Z</published>
    <updated>2025-12-30T08:39:12.404Z</updated>
    
    <content type="html"><![CDATA[<p>pg_stats 视图中的 n_distinct 字段表示某一列中不同取值（distinct values）的数量。</p><p>如果 n_distinct 为负数，其绝对值表示该列中不同取值所占的比例，而不是实际的不同值个数。例如，−1 表示该列中所有值都是唯一的；−3 表示平均而言，每个不同的值大约出现在 3 行中。当估计的不同值数量超过表中总行数的 10% 时，分析器（analyzer）会使用这种“比例”的表示方式。</p><p>如果预期数据是均匀分布的，则会直接使用不同值的数量。例如，在估算 column &#x3D; expression 这种条件的基数（cardinality）时，如果在规划阶段无法确定表达式的具体取值，查询规划器会假设该表达式可以以相同的概率取列中的任意一个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> flights</span><br><span class="line"><span class="keyword">WHERE</span> departure_airport <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> airport_code</span><br><span class="line"><span class="keyword">FROM</span> airports</span><br><span class="line"><span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;Saint Petersburg&#x27;</span></span><br><span class="line">);</span><br><span class="line">                          QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">30.56</span>.<span class="number">.5340</span><span class="number">.40</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2066</span> width<span class="operator">=</span><span class="number">63</span>) </span><br><span class="line"><span class="keyword">Filter</span>: (departure_airport <span class="operator">=</span> $<span class="number">0</span>)</span><br><span class="line">InitPlan <span class="number">1</span> (<span class="keyword">returns</span> $<span class="number">0</span>)</span><br><span class="line">−<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> airports_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.30</span><span class="number">.56</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> wi... </span><br><span class="line"><span class="keyword">Filter</span>: ((city −<span class="operator">&gt;&gt;</span> lang()) <span class="operator">=</span> <span class="string">&#x27;Saint Petersburg&#x27;</span>::text)</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;pg_stats 视图中的 n_distinct 字段表示某一列中不同取值（distinct values）的数量。&lt;/p&gt;
&lt;p&gt;如果 n_distinct 为负数，其绝对值表示该列中不同取值所占的比例，而不是实际的不同值个数。例如，−1 表示该列中所有值都是唯一的；−3</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
    <category term="plan" scheme="https://jeffrey-fly-github-io.pages.dev/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>NULL VALUES</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/19/postgresql/NULL-VALUES/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/19/postgresql/NULL-VALUES/</id>
    <published>2025-12-19T02:52:49.000Z</published>
    <updated>2025-12-30T08:39:12.406Z</updated>
    
    <content type="html"><![CDATA[<p>虽然理论学家对此不以为然，但 NULL 值在关系型数据库中仍然扮演着重要角色：它提供了一种方便的方式来表示某个值要么未知，要么不存在。</p><p>然而，特殊的值需要特殊处理。除了理论上的不一致性之外，还有许多实际问题需要考虑。常规的布尔逻辑被三值逻辑取代，因此 NOT IN 的行为可能出乎意料。对于 NULL 值应该被视为大于还是小于普通值也不明确（因此存在用于排序的 NULLS FIRST 和 NULLS LAST 子句）。是否需要在聚合函数中考虑 NULL 值也并不十分明显。严格来说，NULL 根本不是一个值，因此优化器在处理它们时需要额外的信息。</p><p>除了在表级收集的最基本的统计信息之外，分析器还会为表的每一列收集统计信息。这些数据存储在系统目录的 <em>pg_statistic</em> 表中，但你也可以通过 pg_stats 视图访问，这个视图以更方便的格式提供这些信息。<br>列级统计信息中包括 NULL 值的比例；在分析过程中计算，并以 null_frac 属性表示。<br>例如，当我们查询尚未起飞的航班时，可以依赖它们的起飞时间未定义（NULL）这一事实：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4772</span><span class="number">.67</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">16702</span> width<span class="operator">=</span><span class="number">63</span>) <span class="keyword">Filter</span>: (actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>为了估算结果，优化器将表的总行数乘以 NULL 值的比例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> round(reltuples <span class="operator">*</span> s.null_frac) <span class="keyword">AS</span> <span class="keyword">rows</span> <span class="keyword">FROM</span> pg_class</span><br><span class="line"><span class="keyword">JOIN</span> pg_stats s <span class="keyword">ON</span> s.tablename <span class="operator">=</span> relname <span class="keyword">WHERE</span> s.tablename <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> s.attname <span class="operator">=</span> <span class="string">&#x27;actual_departure&#x27;</span>;</span><br><span class="line"> <span class="keyword">rows</span> </span><br><span class="line">−−−−−−−</span><br><span class="line"><span class="number">16702</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>以下是实际的行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights <span class="keyword">WHERE</span> actual_departure <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"> count </span><br><span class="line">−−−−−−− </span><br><span class="line"> <span class="number">16348</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然理论学家对此不以为然，但 NULL 值在关系型数据库中仍然扮演着重要角色：它提供了一种方便的方式来表示某个值要么未知，要么不存在。&lt;/p&gt;
&lt;p&gt;然而，特殊的值需要特殊处理。除了理论上的不一致性之外，还有许多实际问题需要考虑。常规的布尔逻辑被三值逻辑取代，因此 NOT </summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
  </entry>
  
  <entry>
    <title>Basic Statistics</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/18/postgresql/Basic-Statistics/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/18/postgresql/Basic-Statistics/</id>
    <published>2025-12-18T01:42:18.000Z</published>
    <updated>2025-12-30T08:39:12.403Z</updated>
    
    <content type="html"><![CDATA[<p>基本的 relation-level统计信息存储在系统目录的 pg_class 表中，包含以下数据：</p><ul><li>relation中的元组（记录）数量（reltuples）</li><li>relation的大小，以页（page）为单位（relpages）</li><li>在可见性映射（visibility map）中被标记的页数（relallvisible）</li></ul><p>下面是 flights 表对应的这些值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>     <span class="number">2624</span> <span class="operator">|</span>          <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>如果查询未施加任何过滤条件，则 reltuples 的值将作为基数（cardinality）估计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights;</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> flights (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4772</span><span class="number">.67</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">214867</span> width<span class="operator">=</span><span class="number">63</span>)</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>统计信息是在表分析（无论是手动还是自动）过程中收集的。此外，由于基本统计信息至关重要，这些数据也会在其他操作中计算（如 VACUUM FULL 和 CLUSTER，以及 CREATE INDEX 和 REINDEX），并在常规 VACUUM 过程中进一步精化。</p><p>为了分析目的，会从表中随机抽取 300 × <em>default_statistics_target</em> 行进行采样。为了构建具有特定精度的统计信息，所需的样本量与被分析数据的总体量关系不大，因此表的大小不会被考虑在内。</p><p>抽样行是从同样数量的随机页（300 × <em>default_statistics_target</em> 页）中选出的。显然，如果表本身较小，则可能读取的页数更少，选取用于分析的行数也会相应减少。</p><p>对于大表，统计信息收集不会包含所有行，因此估算值可能与实际值存在偏差。这是完全正常的：如果数据在不断变化，统计信息本身也不可能始终准确。通常，只要估算精度在数量级上足够，即可用来选择合理的查询执行计划。</p><p>我们创建一个 flights 表的副本，并禁用 autovacuum，这样我们就可以控制自动分析（autoanalysis）的启动时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> flights_copy(<span class="keyword">LIKE</span> flights) <span class="keyword">WITH</span> (autovacuum_enabled <span class="operator">=</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>目前新表没有统计信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible</span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">        −<span class="number">1</span> <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>             <span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>当 reltuples &#x3D; −1 时，用于区分尚未分析的表和真正没有行的空表。</p><p>表创建后，很可能会马上插入一些行。由于优化器无法获知表的当前实际状态，它会假设该表包含 10 个页：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights_copy (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.14</span><span class="number">.10</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">410</span> width<span class="operator">=</span><span class="number">170</span>) </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>行数的估算是基于单行的大小（在执行计划中显示为 width）。行宽通常是在分析过程中计算的平均值，但由于此时尚未收集任何统计信息，这里只是根据列的数据类型做出的近似估算。</p><p>现在，我们从 flights 表拷贝数据同时完成分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; INSERT INTO flights_copy SELECT * FROM flights; INSERT 0 214867</span><br><span class="line">=&gt; ANALYZE flights_copy;</span><br></pre></td></tr></table></figure><p>收集到的统计信息反映了实际的行数（表足够小，分析器可以对所有数据收集统计信息）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages, relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages <span class="operator">|</span> relallvisible </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>     <span class="number">2624</span> <span class="operator">|</span>             <span class="number">0</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>relallvisible 值用于估算 index-only scan 的成本。该值由 VACUUM 更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> VACUUM flights_copy;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> relallvisible <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line">relallvisible </span><br><span class="line">−−−−−−−−−−−−−−−</span><br><span class="line">          <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>现在我们将行数翻倍，但不更新统计信息，检查查询计划中的基数估算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> flights_copy <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights; </span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> flights_copy;</span><br><span class="line"> count </span><br><span class="line">−−−−−−−−</span><br><span class="line"><span class="number">429734</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> flights_copy;</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> flights_copy (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.9545</span><span class="number">.34</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">429734</span> width<span class="operator">=</span><span class="number">63</span>) </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>尽管 pg_class 中的数据已经过时，估算结果仍然准确：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples, relpages</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> reltuples <span class="operator">|</span> relpages </span><br><span class="line">−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−</span><br><span class="line">    <span class="number">214867</span> <span class="operator">|</span>    <span class="number">2624</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>问题在于，如果优化器发现 relpages 与实际文件大小之间存在差距，它可以通过比例调整 reltuples 的值来提高估算精度。由于文件大小相比 relpages 翻了一倍，优化器会调整估算的行数，同时假设数据密度保持不变：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> reltuples <span class="operator">*</span></span><br><span class="line">(pg_relation_size(<span class="string">&#x27;flights_copy&#x27;</span>) <span class="operator">/</span> <span class="number">8192</span>) <span class="operator">/</span> relpages <span class="keyword">AS</span> tuples</span><br><span class="line"><span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;flights_copy&#x27;</span>;</span><br><span class="line"> tuples</span><br><span class="line">−−−−−−−−</span><br><span class="line"> <span class="number">429734</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>当然，这种调整并不总是有效（例如，如果删除了一些行，估算值将保持不变），但在某些情况下，它可以让优化器在下一次分析触发之前仍然保持合理的估算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基本的 relation-level统计信息存储在系统目录的 pg_class 表中，包含以下数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;relation中的元组（记录）数量（reltuples）&lt;/li&gt;
&lt;li&gt;relation的大小，以页（page）为单位（relpages）&lt;</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
    <category term="statistics" scheme="https://jeffrey-fly-github-io.pages.dev/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>Extended_Query_Protocol</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/16/postgresql/Extended-Query-Protocol/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/16/postgresql/Extended-Query-Protocol/</id>
    <published>2025-12-16T10:47:17.000Z</published>
    <updated>2025-12-30T08:39:12.404Z</updated>
    
    <content type="html"><![CDATA[<p>当使用简单查询协议时，每个命令（即使重复多次）都必须经历上述所有阶段：</p><ol><li>parsing</li><li>transformation </li><li>planning</li><li>execution</li></ol><p>但是，一次又一次地解析相同的查询是没有意义的。重复解析仅在常量上不同的查询也没有多大意义——解析树结构仍然保持不变。</p><p>简单查询协议的另一个缺点是客户端会立即收到整个结果，无论它可能包含多少行。</p><p>一般来说，使用 SQL 命令可以克服这些限制。要处理第一种情况，您可以在运行 EXECUTE 命令之前PREPARE查询；第二个问题可以通过使用 DECLARE 创建游标并通过 FETCH 返回行来解决。但在这种情况下，这些新创建的对象的命名必须由客户端处理，而服务器则需要解析额外命令的额外开销</p><p>扩展的客户端—服务器协议提供了一种替代方案，使得可以在协议本身的命令级别上，对各个算子执行阶段进行精确控制。</p><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><p>在准备阶段，查询会像往常一样被解析并进行转换，但生成的解析树会保存在后端的内存中。</p><p>PostgreSQL 并不存在全局的查询缓存。这种架构的缺点是显而易见的：即使同一条查询已经被其他后端进程解析过，每个后端仍然必须重新解析其接收到的所有查询。但与此同时，这种设计也带来了一些好处。全局缓存由于需要加锁，很容易成为系统瓶颈。一个客户端如果频繁执行大量相似但不完全相同的小查询（例如仅常量不同的查询），会产生大量缓存访问流量，从而对整个实例的性能造成负面影响。在 PostgreSQL 中，查询是在各个后端本地解析的，因此不会对其他进程产生影响。</p><p>一条预处理（prepared）的查询可以带参数化。下面是一个使用 SQL 命令的简单示例（尽管这与协议层的预处理不完全相同，但最终效果是一样的）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">PREPARE</span> plane(text) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> $<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>所有命名的预处理语句都显示在 pg_prepared_statements 视图中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, statement, parameter_types</span><br><span class="line"><span class="keyword">FROM</span> pg_prepared_statements \gx</span><br><span class="line">−[ RECORD <span class="number">1</span> ]−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">name            <span class="operator">|</span> plane</span><br><span class="line">statement       <span class="operator">|</span> <span class="keyword">PREPARE</span> plane(text) <span class="keyword">AS</span> <span class="operator">+</span></span><br><span class="line">                <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aircrafts <span class="keyword">WHERE</span> aircraft_code <span class="operator">=</span> $<span class="number">1</span>; </span><br><span class="line">parameter_types <span class="operator">|</span> &#123;text&#125;</span><br></pre></td></tr></table></figure><p>这里不会显示任何未命名语句（即使用扩展查询协议或 PL&#x2F;pgSQL 的语句）。其他后端准备的语句也不会显示：因为无法访问其他会话的内存。</p><h2 id="Parameter-Binding"><a href="#Parameter-Binding" class="headerlink" title="Parameter Binding"></a>Parameter Binding</h2><p>在预处理语句被执行之前，必须先绑定实际的参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;733&#x27;</span>);</span><br><span class="line">aircraft_code <span class="operator">|</span> model <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−− </span><br><span class="line"><span class="number">733</span>            <span class="operator">|</span> Boeing <span class="number">737</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">4200</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>在预处理语句中绑定参数，相比将字面量直接拼接到查询字符串中，其优势在于可以彻底杜绝 SQL 注入：绑定的参数值无法以任何方式修改已经构建完成的解析树。若不使用预处理语句而想达到同等的安全级别，就必须对来自不可信来源的每一个值进行非常谨慎的转义处理。</p><h2 id="Planning-and-Execution"><a href="#Planning-and-Execution" class="headerlink" title="Planning and Execution"></a>Planning and Execution</h2><p>在执行预处理语句时，查询规划会基于实际的参数值来进行；随后生成的执行计划会交由执行器处理。</p><p>由于不同的参数值可能对应不同的最优执行计划，因此在规划阶段准确考虑具体参数值是非常重要的。举例来说，在查询价格较高的预订记录时，规划器会假定符合条件的行数不多，从而选择使用索引扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> bookings(total_amount);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> bookings</span><br><span class="line"><span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">1000000</span>;</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Bitmap Heap Scan <span class="keyword">on</span> bookings (cost<span class="operator">=</span><span class="number">86.49</span>.<span class="number">.9245</span><span class="number">.82</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4395</span> wid... </span><br><span class="line">Recheck Cond: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;1000000&#x27;</span>::<span class="type">numeric</span>)</span><br><span class="line">−<span class="operator">&gt;</span> Bitmap Index Scan <span class="keyword">on</span> bookings_total_amount_idx (cost<span class="operator">=</span><span class="number">0.00</span>....</span><br><span class="line">Index Cond: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;1000000&#x27;</span>::<span class="type">numeric</span>) </span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>但如果给定的条件对所有预订记录都成立，那么使用索引就没有意义了，因为最终仍然需要扫描整张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> bookings</span><br><span class="line"><span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line">QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Seq Scan <span class="keyword">on</span> bookings (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.39835</span><span class="number">.88</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2111110</span> width<span class="operator">=</span><span class="number">21</span>) <span class="keyword">Filter</span>: (total_amount <span class="operator">&gt;</span> <span class="string">&#x27;100&#x27;</span>::<span class="type">numeric</span>)</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>在某些情况下，规划器可能会同时保留解析树和查询计划，以避免重复进行规划。由于这种计划不会考虑具体的参数值，因此被称为通用计划（generic plan），以区别于基于实际参数值生成的定制计划（custom plan）。</p><p>参数化预处理语句的前五次执行，优化过程始终依赖于实际的参数值；规划器会基于这些参数值计算定制计划（custom plan）的平均成本。从第六次执行开始，如果通用计划（generic plan）在平均意义上比定制计划更高效（同时考虑到每次都需要重新生成定制计划的额外开销），规划器就会保留通用计划并继续使用它，从而跳过后续的优化阶段。</p><p>一个显而易见的场景是：当查询不包含任何参数时，数据库可以使用通用计划而不会对性能造成影响</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;763&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;773&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;319&#x27;</span>);</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> <span class="string">&#x27;319&#x27;</span>::text) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p> 在第五次执行之后，规划器会切换为通用计划（generic plan）：该计划与之前的定制计划并无差别，成本也相同，但后端只需构建一次即可，并且可以跳过优化阶段，从而降低规划开销。此时，EXPLAIN 命令显示参数是通过位置来引用的，而不再显示其具体取值。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;320&#x27;</span>);</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;321&#x27;</span>);</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> $<span class="number">1</span>) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><blockquote><p>“优化阶段”特指每次执行时基于参数值重新生成执行计划的那一部分工作。</p></blockquote><p> 我们可以很容易想象这样一种不利情况：前几次生成的 custom plan 比 generic plan 更昂贵；随后可能出现的更高效的 custom plan 却完全不会被考虑。此外，规划器比较的是估算成本而非实际执行成本，这也可能导致误判。</p><p>不过，如果规划器的自动决策出现偏差，你可以通过设置 plan_cache_mode 参数来覆盖自动选择，从而强制使用 generic plan 或 custom plan</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">SET</span> plan_cache_mode <span class="operator">=</span> <span class="string">&#x27;force_custom_plan&#x27;</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">EXECUTE</span> plane(<span class="string">&#x27;CN1&#x27;</span>);</span><br><span class="line">QUERY PLAN </span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− </span><br><span class="line">Seq Scan <span class="keyword">on</span> aircrafts_data ml (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">52</span>)</span><br><span class="line"><span class="keyword">Filter</span>: ((aircraft_code)::text <span class="operator">=</span> <span class="string">&#x27;CN1&#x27;</span>::text) (<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>除了其他信息之外，pg_prepared_statements 视图还显示了所选计划的统计信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=&gt; SELECT name, generic_plans, custom_plans</span><br><span class="line">FROM pg_prepared_statements;</span><br><span class="line">name   | generic_plans | custom_plans </span><br><span class="line">−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−− </span><br><span class="line">plane  | 1             | 6</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h2 id="Getting-the-Results"><a href="#Getting-the-Results" class="headerlink" title="Getting the Results"></a>Getting the Results</h2><p>扩展查询协议允许按批次而不是一次性检索数据。SQL 游标（cursor）几乎具有相同效果（唯一的区别是服务器需要做一些额外处理，而且规划器只会优化前 <em>cursor_tuple_fraction</em> 行的获取，而不是整个结果集）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> aircrafts</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> aircraft_code;</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">FETCH</span> <span class="number">3</span> <span class="keyword">FROM</span> cur;</span><br><span class="line">aircraft_code  <span class="operator">|</span> model           <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−</span><br><span class="line"><span class="number">319</span>            <span class="operator">|</span> Airbus A319−<span class="number">100</span> <span class="operator">|</span> <span class="number">6700</span></span><br><span class="line"><span class="number">320</span>            <span class="operator">|</span> Airbus A320−<span class="number">200</span> <span class="operator">|</span> <span class="number">5700</span></span><br><span class="line"><span class="number">321</span>            <span class="operator">|</span> Airbus A321−<span class="number">200</span> <span class="operator">|</span> <span class="number">5600</span></span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">FETCH</span> <span class="number">2</span> <span class="keyword">FROM</span> cur;</span><br><span class="line">aircraft_code  <span class="operator">|</span> model          <span class="operator">|</span> <span class="keyword">range</span> </span><br><span class="line">−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−−−−−−−−−−−<span class="operator">+</span>−−−−−−− </span><br><span class="line"><span class="number">733</span>            <span class="operator">|</span> Boeing <span class="number">737</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">4200</span> </span><br><span class="line"><span class="number">763</span>            <span class="operator">|</span> Boeing <span class="number">767</span>−<span class="number">300</span> <span class="operator">|</span> <span class="number">7900</span></span><br><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>) </span><br></pre></td></tr></table></figure><p>如果查询返回大量行，且客户端需要获取所有行，那么系统吞吐量高度依赖于批量大小（batch size）。批量包含的行数越多，每次访问服务器并获取响应时产生的通信开销就越小。然而，随着批量大小继续增加，这种优势会逐渐减弱：例如，将行一条条取出与每批取 10 行的差别非常明显，但将每批取 100 行与每批取 1000 行相比，性能提升就不那么显著了</p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol><li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当使用简单查询协议时，每个命令（即使重复多次）都必须经历上述所有阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parsing&lt;/li&gt;
&lt;li&gt;transformation &lt;/li&gt;
&lt;li&gt;planning&lt;/li&gt;
&lt;li&gt;execution&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，一</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
  </entry>
  
  <entry>
    <title>Query Execution Stages</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/07/postgresql/Query-Execution-Stages/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/07/postgresql/Query-Execution-Stages/</id>
    <published>2025-12-07T02:00:35.000Z</published>
    <updated>2025-12-30T08:39:12.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Demo-Database"><a href="#1-Demo-Database" class="headerlink" title="1. Demo Database"></a>1. Demo Database</h2><p>前面章节中的示例都是基于只有几行数据的简单表。本章以及后面的章节要处理查询执行，在这方面对数据要求更高：我们需要行数多得多、彼此有关联的表。为了不在每个示例中都重新发明一个新的数据集，我选用了一个现成的演示数据库，它展示了俄罗斯的客运航空交通情况。这个数据库有多个版本；我们将使用 2017 年 8 月 15 日创建的较大版本。要安装这个版本，你需要从压缩包中解压出包含数据库副本的文件，然后在 psql 中运行这个文件。</p><p>在开发这个演示数据库时，我们尝试让它的模式（schema）足够简单，以便无需额外说明就能理解；同时，我们也希望它足够复杂，能够用来编写有意义的查询。数据库填充了贴近真实场景的数据，这使得示例更加全面，也更有趣味性。</p><p>这里我只会简要介绍主要的数据库对象；如果你想查看整个模式(schema)，可以参阅脚注中引用的完整描述。</p><p>主要的实体(entity)是 预订（<strong>booking</strong>），它对应于 bookings 表。一个预订可以包含多个乘客，每个乘客都有单独的电子机票（对应 tickets 表）。乘客本身不构成独立的实体；在我们的实验中，我们假设所有乘客都是唯一的</p><p>每张机票包含一个或多个航段（对应 ticket_flights 表）。一张机票之所以可能有多个航段，主要有两种情况：要么它是往返票，要么它包含联程航班。虽然数据库模式中没有相应的约束，但我们假设同一个预订（booking）中的所有机票都拥有相同的航段。</p><p>每个航班（flights 表）都从一个机场（airports 表）飞往另一个机场。具有相同航班号的航班拥有相同的出发地和目的地，但起飞日期不同。</p><p>routes 视图基于 flights 表构建；它展示的是与具体航班日期无关的航线信息。</p><p>在值机时，每位乘客都会被发放一张带有座位号的登机牌（boarding_passes 表）。乘客只能为机票中包含的航班办理值机。航班 + 座位 的组合必须唯一，因此不可能为同一个座位发放两张登机牌。</p><p>飞机上的座位数量（seats 表）以及这些座位在不同舱位之间的分布，取决于执行该航班的具体机型（aircrafts 表）。我们假设每一种机型只能有一种客舱布局。</p><p>有些表使用了代理主键（surrogate primary key），而另一些表使用了自然主键（natural key）（其中有些还是复合主键）。这样设计纯粹是为了演示，绝不是推荐的实践方式。</p><p>这个演示数据库可以看作是真实系统的一份转储：其中包含了某个过去时间点的数据快照。要查看这个时间，可以调用 bookings.now() 函数。在需要使用 now() 的真实查询场景中，你可以在演示查询里使用这个函数。</p><p>机场、城市和机型的名称存储在 airports_data 和 aircrafts_data 表中，并提供了两种语言：英文和俄文。为了构建本章的示例，我通常会查询实体关系图中显示的 airports 和 aircrafts 这两个视图；这些视图会根据 bookings.lang 参数的值来选择输出语言。不过在查询计划中，有些底层表的名称仍然可能会出现。</p><h2 id="2-Simple-Query-Protoco"><a href="#2-Simple-Query-Protoco" class="headerlink" title="2. Simple Query Protoco"></a>2. Simple Query Protoco</h2><p>一种简单版本的客户端–服务器协议即可实现 SQL 查询的执行：客户端将查询文本发送给服务器，而服务器则返回完整的执行结果——无论结果包含多少行。发送到服务器的查询会经过几个阶段：解析（parse）→ 转换（transform）→ 计划（plan）→ 执行（execute）。</p><p><img src="/images/QES/qes1.png" alt="qes1"></p><h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>首先，PostgreSQL 必须对查询文本进行<strong>解析（parse）</strong>，以便理解需要执行的内容。</p><p><strong>Lexical and syntactic analysis</strong> 词法分析器（lexer）会把查询文本拆分成一组词法单元（lexemes），例如关键字、字符串字面量、数字字面量等；而<strong>语法分析器（parser）</strong>会根据 SQL 的语言语法规则对这组词法单元进行验证。PostgreSQL 使用的是标准的解析工具，即 Flex 和 Bison。</p><p>解析后的查询会以<strong>抽象语法树（AST）</strong>的形式存储在后端进程的内存中。</p><p>例如，让我们来看下面这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br></pre></td></tr></table></figure><p>词法分析器从中识别出了 5 个关键字、5 个标识符、1 个字符串字面量，以及 3 个单字符词素（一个逗号、一个等号和一个分号）。语法分析器则使用这些词素来构建解析树，下面的插图展示了一个高度简化的解析树。树中每个节点旁的文字说明表示该节点对应查询中的哪一部分：</p><p><img src="/images/QES/qes2.png" alt="qes2"></p><p>一个比较晦涩的缩写 RTE 代表 Range Table Entry（范围表项）。PostgreSQL 的源代码中使用 range table（范围表） 这个术语来指代表、子查询、连接结果——换句话说，指代 任何可以被 SQL 运算符处理的行集（set of rows）</p><p><strong>语义分析（Semantic analysis）</strong> 的目的在于确认数据库中是否存在该查询按名称引用的表或其他对象，并检查用户是否拥有访问这些对象的权限。语义分析所需的全部信息都存储在 系统目录（system catalog） 中。</p><p>在获得解析树之后，语义分析器会对其进行进一步的重组，这包括：为解析树添加对具体数据库对象、数据类型以及其他信息的引用。</p><p>如果你启用了参数 debug_print_parse，就可以在服务器日志中看到完整的解析树，但这通常没有太大的实际意义。</p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>在下一阶段，查询会被<strong>转换（重写，rewrite）</strong>。</p><p>PostgreSQL 核心在多个场景下会使用查询转换。其中之一就是：<br>将解析树中 视图（view） 的名称替换为该视图底层查询（base query）对应的子树。</p><p>另一个使用转换的场景是行级安全（Row-Level Security, RLS） 的实现。<br>另外，递归查询中的 <strong>SEARCH</strong> 和 <strong>CYCLE</strong> 子句也会在此阶段被转换。</p><p>在上面的示例中，pg_tables 是一个视图；如果我们把它的定义直接展开写进查询文本，它将会是下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> (<span class="comment">-- pg_tables</span></span><br><span class="line">    <span class="keyword">SELECT</span> n.nspname <span class="keyword">AS</span> schemaname,</span><br><span class="line">        c.relname <span class="keyword">AS</span> tablename,</span><br><span class="line">        pg_get_userbyid(c.relowner) <span class="keyword">AS</span> tableowner,</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">FROM</span> pg_class c</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_namespace n <span class="keyword">ON</span> n.oid <span class="operator">=</span> c.relnamespace</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> pg_tablespace t <span class="keyword">ON</span> t.oid <span class="operator">=</span> c.reltablespace</span><br><span class="line">    <span class="keyword">WHERE</span> c.relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="keyword">ARRAY</span>[<span class="string">&#x27;r&#x27;</span>::<span class="type">char</span>, <span class="string">&#x27;p&#x27;</span>::<span class="type">char</span>])</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename；</span><br></pre></td></tr></table></figure><p>不过，服务器并不会处理查询的文本表示；所有操作都在解析树（parse tree）上完成。下图展示的是一个简化后的重写树（如果启用 debug_print_rewritten 参数，你可以在服务器日志中看到其完整版本）。</p><p>解析树只反映了查询的语法结构，但并不包含任何关于操作执行顺序的信息。</p><p>此外，PostgreSQL 还支持自定义转换，用户可以通过 rewrite rule（重写规则）系统来实现自己的查询重写逻辑。</p><p><img src="/images/QES/qes3.png" alt="qes3"></p><blockquote><p>规则系统（rule system）的支持曾被宣称为 Postgres 开发的主要目标之一；在最初实现规则系统时，Postgres 还只是一个学术项目，但之后规则系统已经多次被重新设计。规则系统非常强大，但也相当难以理解和调试。甚至有人提议直接把规则系统从 PostgreSQL 中移除，但这一想法并未得到一致认可。在大多数情况下，使用 触发器（trigger） 会比使用规则更加安全且容易。</p></blockquote><h3 id="Planning"><a href="#Planning" class="headerlink" title="Planning"></a>Planning</h3><p>SQL 是一种声明式语言：查询只说明要取什么数据，而不说明如何取。</p><p>任何查询都可以有多种执行路径。解析树中的每个操作都可能有多种完成方式：<br>例如，结果既可以通过全表扫描（读取整张表并过滤掉不需要的数据）得到，也可以通过索引扫描来找到所需行。数据集在连接时总是两两结合（pairwise joins），这意味着连接顺序存在大量组合，从而产生数量巨大的候选执行方案。此外，还有多种连接算法（join algorithms）：例如，执行器可以扫描第一个数据集的每一行，并在第二个数据集中查找匹配行；或者，先对两个数据集进行排序，再执行合并连接（merge join）。对每一种算法，都能找到其优于其他算法的使用场景。</p><p>最优计划与非最优计划的执行时间可能相差几个数量级，因此用于对解析后的查询进行优化的 计划器（planner） 是系统中最复杂的组件之一</p><p><strong>Plan tree</strong>  执行计划同样以树结构表示，但其节点处理的是物理数据操作，而不是逻辑操作。</p><p>如果你想查看完整的计划树，可以启用 debug_print_plan 参数，将计划树输出到服务器日志中。但在实际工作中，通常只需要查看 EXPLAIN 命令显示的文本形式的执行计划就足够了。</p><p>下图突出展示了执行计划树中的主要节点。正是这些节点会出现在下面 EXPLAIN 命令的输出中。</p><p>暂时我们先关注以下两点：</p><ul><li>这棵计划树中只包含了三个被查询表中的两个：规划器发现其中一个表对获取结果并非必需，于是将其从计划树中移除了。</li><li>对于计划树中的每个节点，规划器都会给出估算的成本（cost）以及预计要处理的行数（rows）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> schemaname, tablename</span><br><span class="line"><span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br><span class="line">QUERY PLAN</span><br><span class="line">−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−</span><br><span class="line">Sort (cost<span class="operator">=</span><span class="number">21.03</span>.<span class="number">.21</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">  Sort Key: c.relname</span><br><span class="line">  −<span class="operator">&gt;</span> Nested Loop <span class="keyword">Left</span> <span class="keyword">Join</span> (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.21</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">    <span class="keyword">Join</span> <span class="keyword">Filter</span>: (n.oid <span class="operator">=</span> c.relnamespace)</span><br><span class="line">    −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_class c (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.93</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">72</span>)</span><br><span class="line">        <span class="keyword">Filter</span>: ((relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="keyword">AND</span> (pg_g...</span><br><span class="line">    −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_namespace n (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> wid...</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>查询计划中的 Seq Scan 节点表示顺序扫描表数据，<br>而 Nested Loop 节点则表示连接（join）操作。</p><p><img src="/images/QES/qes4.png" alt="qes4"></p><p><strong>Plan search</strong> PostgreSQL 使用的是基于成本（cost-based）的优化器；它会遍历可能的执行计划，并估算执行这些计划所需的资源，例如 I&#x2F;O 操作或 CPU 周期。这种估算会被归一化为一个数值，称为该计划的 cost（成本）。在所有被考虑的计划中，优化器最终会选择 成本最低的那个计划。</p><p>问题在于：潜在可用的执行计划数量会随着参与连接的表数呈指数级增长，因此即使针对相对简单的查询，也不可能把所有计划都枚举一遍。通常，规划器会使用动态规划（dynamic programming）算法并结合一些启发式规则（heuristics）来缩小搜索范围。这种方法使规划器能够在可接受的时间内，为包含大量表的查询找到数学上最优的执行计划。</p><blockquote><p>准确的解决方案并不能保证所选计划确实是最佳计划，因为规划器使用简化的数学模型，可能缺乏可靠的输入数据</p></blockquote><p><strong>Managing the order of joins</strong> 查询可以通过某种结构方式来限制优化器的搜索范围（当然，这样做有可能错过最优执行计划）。</p><ul><li><p>公共表表达式（CTE） 和主查询可以被分别优化；如果你想强制这种行为，可以使用 MATERIALIZED 子句。</p></li><li><p>在非 SQL 函数内部运行的子查询 总是会被单独优化。（SQL 函数有时可能会被 inline 到主查询中。）</p></li><li><p>如果你设置了 join_collapse_limit 并在查询中使用显式的 JOIN 语法，那么部分连接顺序会被查询的语法结构所固定；类似地，from_collapse_limit 对子查询有相同的效果。</p></li></ul><p>最后一点可能需要解释一下。让我们来看一个示例：在 FROM 子句中列出表，但没有写任何显式 JOIN 的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b, c, d, e</span><br><span class="line"><span class="keyword">WHERE</span> ..</span><br></pre></td></tr></table></figure><p>在这种情况下，规划器必须考虑所有可能的连接（join）组合。该查询会由解析树中的如下部分来表示（示意性展示）。</p><p><img src="/images/QES/qes5.png" alt="qes5"></p><p>在下一个示例中，连接（join）的结构由 JOIN 子句 明确定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> a, b <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ..., d, e</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>解析树会反映出这种结构。</p><p><img src="/images/QES/qes6.png" alt="qes6"></p><p>规划器通常会将连接树（join tree）扁平化，使其看起来与第一个示例中的结构类似。该算法会递归遍历整棵树，并将每个 JOINEXPR 节点替换为其包含元素的扁平列表。</p><p>然而，只有当生成的扁平列表元素数量不超过 <em>join_collapse_limit</em> 时，这种合并操作才会执行。在这个特定的例子中，如果 <em>join_collapse_limit</em> 的值小于五，JOINEXPR 节点将不会被合并。</p><p>对于查询优化器而言，这意味着：</p><ul><li>表 B 必须与表 C 进行连接（或者反过来，C 必须与 B 连接；在这对表中的连接顺序没有限制）。 </li><li>表 A、D、E 以及 B 和 C 连接的结果可以按任意顺序进行连接。</li></ul><p>如果 <em>join_collapse_limit</em>  参数设置为 1，则显式 JOIN 子句中定义的顺序将被保留。</p><p>关于 <strong>FULL OUTER JOIN</strong> 的操作数，它们永远不会被合并（collapsed），无论 <em>join_collapse_limit</em>  参数的值是多少。  </p><p><em>from_collapse_limit</em> 参数以类似的方式控制子查询的扁平化。虽然子查询看起来不像 JOIN 子句，但在解析树（parse tree）层面上，这种相似性就很明显了</p><p>一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line"><span class="keyword">FROM</span> a,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> b, c <span class="keyword">WHERE</span> ...</span><br><span class="line">) bc,</span><br><span class="line">d, e </span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>对应的JOIN树如下所示。这里唯一的区别是，这棵树包含的是 <strong>FROMEXPR</strong> 节点，而不是 <strong>JOINEXPR</strong>（因此参数名如此命名）。</p><p><img src="/images/QES/qes7.png" alt="qes7"></p><p><strong>遗传查询优化（Genetic query optimization）</strong> 在将查询树扁平化之后，某一层可能包含过多的元素——无论是表还是中间连接结果，这些元素都需要单独进行优化。由于查询计划的生成时间会随着需要连接的数据集数量呈指数增长，因此plan时间可能会超出所有合理的范围。</p><p>如果启用了 <em>geqo</em> 参数，并且某一层的元素数量超过 <em>geqo_threshold</em> 的阈值，查询规划器将使用遗传算法来优化查询。相比动态规划，遗传算法的速度要快得多，但它无法保证找到的查询计划一定是最优的。因此，一条经验法则是通过减少需要优化的元素数量来避免使用遗传算法。</p><p>遗传算法有若干可配置参数，但在此不作详细介绍。</p><p><strong>选择最佳执行计划</strong> 查询计划是否可以被认为是最优的，取决于特定客户端如何使用查询结果。如果客户端需要一次性获取完整结果（例如，用于生成报表），那么计划应当优化所有行的检索效率。但如果优先考虑尽快返回前几行（例如，用于屏幕显示），那么最优计划可能完全不同。</p><p>为了做出这个选择，PostgreSQL 会计算成本的两个组成部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">&gt;</span> EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> schemaname, tablename <span class="keyword">FROM</span> pg_tables</span><br><span class="line"><span class="keyword">WHERE</span> tableowner <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> tablename;</span><br><span class="line">                      QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------</span></span><br><span class="line">Sort (cost<span class="operator">=</span><span class="number">21.03</span>.<span class="number">.21</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">    Sort Key: c.relname</span><br><span class="line">    −<span class="operator">&gt;</span> Nested Loop <span class="keyword">Left</span> <span class="keyword">Join</span> (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.21</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">128</span>)</span><br><span class="line">        <span class="keyword">Join</span> <span class="keyword">Filter</span>: (n.oid <span class="operator">=</span> c.relnamespace)</span><br><span class="line">        −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_class c (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.93</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">72</span>)</span><br><span class="line">            <span class="keyword">Filter</span>: ((relkind <span class="operator">=</span> <span class="keyword">ANY</span> (<span class="string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="keyword">AND</span> (pg_g... </span><br><span class="line">        −<span class="operator">&gt;</span> Seq Scan <span class="keyword">on</span> pg_namespace n (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">4</span> wid..</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>第一个组成部分（启动成本）表示节点执行前的准备开销；第二个组成部分（总成本）则包括获取查询结果过程中产生的所有开销。</p><blockquote><p>有时人们会说启动成本是获取结果集第一行的开销，但这种说法并不完全准确。</p></blockquote><p>为了挑选出首选执行计划，优化器会检查查询是否使用了游标（无论是通过 SQL 中的 DECLARE 命令，还是在 PL&#x2F;pgSQL 中显式声明（<em>explicitly</em>））。如果没有使用游标，则默认客户端需要一次性获取完整结果，优化器会选择总成本最小的计划。</p><p>如果查询是通过游标执行的，则所选计划必须优化仅获取所有行中 <em>cursor_tuple_fraction</em> 部分的效率。更准确地说，PostgreSQL 会选择使以下表达式值最小的计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup cost + cursor_tuple_fraction (total cost − startup cost)</span><br></pre></td></tr></table></figure><p>** 成本估算概述 ** 要估算一个计划的总成本，必须对计划中的所有节点进行成本估算。节点的成本取决于其类型（显而易见，读取堆表数据的成本与排序操作的成本不同）以及节点处理的数据量（数据量越大，通常成本越高）。虽然节点类型是已知的，但数据量只能根据输入集的预计基数（节点接收的行数）以及节点的选择性（输出中剩余行的比例）来预测。这些计算依赖于收集到的统计信息，例如表的大小以及表列中数据的分布情况。</p><p>如果对每个节点的基数估计准确，计算出的成本很可能能够较好地反映实际成本。规划中主要的缺陷通常源于基数和选择性的估计不准确，这可能由以下原因造成：</p><ol><li>统计信息不准确或过时；</li><li>无法使用统计信息；</li><li>（程度较轻）规划模型本身的不完善。</li></ol><p><strong>基数估计（Cardinality estimation）</strong>  要计算节点的基数，优化器必须递归地完成以下步骤：</p><ol><li>估算每个子节点的基数，并评估该节点将从子节点接收到的输入行数；</li><li>估算节点的选择性(Selectivity)，即输出中剩余的输入行所占的比例。</li></ol><p>节点的基数即这两个值的乘积。</p><blockquote><p>选择性(Selectivity)用一个介于 0 到 1 之间的数表示。数值越小，选择性越高；反之，数值接近 1 表示选择性较低。乍一看可能不太直观，其含义是：高选择性条件会筛掉几乎所有行，而只排除少量行的条件则选择性低。</p></blockquote><p>首先，优化器会估算定义数据访问方式的叶子节点的基数。这些计算依赖于收集到的统计信息，例如表的总大小。</p><p>过滤条件的选择性取决于条件的类型。在最简单的情况下，可以将其假设为一个常数值，尽管优化器会尽量利用所有可用信息来精确估算。通常，只需要掌握如何估算简单过滤条件即可；如果条件包含逻辑运算，其选择性则按照以下公式计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sel𝑥 𝑎𝑛𝒅 𝑦 = sel𝑥sel𝑦</span><br><span class="line">sel𝑥 𝑜𝒓 𝑦  = 1−(1−sel𝑥)(1−sel𝑦) = sel𝑥+sel𝑦−sel𝑥sel𝑦</span><br></pre></td></tr></table></figure><blockquote><p>sel_X：满足条件 X 的行比例  sel_Y：满足条件 Y 的行比例 条件 X AND Y：满足两个条件的行，概率就是两者独立事件概率的乘积;  (1 - sel_X)：不满足 X 的行比例, (1 - sel_Y)：不满足 Y 的行比例, (1 - sel_X)(1 - sel_Y)：同时不满足 X 和 Y 的行比例.所以 1 − (1 − sel_X)(1 − sel_Y) &#x3D; 满足 X 或 Y 的行比例</p></blockquote><p>不幸的是，上述公式假设谓词 X 和 Y 彼此独立。对于相关（correlated）的谓词，这类估算将不准确。</p><p>要估算 连接（join）的基数，优化器必须首先计算笛卡尔积的基数（即两个数据集基数的乘积），然后估算连接条件的选择性，这仍然取决于条件类型。</p><p>其他节点（如排序或聚合）的基数估算方式也类似。</p><p>需要注意的是：下层节点基数估算不准确，会影响后续所有计算，导致总成本估算不准确，从而选择了不理想的执行计划。更糟糕的是，优化器没有关于连接结果的统计信息，只能依赖表的统计信息。</p><p><strong>成本估算</strong> 成本估算的过程同样是递归的。要计算一个子树的成本，需要先计算并累加其所有子节点的成本，然后再加上父节点自身的成本。</p><p>在估算节点成本时，PostgreSQL 会根据该节点执行的操作建立数学模型，并以已经估算好的节点基数作为输入。对于每个节点，都会计算 启动成本 和 总成本。</p><p>某些操作没有前置条件，因此可以立即执行，这类节点的启动成本为零。</p><p>而另一类操作则必须等待一些前置操作完成后才能执行。例如，排序节点通常需要等待其子节点返回所有数据后，才能进行自己的任务。这类节点的启动成本通常大于零：即使上层节点（或客户端）只需要输出中的一行，也必须支付这一成本。</p><p>优化器进行的所有计算都是估算值，可能与实际执行时间无关。它们的唯一目的，是在相同条件下对同一查询的不同执行计划进行比较。在其他情况下（尤其是不同查询之间），用成本来比较意义不大。例如，由于统计信息过时，成本可能被低估；在统计信息刷新后，计算出的成本可能上升，但由于估算更准确，服务器会选择更优的执行计划。</p><h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><p>在查询优化阶段生成的执行计划现在必须被执行。</p><p>执行器（executor）会在后端内存中打开一个 portal，这是一个保存当前正在执行查询状态的对象。这个状态以一棵树的形式表示，结构与执行计划树相同。树中的各节点像流水线一样运作，彼此请求并传递行数据。</p><p><img src="/images/QES/qes8.png" alt="qes8"></p><p>查询执行从根节点开始。以本例为例，根节点表示 排序（SORT）操作，它从子节点获取数据。在接收到所有行之后，根节点对数据进行排序，并将结果传递给客户端。</p><p>某些节点（如图示中的 NESTLOOP 节点）负责将来自不同来源的数据集进行连接。此类节点会从两个子节点拉取数据，并在收到满足连接条件的行对后立即向上层传递结果行（与排序不同，排序必须先获取所有行）。此时，节点的执行会暂停，直到其父节点请求下一行。如果查询只需要部分结果（例如包含 LIMIT 子句），该操作不会执行完整。</p><p>树中的两个 SEQSCAN 叶子节点负责表扫描。当父节点请求数据时，这些节点会从对应的表中获取下一行数据。</p><p>因此，一些节点不存储任何行，而是立即向上层传递数据；而其他节点（如 SORT）可能需要保留大量数据。为此，后端内存中会为其分配一个 work_mem 内存块；如果内存不足，多余的数据会溢写到磁盘上的临时文件。</p><p>一个执行计划可能包含多个需要数据存储的节点，因此 PostgreSQL 可能会分配多个 work_mem 大小的内存块。查询可使用的总 RAM 大小没有任何限制。</p><h2 id="翻译来之"><a href="#翻译来之" class="headerlink" title="翻译来之"></a>翻译来之</h2><ol><li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Demo-Database&quot;&gt;&lt;a href=&quot;#1-Demo-Database&quot; class=&quot;headerlink&quot; title=&quot;1. Demo Database&quot;&gt;&lt;/a&gt;1. Demo Database&lt;/h2&gt;&lt;p&gt;前面章节中的示例都是基于只有几行</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
  </entry>
  
  <entry>
    <title>RD-Trees for Full-Text Search</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/06/postgresql/RD-Trees-for-Full-Text-Search/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/06/postgresql/RD-Trees-for-Full-Text-Search/</id>
    <published>2025-12-06T02:05:39.000Z</published>
    <updated>2025-12-30T08:39:12.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于全文搜索"><a href="#关于全文搜索" class="headerlink" title="关于全文搜索"></a>关于全文搜索</h2><p>全文搜索的目标是从提供的文档集中选择与搜索查询匹配的文档</p><p>为了进行搜索，文档会被转换为 tsvector 类型，该类型包含文档中的词素（lexemes）及其在文档中的位置。词素是将单词转换为适合搜索的格式。默认情况下，所有单词都会被标准化为小写，并去除其词尾。</p><blockquote><p>“并去除其词尾”指的是在全文搜索中，对单词进行词干提取（stemming）或词形归一化（normalization）的过程。具体来说，这是将单词的词尾（如英语中的复数、时态、词性变化等）去除，提取出单词的词干（stem）或基本形式，以便在搜索时能够匹配同一词根的不同变体。例如：单词“running”、“ran”和“runs”都源自同一词根“run”。在全文搜索的处理中，这些单词可能会被归一化为“run”，即去除词尾变化，保留词干。搜索“run”时，系统不仅会匹配“run”，还会匹配“running”、“ran”和“runs”等形式，因为它们都被归一化为相同的词干“run”。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SET</span> default_text_search_config <span class="operator">=</span> english;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(</span><br><span class="line">    <span class="string">&#x27;No one can tell me, nobody knows, &#x27;</span> <span class="operator">||</span></span><br><span class="line">    <span class="string">&#x27;Where the wind comes from, where the wind goes.&#x27;</span></span><br><span class="line">);</span><br><span class="line">                             to_tsvector                              </span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line"> <span class="string">&#x27;come&#x27;</span>:<span class="number">11</span> <span class="string">&#x27;goe&#x27;</span>:<span class="number">16</span> <span class="string">&#x27;know&#x27;</span>:<span class="number">7</span> <span class="string">&#x27;nobodi&#x27;</span>:<span class="number">6</span> <span class="string">&#x27;one&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;tell&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;wind&#x27;</span>:<span class="number">10</span>,<span class="number">15</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>所谓的停用词（如“the”或“from”）会被过滤掉：这些词被认为出现频率过高，搜索它们无法返回有意义的搜索结果。当然，所有这些转换都是可以配置的。</p><p>查询由另一种类型表示：tsquery。任何查询都包含一个或多个通过逻辑连接符连接的词素：&amp;（与）、|（或）、!（非）。你还可以使用括号来定义操作符的优先级。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsquery(<span class="string">&#x27;wind &amp; (comes | goes)&#x27;</span>);</span><br><span class="line">         to_tsquery          </span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"> <span class="string">&#x27;wind&#x27;</span> <span class="operator">&amp;</span> ( <span class="string">&#x27;come&#x27;</span> <span class="operator">|</span> <span class="string">&#x27;goe&#x27;</span> )</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>全文搜索中唯一使用的操作符是匹配操作符 @@：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, oprcode::regproc, amopstrategy <span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid <span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily <span class="keyword">JOIN</span> pg_operator opr <span class="keyword">ON</span> opr.oid <span class="operator">=</span> amopopr</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;tsvector_ops&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">       amopopr        <span class="operator">|</span>   oprcode   <span class="operator">|</span> amopstrategy </span><br><span class="line"><span class="comment">----------------------+-------------+--------------</span></span><br><span class="line"> @@(tsvector,tsquery) <span class="operator">|</span> ts_match_vq <span class="operator">|</span>            <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>该操作符判断文档是否满足查询条件。以下是一个示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;Where the wind comes from, where the wind goes&#x27;</span>) @@ to_tsquery(<span class="string">&#x27;wind &amp; coming&#x27;</span>);</span><br><span class="line"> ?<span class="keyword">column</span>? </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>这绝不是对全文搜索的详尽描述，但这些信息应足以理解索引的基础知识。</p><h2 id="Indexing-tsvector-Data"><a href="#Indexing-tsvector-Data" class="headerlink" title="Indexing tsvector Data"></a>Indexing tsvector Data</h2><p>为了实现快速的全文搜索，必须使用索引来支持。索引的对象不是文档本身，而是 tsvector 值。这里有两种选择：一种是在表达式上构建索引并进行类型转换，另一种是添加一个单独的 tsvector 类型列并对该列进行索引。第一种方法的优点是不会浪费空间来存储 tsvector 值，因为这些值实际上并不需要直接存储。但这种方法比第二种方法慢，因为索引引擎需要重新检查访问方法返回的所有堆元组。这意味着对于每个重新检查的行，都需要再次计算 tsvector 值，而且正如我们很快会看到的，GiST 索引会重新检查所有行。</p><p>让我们构建一个简单的示例。我们将创建一个包含两列的表：第一列存储文档，第二列存储 tsvector 值。我们可以使用触发器来更新第二列，但更方便的做法是直接将该列声明为生成列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> ts(</span><br><span class="line">    doc text,</span><br><span class="line">    doc_tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> (</span><br><span class="line">         to_tsvector(<span class="string">&#x27;pg_catalog.english&#x27;</span>, doc) </span><br><span class="line">    ) STORED</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX ts_gist_idx <span class="keyword">ON</span> ts</span><br><span class="line"><span class="keyword">USING</span> gist(doc_tsv);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，我使用了带有单一参数的 to_tsvector 函数，通过设置 default_text_search_config 参数来定义全文搜索配置。这种函数变体的波动性（volatility）类别是 STABLE，因为它隐式依赖于参数值。但在这里，我使用了另一种变体，显式指定配置；这种变体是 IMMUTABLE，可以用于生成表达式。</p></blockquote><p>我们插入几行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> ts(doc) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some cows&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a moo, there a moo&#x27;</span>), (<span class="string">&#x27;Everywhere a moo moo&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>), (<span class="string">&#x27;And on his farm he had some chicks&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here a cluck, there a cluck&#x27;</span>), (<span class="string">&#x27;Everywhere a cluck cluck&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Old MacDonald had a farm&#x27;</span>),(<span class="string">&#x27;And on his farm he had some pigs&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Here an oink, there an oink&#x27;</span>),(<span class="string">&#x27;Everywhere an oink oink&#x27;</span>)</span><br><span class="line">RETURNING doc_tsv;</span><br><span class="line">            doc_tsv             </span><br><span class="line"><span class="comment">--------------------------------</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;cow&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;moo&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;chick&#x27;</span>:<span class="number">8</span> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;cluck&#x27;</span>:<span class="number">3</span>,<span class="number">4</span> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">5</span> <span class="string">&#x27;macdonald&#x27;</span>:<span class="number">2</span> <span class="string">&#x27;old&#x27;</span>:<span class="number">1</span></span><br><span class="line"> <span class="string">&#x27;farm&#x27;</span>:<span class="number">4</span> <span class="string">&#x27;pig&#x27;</span>:<span class="number">8</span></span><br><span class="line"> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">6</span></span><br><span class="line"> <span class="string">&#x27;everywher&#x27;</span>:<span class="number">1</span> <span class="string">&#x27;oink&#x27;</span>:<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">(<span class="number">12</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>因此，R 树不适合用于索引文档，因为边界框（bounding box）的概念对文档没有意义。因此，使用了其 RD 树（俄罗斯套娃，Russian Doll）变体。RD 树不使用边界框，而是使用边界集（bounding set），即一个包含其所有子集元素的集合。对于全文搜索，这样的集合包含文档的词素（lexemes），但在一般情况下，边界集可以是任意的。</p><p>在索引条目中表示边界集有几种方法。最简单的一种是列举集合中的所有元素。如下图所示</p><p><img src="/images/RDTree/rdtree1.png" alt="rdtree1"></p><p>为了找到满足 DOC_TSV @@ TO_TSQUERY(‘COW’) 条件的文档，我们需要深入到那些已知包含“cow”词素的子节点的节点。</p><p><img src="/images/RDTree/rdtree2.png" alt="rdtree2"></p><p>这种表示方式的问题显而易见。文档中的词素数量可能非常庞大，而页面大小是有限的。即使单个文档的独特词素数量不算太多，在树的较高层级中，它们的联合集仍然可能变得过大。</p><p>全文搜索使用了另一种解决方案，即更紧凑的签名树（signature tree）。对于那些熟悉布隆过滤器（Bloom filter）的人来说，这种解决方案应该很熟悉。 </p><p>每个词素可以由其签名（signature）表示：一个特定长度的位字符串，其中只有一位被置为 1。置为 1 的位由词素的哈希函数决定。 </p><p>文档的签名是对该文档中所有词素签名的按位或（bitwise OR）操作结果。</p><p><img src="/images/RDTree/rdtree3.png" alt="rdtree3"></p><p>这种方法的优点显而易见：索引条目大小相同且相当小，因此索引非常紧凑。但也存在一些缺点。首先，无法执行仅索引扫描（index-only scan），因为索引不再存储索引键，每个返回的 TID（行标识）都必须通过表进行重新检查。此外，准确性也会受到影响：索引可能返回许多误报（false positives），这些误报需要在重新检查阶段过滤掉。</p><p><img src="/images/RDTree/rdtree4.png" alt="rdtree4"></p><p>让我们再次看看 DOC_TSV @@ TO_TSQUERY(‘COW’) 条件。查询的签名（signature）以与文档相同的方式计算；在这个特定情况下，其签名等于 0000010。一致性函数（consistency function）必须找到所有签名中具有相同位被置位的子节点。</p><p><img src="/images/RDTree/rdtree5.png" alt="rdtree5"></p><p>与前面的例子相比，这里需要扫描更多的节点，因为存在误报（false-positive）命中。由于签名的容量有限，在大型集合中，某些词素必然会具有相同的签名。在这个例子中，这样的词素是“cow”和“oink”。这意味着一个签名可能匹配多个不同的文档；在这里，查询的签名对应于三个文档。</p><p>误报会降低索引的效率，但不会以任何方式影响其正确性：因为假阴性（false negatives）被保证排除，所以不会遗漏所需的值。</p><p>显然，签名的实际大小要大得多。默认情况下，签名占用 123 字节（992 位），因此冲突的概率远低于本例中所示。如果需要，可以使用操作符类参数进一步将签名大小增加到大约 2000 字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ... <span class="keyword">USING</span> gist(<span class="keyword">column</span> tsvector_ops(siglen <span class="operator">=</span> <span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>此外，如果值足够小（略小于页面大小的 1&#x2F;16，对于标准页面大约是 500 字节），tsvector_ops 操作符类会在索引的叶子页面中存储 tsvector 值本身，而不是它们的签名。</p><p>为了了解索引在真实数据上的工作方式，我们可以使用 pgsql-hackers 邮件列表存档。该存档包含 356,125 封电子邮件，包括发送日期、主题、作者姓名和正文文本。让我们添加一个 tsvector 类型的列并构建索引。在这里，我将三个值（主题、作者和正文文本）组合成一个单一的向量，以展示文档可以动态生成，而不必存储在单一列中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> mail_messages <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> tsv tsvector GENERATED ALWAYS <span class="keyword">AS</span> ( to_tsvector(</span><br><span class="line"><span class="string">&#x27;pg_catalog.english&#x27;</span>, subject<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>author<span class="operator">||</span><span class="string">&#x27; &#x27;</span><span class="operator">||</span>body_plain ) ) STORED;</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored.</span><br><span class="line">...</span><br><span class="line">NOTICE: word <span class="keyword">is</span> too long <span class="keyword">to</span> be indexed</span><br><span class="line">DETAIL: Words longer than <span class="number">2047</span> characters <span class="keyword">are</span> ignored. </span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mail_gist_idx <span class="keyword">ON</span> mail_messages <span class="keyword">USING</span> gist(tsv);</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_gist_idx&#x27;</span>));</span><br><span class="line">pg_size_pretty </span><br><span class="line">−−−−−−−−−−−−−−−−</span><br><span class="line"><span class="number">127</span> MB </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><p>在填充该列（tsv）的过程中，一些特别长的词因为长度太大被过滤掉了。但一旦索引构建完成，就可以用于搜索查询了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">27575</span> read<span class="operator">=</span><span class="number">31875</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">75</span> read<span class="operator">=</span><span class="number">4</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>除了满足条件的 898 行之外，访问方法还返回了另外 7852 行，这些行需要后续通过回检（recheck）来过滤。如果我们增加签名容量（signature capacity），准确性（也就是索引效率）会提高，但索引的大小也会随之增加。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">DROP</span> INDEX mail_messages_tsv_idx;</span><br><span class="line"><span class="keyword">DROP</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> mail_messages</span><br><span class="line"><span class="keyword">USING</span> gist(tsv tsvector_ops(siglen<span class="operator">=</span><span class="number">1024</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>));</span><br><span class="line"> pg_size_pretty </span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> <span class="number">241</span> MB</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (analyze, costs off, timing off, summary off) <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mail_messages</span><br><span class="line"><span class="keyword">WHERE</span> tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>);</span><br><span class="line">                                  QUERY PLAN                                  </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> mail_gist_idx <span class="keyword">on</span> mail_messages (actual <span class="keyword">rows</span><span class="operator">=</span><span class="number">898.00</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (tsv @@ to_tsquery(<span class="string">&#x27;magic &amp; value&#x27;</span>::text))</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">7852</span></span><br><span class="line">   Index Searches: <span class="number">1</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">25968</span> read<span class="operator">=</span><span class="number">33482</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">3</span> read<span class="operator">=</span><span class="number">2</span> dirtied<span class="operator">=</span><span class="number">1</span></span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>我已经展示了访问方法的属性，其中大多数在所有操作符类中都是相同的。但是下面两个列级别的属性值得一提：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;mail_messages_tsv_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> f</span><br><span class="line"> distance_orderable <span class="operator">|</span> f</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>现在不可能进行 Index-only 扫描了，因为无法从签名中恢复出原始值。<br>不过在这个特定的场景下这是完全可以接受的：<br>tsvector 值只是用于搜索，我们真正需要的是文档本身（也就是实际的数据行）。<br>对于 tsvector_ops 类来说，也没有定义排序操作符</p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol><li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于全文搜索&quot;&gt;&lt;a href=&quot;#关于全文搜索&quot; class=&quot;headerlink&quot; title=&quot;关于全文搜索&quot;&gt;&lt;/a&gt;关于全文搜索&lt;/h2&gt;&lt;p&gt;全文搜索的目标是从提供的文档集中选择与搜索查询匹配的文档&lt;/p&gt;
&lt;p&gt;为了进行搜索，文档会被转换为 tsv</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
  </entry>
  
  <entry>
    <title>R-tree for points</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/02/postgresql/r-tree-for-points/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/02/postgresql/r-tree-for-points/</id>
    <published>2025-12-02T11:00:26.000Z</published>
    <updated>2025-12-30T08:39:12.407Z</updated>
    
    <content type="html"><![CDATA[<p>第一个示例涉及在平面上对点（或其他几何形状）进行索引。常规的B树无法用于这种数据类型，因为点没有定义比较运算符。显然，我们可以自己实现这样的运算符，但几何形状需要索引支持完全不同的操作。我将只讨论其中的两种：搜索特定区域内包含的对象和最近邻搜索。</p><p>R树在平面上绘制矩形；这些矩形合起来必须覆盖所有被索引的点。一个索引条目存储边界框，谓词可以定义如下：点位于该边界框内。</p><p>R树的根节点包含若干个大矩形（这些矩形可能会有重叠）。子节点包含较小的矩形，这些矩形适合其父节点；它们一起覆盖所有底层的点。</p><p>叶节点应该包含被索引的点本身，但GiST要求所有条目具有相同的数据类型；因此，叶节点的条目也由矩形表示，这些矩形被简化为点。</p><p>为了更好地可视化这种结构，我们来看一个基于机场坐标构建的R树的三个层次。在这个例子中，我已将演示数据库的机场表扩展到五千行。同时我还降低了fillfactor值使树的层次更深。默认值会给我们一个单层树。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> airports_big <span class="keyword">AS</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> airports_data;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">104</span>     </span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">COPY</span> airports_big <span class="keyword">FROM</span> <span class="string">&#x27;/home/postgres/data/extra_airports.copy&#x27;</span>;</span><br><span class="line"><span class="keyword">COPY</span> <span class="number">5413</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX airports_gist_idx <span class="keyword">ON</span> airports_big <span class="keyword">USING</span> gist(coordinates) <span class="keyword">WITH</span> (fillfactor<span class="operator">=</span><span class="number">10</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br></pre></td></tr></table></figure><p>在顶层，所有点都被包含在几个（可能部分重叠的）边界框中。</p><p>在下一层，大矩形被分割成较小的矩形。</p><p>最后，在树的底层，每个边界框包含的点数量与单个页面所能容纳的数量相同。</p><p>该索引使用point_ops操作符类，这是点数据唯一可用的操作符类。</p><p>矩形和其他几何形状可以以相同的方式进行索引，但索引存储的不是对象本身，而是其边界框。</p><h2 id="Page-Layout"><a href="#Page-Layout" class="headerlink" title="Page Layout"></a>Page Layout</h2><p>可以通过 pageinspect 插件来学习Gist页</p><p>和B-Tree索引不同，Gist没有metapage，0号page就是gist的root节点。如果root节点分裂了，老root节点会被move到一个（或多个）单独的页，新root节点取代其位置</p><p>root页的内容如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> ctid, keys <span class="keyword">FROM</span> gist_page_items(get_raw_page(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">0</span>), <span class="string">&#x27;airports_gist_idx&#x27;</span> );</span><br><span class="line">    ctid    <span class="operator">|</span>                                               keys                                               </span><br><span class="line"><span class="comment">------------+--------------------------------------------------------------------------------------------------</span></span><br><span class="line"> (<span class="number">1</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-75.47339630130001,-0.12295600026845932),(-179.876998901,-43.810001373291016)&quot;)</span><br><span class="line"> (<span class="number">2</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-62.919601,-0.14835),(-74.9615020752,-54.93109893798828)&quot;)</span><br><span class="line"> (<span class="number">3</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-39.253101348877,-17.652299880981),(-62.1693,-62.1907997131)&quot;)</span><br><span class="line"> (<span class="number">4</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-14.3937,-0.6994310021400452),(-61.8465003967,-16.706899642899998)&quot;)</span><br><span class="line"> (<span class="number">5</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(22.4692001343,-2.7174999713897705),(10.674076080322266,-34.554901123)&quot;)</span><br><span class="line"> (<span class="number">6</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(63.361,-2.3089799880981445),(22.9993000031,-34.0881601675)&quot;)</span><br><span class="line"> (<span class="number">7</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(177.97799682617188,-31.94029998779297),(115.401596069,-46.8997)&quot;)</span><br><span class="line"> (<span class="number">8</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-79.3834991455,28.20170021057129),(-177.38099670410156,0.9785190224647522)&quot;)</span><br><span class="line"> (<span class="number">9</span>,<span class="number">65535</span>)  <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-51.0722007751,19.96980094909668),(-78.7492,0.0506640002131)&quot;)</span><br><span class="line"> (<span class="number">10</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(128.707992554,-0.06239889934659004),(8.754380226135254,-30.83810043334961)&quot;)</span><br><span class="line"> (<span class="number">11</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(153.56199646,-0.8918330073356628),(130.6199951171875,-31.8885993958)&quot;)</span><br><span class="line"> (<span class="number">12</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(179.951004028,-0.547458),(154.67300415039062,-31.5382995605)&quot;)</span><br><span class="line"> (<span class="number">13</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-153.7039948,71.285402),(-176.64599609375,51.87799835205078)&quot;)</span><br><span class="line"> (<span class="number">14</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-128.576009,70.33080291750001),(-152.621994019,53.25429916379999)&quot;)</span><br><span class="line"> (<span class="number">15</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-104.26300048828125,39.90879822),(-122.8130035,24.072700500499998)&quot;)</span><br><span class="line"> (<span class="number">16</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-91.149597,37.9275016785),(-103.602996826,25.54949951171875)&quot;)</span><br><span class="line"> (<span class="number">17</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-68.36340332030001,31.9512996674),(-90.25800323486328,18.25149917602539)&quot;)</span><br><span class="line"> (<span class="number">18</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-2.269860029220581,31.9475002289),(-67.14849853515625,4.3790202140808105)&quot;)</span><br><span class="line"> (<span class="number">19</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-115.78199768066,63.20940017700195),(-127.36699676513672,40.1506996155)&quot;)</span><br><span class="line"> (<span class="number">20</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-96.6707992553711,62.462799072265625),(-114.903999329,37.649899)&quot;)</span><br><span class="line"> (<span class="number">21</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-83.29579926,37.24570084),(-95.984596252441,32.30059814)&quot;)</span><br><span class="line"> (<span class="number">22</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-83.3467025756836,48.06570053),(-96.38439941,37.74010086)&quot;)</span><br><span class="line"> (<span class="number">23</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-78.31999969,47.697400654599996),(-83.072998,32.00999832)&quot;)</span><br><span class="line"> (<span class="number">24</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-64.67859649658203,47.990799),(-77.98459625,32.36399841308594)&quot;)</span><br><span class="line"> (<span class="number">25</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-74.5280990600586,79.9946975708),(-126.7979965209961,48.0532989502)&quot;)</span><br><span class="line"> (<span class="number">26</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(-13.746399879455566,82.51779937740001),(-72.2656021118164,32.697899)&quot;)</span><br><span class="line"> (<span class="number">27</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(25.3379993439,39.828335),(-9.35523,0.0226000007242)&quot;)</span><br><span class="line"> (<span class="number">28</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(1.7605600357100002,48.069499969499994),(-8.68138980865,40.471926)&quot;)</span><br><span class="line"> (<span class="number">29</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(1.954759955406189,62.0635986328125),(-9.653610229492188,48.447898864746094)&quot;)</span><br><span class="line"> (<span class="number">30</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(173.82899475097656,31.3253993988),(27.221700668300002,0.042386)&quot;)</span><br><span class="line"> (<span class="number">31</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(7.8790798,61.583599090576),(2.040833,32.38410186767578)&quot;)</span><br><span class="line"> (<span class="number">32</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(58.890499114990234,31.989853),(32.2400016784668,10.350000381469727)&quot;)</span><br><span class="line"> (<span class="number">33</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(89.4672012329,31.909400939941406),(60.3820991516,8.30148983002)&quot;)</span><br><span class="line"> (<span class="number">34</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(111.63999939,31.4281005859375),(90.30120086669922,8.09912014008)&quot;)</span><br><span class="line"> (<span class="number">35</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(169.852005,31.919701),(113.069999695,8.178509712219238)&quot;)</span><br><span class="line"> (<span class="number">36</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(17.439699172973633,52.59120178222656),(6.504444,32.6635017395)&quot;)</span><br><span class="line"> (<span class="number">37</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(31.1583003998,52.527000427246094),(17.828399658203125,32.096801757799994)&quot;)</span><br><span class="line"> (<span class="number">38</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(30.60810089111328,57.78390121459961),(6.57944011688,53.0475006104)&quot;)</span><br><span class="line"> (<span class="number">39</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(31.044900894165,78.246101379395),(6.0741000175476,58.0994987487793)&quot;)</span><br><span class="line"> (<span class="number">40</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(42.4826011658,61.88520050048828),(31.9197998046875,32.01139831542969)&quot;)</span><br><span class="line"> (<span class="number">41</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(75.634444,63.566898345947266),(43.025978088378906,32.056098938)&quot;)</span><br><span class="line"> (<span class="number">42</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(98.3414,73.51780700683594),(32.75080108642578,32.1)&quot;)</span><br><span class="line"> (<span class="number">43</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(122.853996,71.97810363769531),(100.0989990234375,32.1506)&quot;)</span><br><span class="line"> (<span class="number">44</span>,<span class="number">65535</span>) <span class="operator">|</span> (coordinates)<span class="operator">=</span>(&quot;(177.74099731445312,71.697700500488),(123.48300170898438,32.482498)&quot;)</span><br><span class="line">(<span class="number">44</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><blockquote><p>To extract more detailed information, you can use the gevel extension,which is not included into the standard PostgreSQL distribution.</p></blockquote><h2 id="Operator-Class"><a href="#Operator-Class" class="headerlink" title="Operator Class"></a>Operator Class</h2><p>This query retrieves the list of support functions used by the point_ops operator class in a GiST (Generalized Search Tree) index within a PostgreSQL database</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amprocnum, amproc::regproc</span><br><span class="line"><span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid</span><br><span class="line"><span class="keyword">JOIN</span> pg_amproc amop <span class="keyword">ON</span> amprocfamily <span class="operator">=</span> opcfamily</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amprocnum;</span><br><span class="line"> amprocnum <span class="operator">|</span>         amproc         </span><br><span class="line"><span class="comment">-----------+------------------------</span></span><br><span class="line">         <span class="number">1</span> <span class="operator">|</span> gist_point_consistent</span><br><span class="line">         <span class="number">2</span> <span class="operator">|</span> gist_box_union</span><br><span class="line">         <span class="number">3</span> <span class="operator">|</span> gist_point_compress</span><br><span class="line">         <span class="number">5</span> <span class="operator">|</span> gist_box_penalty</span><br><span class="line">         <span class="number">6</span> <span class="operator">|</span> gist_box_picksplit</span><br><span class="line">         <span class="number">7</span> <span class="operator">|</span> gist_box_same</span><br><span class="line">         <span class="number">8</span> <span class="operator">|</span> gist_point_distance</span><br><span class="line">         <span class="number">9</span> <span class="operator">|</span> gist_point_fetch</span><br><span class="line">        <span class="number">11</span> <span class="operator">|</span> gist_point_sortsupport</span><br><span class="line">(<span class="number">9</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>必需的函数：</p><p>1 consistency function used to traverse the tree during search（检查查询条件是否与索引条目一致）</p><p>2 union function that merges rectangles计算边界框的并集）</p><p>5 penalty function used to choose the subtree to descend to when inserting an entry （计算插入新条目的代价）</p><p>6 picksplit function that distributes entries between new pages after a page split（决定节点分裂方式）</p><p>7 same function that checks two keys for equality（比较索引条目是否相同）</p><p>point_ops 支持的操作符如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, amopstrategy <span class="keyword">AS</span>  st, oprcode::regproc,</span><br><span class="line"><span class="keyword">left</span>(obj_description(opr.oid, <span class="string">&#x27;pg_operator&#x27;</span>),<span class="number">19</span>) description</span><br><span class="line"><span class="keyword">FROM</span> pg_am am</span><br><span class="line">        <span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid </span><br><span class="line">        <span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily </span><br><span class="line">        <span class="keyword">JOIN</span> pg_operator opr <span class="keyword">ON</span> opr.oid <span class="operator">=</span> amopopr</span><br><span class="line"><span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">      amopopr      <span class="operator">|</span> st <span class="operator">|</span>       oprcode       <span class="operator">|</span>     description     </span><br><span class="line"><span class="comment">-------------------+----+---------------------+---------------------</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span>(point,point)   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> point_left          <span class="operator">|</span> <span class="keyword">is</span> <span class="keyword">left</span> <span class="keyword">of</span></span><br><span class="line"> <span class="operator">&gt;&gt;</span>(point,point)   <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> point_right         <span class="operator">|</span> <span class="keyword">is</span> <span class="keyword">right</span> <span class="keyword">of</span></span><br><span class="line"> <span class="operator">~</span><span class="operator">=</span>(point,point)   <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> point_eq            <span class="operator">|</span> same <span class="keyword">as</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span><span class="operator">|</span>(point,point)  <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> point_below         <span class="operator">|</span> <span class="keyword">is</span> below</span><br><span class="line"> <span class="operator">|</span><span class="operator">&gt;&gt;</span>(point,point)  <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> point_above         <span class="operator">|</span> <span class="keyword">is</span> above</span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span>(point,point)  <span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> point_distance      <span class="operator">|</span> distance <span class="keyword">between</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,box)     <span class="operator">|</span> <span class="number">28</span> <span class="operator">|</span> on_pb               <span class="operator">|</span> point inside box</span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> <span class="number">29</span> <span class="operator">|</span> point_below         <span class="operator">|</span> deprecated, use <span class="operator">&lt;&lt;</span><span class="operator">|</span></span><br><span class="line"> <span class="operator">&gt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> point_above         <span class="operator">|</span> deprecated, use <span class="operator">|</span><span class="operator">&gt;&gt;</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,polygon) <span class="operator">|</span> <span class="number">48</span> <span class="operator">|</span> pt_contained_poly   <span class="operator">|</span> <span class="keyword">is</span> contained <span class="keyword">by</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,circle)  <span class="operator">|</span> <span class="number">68</span> <span class="operator">|</span> pt_contained_circle <span class="operator">|</span> <span class="keyword">is</span> contained <span class="keyword">by</span></span><br><span class="line">(<span class="number">11</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>操作符的名字通常并不能准确反映其语义，因此这个查询还会显示底层函数的名称和它们的描述。无论具体形式如何，这些操作符都处理几何对象之间的相对位置关系（如在左侧、右侧、上方、下方、包含、被包含）以及它们之间的距离。<br>与 B-tree 相比，GiST 提供了更多的策略（strategy）。一些策略号在多种类型的索引中是通用的，而另一些则是通过公式计算出来的（例如，策略号 28、48 和 68 实际上代表相同的策略：对矩形、多边形和圆形来说都是“被包含”）。此外，GiST 还支持一些已经过时的操作符名称（例如 &lt;&lt;| 和 |&gt;&gt;）。<br>一个操作符类（operator class）可能只实现了部分可用的策略。举个例子：点类型的操作符类不支持“包含”这个策略，但这个策略在那些具有可度量面积的几何体操作符类（如 box_ops、poly_ops 和 circle_ops）中是可用的。</p><h2 id="Search-for-Contained-Elements"><a href="#Search-for-Contained-Elements" class="headerlink" title="Search for Contained Elements"></a>Search for Contained Elements</h2><p>一个典型的可以通过索引加速的查询是返回指定区域内的所有点。例如，我们来查找距离莫斯科中心一度以内的所有机场：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> airport_code, airport_name<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">WHERE</span> coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.753220),1.0&gt;&#x27;</span>::circle;</span><br><span class="line"> airport_code <span class="operator">|</span>              ?<span class="keyword">column</span>?              </span><br><span class="line"><span class="comment">--------------+------------------------------------</span></span><br><span class="line"> SVO          <span class="operator">|</span> Sheremetyevo International Airport</span><br><span class="line"> VKO          <span class="operator">|</span> Vnukovo International Airport</span><br><span class="line"> DME          <span class="operator">|</span> Domodedovo International Airport</span><br><span class="line"> BKA          <span class="operator">|</span> Bykovo Airport</span><br><span class="line"> ZIA          <span class="operator">|</span> Zhukovsky International Airport</span><br><span class="line"> CKL          <span class="operator">|</span> Chkalovskiy Air Base</span><br><span class="line"> OSF          <span class="operator">|</span> Ostafyevo International Airport</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (costs off) <span class="keyword">SELECT</span> airport_code</span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">WHERE</span> coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.753220),1.0&gt;&#x27;</span>::circle;</span><br><span class="line">                               QUERY PLAN                                </span><br><span class="line"><span class="comment">-------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> airports_big</span><br><span class="line">   Recheck Cond: (coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.75322),1&gt;&#x27;</span>::circle)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> airports_gist_idx</span><br><span class="line">         Index Cond: (coordinates <span class="operator">&lt;</span>@ <span class="string">&#x27;&lt;(37.622513,55.75322),1&gt;&#x27;</span>::circle)</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过下图所示的一个简单示例来更仔细地查看这个操作符</p><p><img src="/images/RTree/rtree1.png" alt="rtree1"></p><p>如果以这种方式选择边界框，索引结构将如下所示：</p><p><img src="/images/RTree/rtree2.png" alt="rtree2"></p><p>包含操作符 &lt;@ 用于判断某个点是否位于指定矩形内部。对于该操作符，其一致性函数（consistency function）会在索引条目的矩形与指定矩形有任何重合点时返回“是”。这意味着，对于叶子节点中的索引条目（它们通常是退化为点的矩形），该函数实际上是在判断这个点是否被指定的矩形所包含。</p><p>例如，假设我们要查找位于矩形 (1,2)–(4,7) 内部的点，该矩形在下图中以阴影表示：</p><p><img src="/images/RTree/rtree3.png" alt="rtree3"></p><p>搜索从根节点开始。目标矩形与索引项 (0,0)–(3,4) 有重叠，但与 (5,3)–(9,9) 没有重叠，这意味着我们不需要进入第二棵子树。<br>在下一层中，目标矩形与 (0,3)–(3,4) 有重叠，并且与 (0,0)–(3,2) 有接触（边界相交），所以我们需要检查这两个子树。<br>一旦到达叶子节点，我们只需遍历它们包含的所有点，并返回那些满足一致性函数的点</p><p><img src="/images/RTree/rtree4.png" alt="rtree4"></p><p>B-tree 的搜索总是只选择一个子节点进行查找。而 GiST 的搜索可能需要扫描多个子树，特别是当它们的边界框（bounding boxes）发生重叠时。</p><h2 id="Nearest-Neighbor-Search"><a href="#Nearest-Neighbor-Search" class="headerlink" title="Nearest Neighbor Search"></a>Nearest Neighbor Search</h2><p>大多数索引支持的操作符（例如上一个例子中的 &#x3D; 或 &lt;@）通常被称为搜索操作符，因为它们在查询中定义了搜索条件。这类操作符是谓词，即它们返回一个逻辑值（真或假）。</p><p>但还有一类是排序操作符，它们返回的是参数之间的距离。这类操作符通常用于 ORDER BY 子句中，并且一般由具有 Distance Orderable 属性的索引所支持。该属性允许你快速找到指定数量的最近邻。这种类型的搜索被称为 k-NN（k 最近邻搜索）。</p><p>例如，我们可以查找最接近 Kostroma 的 10 个机场：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> airport_code, airport_name<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.926780,57.767943)&#x27;</span>::point LIMIT <span class="number">10</span>;</span><br><span class="line"> airport_code <span class="operator">|</span>                    ?<span class="keyword">column</span>?                    </span><br><span class="line"><span class="comment">--------------+------------------------------------------------</span></span><br><span class="line"> KMW          <span class="operator">|</span> Kostroma Sokerkino Airport</span><br><span class="line"> IAR          <span class="operator">|</span> Tunoshna Airport</span><br><span class="line"> IWA          <span class="operator">|</span> Ivanovo South Airport</span><br><span class="line"> VGD          <span class="operator">|</span> Vologda Airport</span><br><span class="line"> RYB          <span class="operator">|</span> Staroselye Airport</span><br><span class="line"> GOJ          <span class="operator">|</span> Nizhny Novgorod Strigino International Airport</span><br><span class="line"> CEE          <span class="operator">|</span> Cherepovets Airport</span><br><span class="line"> CKL          <span class="operator">|</span> Chkalovskiy Air Base</span><br><span class="line"> ZIA          <span class="operator">|</span> Zhukovsky International Airport</span><br><span class="line"> BKA          <span class="operator">|</span> Bykovo Airport</span><br><span class="line">(<span class="number">10</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">demo<span class="operator">=</span># EXPLAIN (costs off) <span class="keyword">SELECT</span> airport_code</span><br><span class="line"><span class="keyword">FROM</span> airports_big</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.926780,57.767943)&#x27;</span>::point LIMIT <span class="number">5</span>;</span><br><span class="line">                            QUERY PLAN                             </span><br><span class="line"><span class="comment">-------------------------------------------------------------------</span></span><br><span class="line"> Limit</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> airports_gist_idx <span class="keyword">on</span> airports_big</span><br><span class="line">         <span class="keyword">Order</span> <span class="keyword">By</span>: (coordinates <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;(40.92678,57.767943)&#x27;</span>::point)</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>由于索引扫描是逐个返回结果，并且可以在任何时刻停止，因此前几个值可以非常快速地获取到。</p><p>如果没有索引支持，要实现高效的搜索将非常困难。我们将不得不先查找某个特定区域内的所有点，然后逐步扩大该区域，直到返回所需数量的结果。<br>这将需要多次索引扫描，更不用说还存在一个难题：如何选择初始区域的大小以及每次扩展的增量。</p><p>你可以在系统目录中查看操作符的类型（其中 “s” 表示搜索操作符，”o” 表示排序操作符）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> amopopr::regoperator, amoppurpose, amopstrategy <span class="keyword">FROM</span> pg_am am</span><br><span class="line"><span class="keyword">JOIN</span> pg_opclass opc <span class="keyword">ON</span> opcmethod <span class="operator">=</span> am.oid</span><br><span class="line"><span class="keyword">JOIN</span> pg_amop amop <span class="keyword">ON</span> amopfamily <span class="operator">=</span> opcfamily <span class="keyword">WHERE</span> amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> opcname <span class="operator">=</span> <span class="string">&#x27;point_ops&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amopstrategy;</span><br><span class="line">      amopopr      <span class="operator">|</span> amoppurpose <span class="operator">|</span> amopstrategy </span><br><span class="line"><span class="comment">-------------------+-------------+--------------</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">1</span></span><br><span class="line"> <span class="operator">&gt;&gt;</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">5</span></span><br><span class="line"> <span class="operator">~</span><span class="operator">=</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>            <span class="number">6</span></span><br><span class="line"> <span class="operator">&lt;&lt;</span><span class="operator">|</span>(point,point)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">10</span></span><br><span class="line"> <span class="operator">|</span><span class="operator">&gt;&gt;</span>(point,point)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">11</span></span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">-</span><span class="operator">&gt;</span>(point,point)  <span class="operator">|</span> o           <span class="operator">|</span>           <span class="number">15</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,box)     <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">28</span></span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">29</span></span><br><span class="line"> <span class="operator">&gt;</span><span class="operator">^</span>(point,point)   <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">30</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,polygon) <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">48</span></span><br><span class="line"> <span class="operator">&lt;</span>@(point,circle)  <span class="operator">|</span> s           <span class="operator">|</span>           <span class="number">68</span></span><br><span class="line">(<span class="number">11</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>为了支持这类查询，操作符类必须定义一个额外的支持函数：也就是距离函数（distance function），它会在索引项上被调用，用于计算该索引项中存储的值与另一个值之间的距离。</p><p>对于表示索引值的叶子节点元素，该函数必须返回与该值之间的距离。<br>如果是点（point）类型，这个距离就是常规的欧几里得距离，计算公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = sqrt((x₂-x₁)²+(y₂-y₁)²)</span><br></pre></td></tr></table></figure><p>对于一个内部节点，其距离函数必须返回其所有子叶节点中可能距离的最小值。<br>由于扫描所有子节点的条目代价较高，该函数可以乐观地低估这个距离（以牺牲效率为代价），但绝不能返回一个较大的值——否则将会破坏搜索的正确性</p><p>因此，对于一个由边界框（bounding box）表示的内部节点，其与某个点之间的距离可以按照常规数学意义来理解：<br>要么是该点到矩形边界的最小距离；要么是 0（如果该点在矩形内部）。<br>这个值可以在无需遍历矩形中所有子点的情况下轻松计算出来，<br>并且它保证不会大于矩形中任意一个子点与该查询点之间的实际距离</p><p>我们考虑一下寻离点（6，8）最近的3个值</p><p><img src="/images/RTree/rtree5.png" alt="rtree5"></p><p>搜索从根节点开始，根节点包含两个边界框（bounding box）。指定查询点到矩形 (0,0)–(3,4) 的距离被计算为到该矩形的角点 (3,4) 的距离，即 5.0。到另一个矩形 (5,3)–(9,9) 的距离为 0.0。（这里我会将所有的距离值四舍五入保留到小数点后一位，这种精度对于这个示例来说已经足够。）</p><p>子节点会按照距离增大的顺序被遍历。因此，我们首先进入右子节点，该节点包含两个矩形：(5,3)–(8,5) 和 (6,6)–(9,9)。到第一个矩形的距离是 3.0，到第二个矩形的距离是 0.0。<br>再次地，我们选择右子树，并进入包含三个点的叶子节点：点 (6,6) 的距离为 2.0，点 (8,9) 的距离为 2.2，点 (9,7) 的距离为 3.2。</p><p><img src="/images/RTree/rtree6.png" alt="rtree6"></p><p>因此，我们已经找到了前两个点：(6,6) 和 (8,9)。但该节点中的第三个点距离（查询点）要大于矩形 (5,3)–(8,5) 的距离。</p><p>所以我们需要进入左子节点，该节点包含两个点。到点 (8,5) 的距离是 3.6， 到点 (5,3) 的距离是 5.1。结果发现，之前那个子节点中的点 (9,7) 比左子树中的任何点都更接近查询点 (6,8)，因此我们可以将它作为第三个返回结果。</p><p><img src="/images/RTree/rtree7.png" alt="rtree7"></p><p>这个例子说明了内部条目的距离函数必须满足的要求。由于到矩形 (5,3)–(8,5) 的距离减小（3.0 而不是 3.6），导致需要额外扫描一个节点，因此搜索效率下降；不过，算法本身仍然是正确的。</p><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>当向 R 树中插入一个新键时，用于存放该键的节点是由penalty函数决定的：该节点的边界框（bounding box）大小应尽可能少地增加。</p><p><img src="/images/RTree/rtree8.png" alt="rtree8"></p><p>例如，点 (4,7) 将被插入到矩形 (5,3)–(9,9) 中，因为该矩形的面积只需增加 6 个单位；而如果插入到矩形 (0,0)–(3,4)，则其面积需要增加 12 个单位。在下一层（叶子层），该点也会按照相同的逻辑被加入到矩形 (6,6)–(9,9) 中。</p><p>假设一个页面最多可以容纳三个元素，那么当超出这个限制时，它必须被拆分成两个页面，<br>并且这些元素需要在新的页面之间重新分配。在这个示例中，分配结果看起来很明显，但在一般情况下，数据的分布并不那么简单。最重要的是，picksplit 函数会尽量减少边界框（bounding box）之间的重叠，目标是获得更小的矩形以及在页面之间均匀分布点。</p><p><img src="/images/RTree/rtree9.png" alt="rtree9"></p><h2 id="Exclusion-Constraints"><a href="#Exclusion-Constraints" class="headerlink" title="Exclusion Constraints"></a>Exclusion Constraints</h2><p>GiST 索引也可以用于排除约束（exclusion constraints）。排除约束确保：对任意两条堆表元组来说，它们在某些操作符意义下的指定字段不能彼此匹配。要实现这一点，必须满足以下条件：</p><ul><li>排除约束（exclusion constraint）必须由索引方法本身支持（即具备 Can Exclude 属性）。</li><li>所使用的操作符必须属于该索引方法的操作符类（operator class）；</li><li>操作符必须是可交换的：即满足 “a operator b &#x3D; b operator a” 这个条件。</li></ul><p>对于上面提到的 hash 和 btree 访问方法来说，唯一合适的操作符是等于（&#x3D;）。这实际上使排除约束退化成了唯一约束，因而没有太大实际用途</p><p>GiST 方法还支持另外两种适用的策略：</p><ul><li>重叠（overlapping）：由 &amp;&amp; 操作符表示</li><li>相邻（adjacency）：由 -|- 操作符表示（该操作符主要用于区间）</li></ul><p>我们来试试这个功能：创建一个约束，用于禁止机场之间距离太近。<br>这个条件可以这样表达：以机场坐标为圆心、指定半径的圆形不得彼此重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist (circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Moscow&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span>);</span><br><span class="line">ERROR:  conflicting key <span class="keyword">value</span> violates exclusion <span class="keyword">constraint</span> &quot;airports_data_circle_excl&quot;</span><br><span class="line">DETAIL:  Key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">38.1517</span>,<span class="number">55.5533</span>),<span class="number">0.2</span><span class="operator">&gt;</span>) conflicts <span class="keyword">with</span> existing key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">37.90629959106445</span>,<span class="number">55.40879821777344</span>),<span class="number">0.2</span><span class="operator">&gt;</span>).</span><br></pre></td></tr></table></figure><p>当定义一个排除约束（exclusion constraint）时，系统会自动创建一个索引来强制执行该约束。在本例中，这个索引是一个基于表达式的 GiST 索引。</p><p>我们来看一个更复杂的例子。假设我们允许机场之间距离很近，但前提是这些机场属于同一个城市。一种可行的解决方案是定义一个新的完整性约束，表达如下：如果两个圆（以机场坐标为圆心）发生重叠（&amp;&amp;），且它们对应的城市名称不同（!&#x3D;），则这种情况是不允许的。</p><p>尝试创建这样的约束会导致一个错误，因为对于 text 数据类型并没有可用的操作符类（operator class）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> airports_data_circle_excl;</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist ( circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>,</span><br><span class="line">(city<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span>) <span class="keyword">WITH</span> <span class="operator">!=</span></span><br><span class="line">);</span><br><span class="line">ERROR:  data type text has <span class="keyword">no</span> <span class="keyword">default</span> operator class <span class="keyword">for</span> access <span class="keyword">method</span> &quot;gist&quot;</span><br><span class="line">HINT:  You must specify an operator class <span class="keyword">for</span> the index <span class="keyword">or</span> <span class="keyword">define</span> a <span class="keyword">default</span> operator class <span class="keyword">for</span> the data type.</span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure><p>虽然 GiST 原生不支持 text 或 int 等有序类型，但借助 btree_gist 扩展，可以让这些类型也具备使用 GiST 进行等值&#x2F;比较操作的能力，从而用于复杂约束（如排除约束）或混合类型索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> EXTENSION btree_gist;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">ALTER TABLE</span> airports_data <span class="keyword">ADD</span> EXCLUDE <span class="keyword">USING</span> gist ( circle(coordinates,<span class="number">0.2</span>) <span class="keyword">WITH</span> <span class="operator">&amp;&amp;</span>,</span><br><span class="line">(city<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;en&#x27;</span>) <span class="keyword">WITH</span> <span class="operator">!=</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER TABLE</span></span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure><p>该约束已成功创建。现在我们无法添加名为 Zhukovsky 的机场（即使它属于同名城市），<br>因为它与莫斯科的几个机场之间的距离太近，违反了约束条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Zhukovsky&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">);</span><br><span class="line">ERROR:  conflicting key <span class="keyword">value</span> violates exclusion <span class="keyword">constraint</span> &quot;airports_data_circle_expr_excl&quot;</span><br><span class="line">DETAIL:  Key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>), (city <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;en&#x27;</span>::text))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">38.1517</span>,<span class="number">55.5533</span>),<span class="number">0.2</span><span class="operator">&gt;</span>, Zhukovsky) conflicts <span class="keyword">with</span> existing key (circle(coordinates, <span class="number">0.2</span>::<span class="type">double precision</span>), (city <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;en&#x27;</span>::text))<span class="operator">=</span>(<span class="operator">&lt;</span>(<span class="number">37.90629959106445</span>,<span class="number">55.40879821777344</span>),<span class="number">0.2</span><span class="operator">&gt;</span>, Moscow).</span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure><p>但是我们可以在莫斯科创建机场</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">INSERT INTO</span> airports_data(</span><br><span class="line">airport_code, airport_name, city, coordinates, timezone</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line"><span class="string">&#x27;ZIA&#x27;</span>, <span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&quot;en&quot;: &quot;Moscow&quot;&#125;&#x27;</span>, point(<span class="number">38.1517</span>, <span class="number">55.5533</span>), <span class="string">&#x27;Europe/Moscow&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">demo<span class="operator">=</span># </span><br></pre></td></tr></table></figure><p>需要注意的是，尽管 GiST 支持大于、小于和等于等操作符，但 B-tree 在这方面效率要高得多，尤其是在访问一段范围值时。因此，只有当确实有其他合理原因需要使用 GiST 索引时，<br>才有意义使用上面提到的 btree_gist 扩展技巧。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>访问方法属性（Access Method Properties）以下是 GiST 访问方法的属性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> a.amname, p.name, pg_indexam_has_property(a.oid, p.name) </span><br><span class="line"><span class="keyword">FROM</span> pg_am a, <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;can_order&#x27;</span>, <span class="string">&#x27;can_unique&#x27;</span>, <span class="string">&#x27;can_multi_col&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;can_exclude&#x27;</span>, <span class="string">&#x27;can_include&#x27;</span> </span><br><span class="line">]) p(name)</span><br><span class="line"><span class="keyword">WHERE</span> a.amname <span class="operator">=</span> <span class="string">&#x27;gist&#x27;</span>;</span><br><span class="line"> amname <span class="operator">|</span>     name      <span class="operator">|</span> pg_indexam_has_property </span><br><span class="line"><span class="comment">--------+---------------+-------------------------</span></span><br><span class="line"> gist   <span class="operator">|</span> can_order     <span class="operator">|</span> f</span><br><span class="line"> gist   <span class="operator">|</span> can_unique    <span class="operator">|</span> f</span><br><span class="line"> gist   <span class="operator">|</span> can_multi_col <span class="operator">|</span> t</span><br><span class="line"> gist   <span class="operator">|</span> can_exclude   <span class="operator">|</span> t</span><br><span class="line"> gist   <span class="operator">|</span> can_include   <span class="operator">|</span> t</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>GiST 索引不支持唯一约束（Unique constraints）和排序（sorting）。GiST 索引可以通过额外的 INCLUDE 列来创建。正如我们所知，我们可以在多个列上构建索引，也可以将其用于完整性约束（integrity constraints）。</p><p>索引级别属性（Index-level properties）。这些属性是在索引层面定义的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, p.name) </span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;clusterable&#x27;</span>, <span class="string">&#x27;index_scan&#x27;</span>, <span class="string">&#x27;bitmap_scan&#x27;</span>, <span class="string">&#x27;backward_scan&#x27;</span> </span><br><span class="line">]) p(name);</span><br><span class="line">     name      <span class="operator">|</span> pg_index_has_property </span><br><span class="line"><span class="comment">---------------+-----------------------</span></span><br><span class="line"> clusterable   <span class="operator">|</span> t</span><br><span class="line"> index_scan    <span class="operator">|</span> t</span><br><span class="line"> bitmap_scan   <span class="operator">|</span> t</span><br><span class="line"> backward_scan <span class="operator">|</span> f</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>GiST 索引可以用于聚簇（clusterization）操作。在数据检索方式方面，GiST 支持常规（逐行）索引扫描和位图扫描（bitmap scan）。但 GiST 不支持反向扫描（backward scanning）。</p><p>列级别属性（Column-level properties）：大多数列属性是在访问方法（access method）级别定义的，并且保持不变。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;orderable&#x27;</span>, <span class="string">&#x27;search_array&#x27;</span>, <span class="string">&#x27;search_nulls&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line"> </span><br><span class="line">     name     <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------+------------------------------</span></span><br><span class="line"> orderable    <span class="operator">|</span> f</span><br><span class="line"> search_array <span class="operator">|</span> f</span><br><span class="line"> search_nulls <span class="operator">|</span> t</span><br><span class="line">(<span class="number">3</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>所有与排序相关的属性都是禁用的。</p><p>GiST 索引允许 NULL 值存在，但处理效率并不高。一般认为，NULL 值不会扩展边界框（bounding box），所以这些值会被随机插入某个子树中。因此，在查询时需要遍历整棵 GiST 树来查找这些值。</p><p>不过，有少数列级属性是依赖于具体操作符类（operator class）的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;airports_gist_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> t</span><br><span class="line"> distance_orderable <span class="operator">|</span> t</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><p>GiST 索引允许执行索引仅扫描（Index-only scan），因为叶子节点中保留了完整的索引键值。</p><p>正如前文所述，某些操作符类（operator class）提供了用于最近邻搜索的距离操作符。<br>对于 NULL 值，距离计算结果为 NULL，这种情况下这些值会排在最后返回（类似 B-tree 中的 NULLS LAST 语法）。</p><p>然而，对于范围类型（range types）而言，并不存在“距离操作符”（因为它们表示的是线段，也就是线性几何体，而不是面状几何体）。所以，当索引建立在这些类型上时，上述性质会有所不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE TABLE</span> reservations(during tsrange);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> reservations <span class="keyword">USING</span> gist(during);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">demo<span class="operator">=</span># <span class="keyword">SELECT</span> p.name, pg_index_column_has_property(<span class="string">&#x27;reservations_during_idx&#x27;</span>, <span class="number">1</span>, p.name)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">unnest</span>(<span class="keyword">array</span>[</span><br><span class="line"><span class="string">&#x27;returnable&#x27;</span>, <span class="string">&#x27;distance_orderable&#x27;</span></span><br><span class="line">]) p(name);</span><br><span class="line">        name        <span class="operator">|</span> pg_index_column_has_property </span><br><span class="line"><span class="comment">--------------------+------------------------------</span></span><br><span class="line"> returnable         <span class="operator">|</span> t</span><br><span class="line"> distance_orderable <span class="operator">|</span> f</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol><li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一个示例涉及在平面上对点（或其他几何形状）进行索引。常规的B树无法用于这种数据类型，因为点没有定义比较运算符。显然，我们可以自己实现这样的运算符，但几何形状需要索引支持完全不同的操作。我将只讨论其中的两种：搜索特定区域内包含的对象和最近邻搜索。&lt;/p&gt;
&lt;p&gt;R树在平面上</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
  </entry>
  
  <entry>
    <title>GiST framework</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/12/01/postgresql/GiST/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/12/01/postgresql/GiST/</id>
    <published>2025-12-01T00:40:54.000Z</published>
    <updated>2025-12-30T08:39:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>Gist（Generalized Search Tree，广义搜索树）是一种访问方法(是一个索引框架)，本质上是对支持值之间相对位置关系的数据类型的平衡搜索树的一种泛化。B-tree 只能用于可排序的数据类型，即那些支持比较操作（比如大于、小于等）。对于这类类型，B-tree 的支持是非常高效的。而 Gist 则更为通用，它的操作符类（operator class）允许用户定义任意的数据分布规则，从而控制树的构造方式。因此，Gist 索引可以用于实现不同的数据结构，例如：</p><ul><li>R-tree（二维&#x2F;多维空间数据）</li><li>RD-tree（集合之间的相似性度量）</li><li>签名树（类似 Bloom filter 的结构，用于快速过滤模糊匹配，比如文本）</li></ul><p>由于 PostgreSQL 的可扩展性，你可以通过实现索引引擎的接口，从零开始创建一个新的访问方法（access method）。但是，除了设计索引逻辑之外，你还需要定义页面布局、高效的锁策略，以及其它底层支持功能。这一切都需要强大的编程能力和大量的实现工作。Gist 简化了这项任务，它处理了所有低层次的技术细节，并提供了搜索算法的基础框架。如果你想让某个新的数据类型支持 Gist 方法，你只需要添加一个新的操作符类（operator class），其中包含大约十几个支持函数（support functions）。与 B-tree 的“简单”操作符类不同，Gist 的操作符类承载了主要的索引逻辑。因此，从这个角度看，Gist 可以被认为是构建新访问方法的一个框架。</p><p>每个属于叶子节点的条目（称为“叶子条目”）都包含一个谓词（逻辑条件）和一个指向堆中元组（heap tuple）的引用。索引键（index key）必须满足这个谓词；至于这个键是否直接出现在条目中并不重要。（叶子节点中每一项不是“具体的值”，而是“某种条件”——这个条件是能覆盖实际数据的逻辑表达式。）</p><p>每个内部节点中的条目（称为“内部条目”）也包含一个谓词，以及一个指向子节点的引用；子树中所有的数据都必须满足这个谓词。换句话说，内部节点条目的谓词是其所有子节点谓词的“并集”。GiST 的这个重要特性（即“内部节点的谓词是子节点谓词的并集”）实现了类似于 B-tree 中的简单排序（simple ranking）功能（GiST 通过组织谓词的包含关系，实现了类似于 B-tree 按顺序剪枝的搜索效率）。</p><p>GiST 树的搜索依赖于 一致性函数（consistency function），它是由操作符类（operator class）定义的一种支持函数。</p><p>一致性函数会在某个索引项上被调用，用来判断这个条目的谓词是否与搜索条件一致（即与“索引列的操作符表达式”是否可能匹配）。对于内部节点的条目，一致性函数用于判断是否需要进入对应的子树；对于叶子节点的条目，它用于判断这个索引键是否满足查询条件</p><p>搜索从根节点开始，这是树形结构中常见的做法。一致性函数（consistency function）决定哪些子节点需要继续遍历，哪些可以被跳过。然后对选中的每个子节点重复这一过程；与 B-tree 不同，GiST 可能会同时有多个符合条件的子节点。被一致性函数选中的叶子节点条目将作为查询结果返回</p><p>GiST 的搜索始终是深度优先的：算法会尽可能尽快到达叶子页面。这种策略对返回前几条结果（Top-N 查询）尤其有利。</p><p>在向 GiST 树中插入一个新值时，无法使用一致性函数（consistent()），因为我们需要精确选择一个子节点进行插入。插入逻辑依赖于 penalty() 函数，去评估每个候选子节点“因插入新值而造成的扩展代价”；最终选择 penalty 最小的子节点 来插入。</p><p>和B树索引一样，叶子结点没有空间会造成页面分裂（split），split需要两个函数，一个负责在新老节点之间分布数据，另一个函数则对两个谓词进行并集操作，以更新父节点的谓词</p><p>随着新值不断插入，已有的谓词会不断扩大，而这些谓词通常只有在页面分裂或整个索引重建时才会被缩小。因此，频繁更新 GiST 索引可能会导致其性能下降</p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><ol><li>Egor Rogov, <em>PostgreSQL 14 Internals</em>, <a href="https://postgrespro.com/community/books/internals">https://postgrespro.com/community/books/internals</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gist（Generalized Search Tree，广义搜索树）是一种访问方法(是一个索引框架)，本质上是对支持值之间相对位置关系的数据类型的平衡搜索树的一种泛化。B-tree 只能用于可排序的数据类型，即那些支持比较操作（比如大于、小于等）。对于这类类型，B-tre</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="pginternal" scheme="https://jeffrey-fly-github-io.pages.dev/tags/pginternal/"/>
    
  </entry>
  
  <entry>
    <title>Lehman–Yao B-tree</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/11/22/database/Lehman%E2%80%93Yao-B-tree/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/11/22/database/Lehman%E2%80%93Yao-B-tree/</id>
    <published>2025-11-22T01:24:06.000Z</published>
    <updated>2025-12-30T07:56:30.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Lehman–Yao-B-Trees"><a href="#1-Lehman–Yao-B-Trees" class="headerlink" title="1. Lehman–Yao B*-Trees"></a>1. Lehman–Yao B*-Trees</h2><p>Lehman–Yao构造了一个供并发进程使用的数据结构。该数据结构是 Wedekind提出的 B*-树的一个简单变体（其基础是 Bayer 和 McCreight定义的 B 树）。<br>Lehman–Yao B*-树定义如下。</p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><ol><li>Each path from the root to any leaf has the same length, h.</li><li>内部节点（非 root、非叶子）至少要有 k + 1 个孩子（sons）。 (k is a tree parameter; 2k is the maximum number of elements in a node, neglecting the “high key,” which is explained below.)</li><li>root要么是页节点要么至少有两个孩子（sons）</li><li>每个node最多有2k+1个孩子（sons）</li><li>Lehman–Yao B-tree中的所有数据的键（key）都存储在叶子节点中，叶子节点还包含指向数据库记录的指针（每一条记录都与一个 key 对应）。<br>非叶子节点包含指针，以及用于沿着这些指针继续查找的 key 值（b+ tree）。</li></ol><p>B*-树的节点看起来如图 1 所示。Ki 表示 key 域的实例Pi 表示指针。Pi 可以指向其他节点，或者——在叶子节点的情况下——指向与存储在叶子节点中的 key 值关联的记录。这种安排使得在我们的模型中，叶子节点和非叶子节点的结构基本相同。M 是一个标记，用于指示该节点是叶子节点，它占据了非叶子节点中第一个指针的位置。图 2 显示了一个 B*-树示例。</p><h3 id="1-2-Sequencing（顺序规则）"><a href="#1-2-Sequencing（顺序规则）" class="headerlink" title="1.2 Sequencing（顺序规则）"></a>1.2 Sequencing（顺序规则）</h3><ol><li>每个节点内部，key 按升序排列。</li><li>在 B*-tree 中，有时会在非叶子节点追加一个额外的值，称为 “high key”（见图 3）。</li><li>在任意节点 N 中，每个指针 Pi 指向一个子树 Ti（Pi 指向的节点为 Ti 的根）。Ti 中存储的 key 值被 Pi 左右的两个 key （Ki 和 Ki+1）界定。 这就给非叶子节点提供了一组 (pointer, value) 对    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key(Ti) ∈ (Ki-1, Ki]</span><br></pre></td></tr></table></figure> 其中，k0 &#x3D; -∞（在 N 中物理上不存在），K2k+1 &#x3D; high key（如果存在），high key 提供了 Pi 指向的子树的上界，因此它也是以 N 为根的子树中所有值的上界。<br>叶子节点 定义类似（见图 3）：Ki &#x3D; 叶子中存储的 key；Pi &#x3D; 指向对应记录的指针</li></ol><h3 id="1-3-Insertion-Rule-插入规则"><a href="#1-3-Insertion-Rule-插入规则" class="headerlink" title="1.3 Insertion Rule(插入规则)"></a>1.3 Insertion Rule(插入规则)</h3><ol><li>如果一个叶子节点的条目（entries）少于 2k 个，那么一个新的条目以及指向其对应记录的指针可以直接插入到该节点中。</li><li>如果一个叶子节点已有 2k 个条目，则插入新的条目时，需要通过将该节点分裂为两个节点来进行，每个新节点包含原节点一半的条目。新的条目会被插入到这两个节点中的一个（在合适的位置）。由于其中一个节点是新创建的，因此必须在原单节点的父节点中插入一个新的指针。这个新的指针指向新节点；新的键值是对应于原节点拆分后左半部分的键值。此外，需要为这两个新节点分别设置高键（high key）。图 4 展示了一个节点分裂的示例。</li><li>对非叶子节点的插入操作与叶子节点完全相同，只是指针指向的是子节点，而不是数据记录。</li></ol><p>一个节点（按照上面给出的规则），如果条目数少于 2k，则称其为“安全节点”（就插入操作而言），因为插入可以通过对该节点的简单操作完成。同样，如果一个节点有 2k 个条目，则称其为“非安全节点”，因为必须进行分裂操作。对节点的删除操作也有类似的定义：如果删除可以在节点内完成而不会影响其他节点，则该节点称为“安全节点”；反之，如果删除会影响其他节点，则称为“非安全节点”。也就是说，如果节点的条目数多于 k + 1，则安全；如果恰好有 k + 1 条目，则非安全。</p><p>一个简单的例子就足以说明，对 B*-树进行并发操作的简单做法是错误的。<br>考虑图 5a 所示的 B*-树片段。假设有两个进程：一个搜索值 15，另一个插入值 9。插入操作应当导致树结构修改为图 5b 所示的样子。现在考虑下面这一系列操作：  </p><table><thead><tr><th>select(15)</th><th>insert(9)</th></tr></thead><tbody><tr><td>C&lt;-read(x)</td><td></td></tr><tr><td></td><td>A&lt;-read(x)</td></tr><tr><td>exam C;get ptr to y</td><td></td></tr><tr><td></td><td>exam A;get ptr to y</td></tr><tr><td></td><td>A &lt;- read(y)</td></tr><tr><td></td><td>insert 9 into A; must split into A, B</td></tr><tr><td></td><td>PUT(B, Y’)</td></tr><tr><td></td><td>PUT(A, Y)</td></tr><tr><td></td><td>Add to node x a pointer to node y’.</td></tr><tr><td>C &lt;- read(y)</td><td></td></tr><tr><td>error!15 not found</td><td></td></tr></tbody></table><p>问题在于，搜索操作首先返回指向 y 的指针（从 X 获得），然后才读取包含 y 的页面。在这两个操作之间，插入操作已经修改了树的结构。</p><h2 id="2-Previous-Approaches"><a href="#2-Previous-Approaches" class="headerlink" title="2. Previous Approaches"></a>2. Previous Approaches</h2><p>前面的例子表明，对并发 B 树问题采取简单做法是行不通的：如果不防范并发操作带来的潜在问题，多个进程的操作可能导致结果不正确。为了更好地理解这个问题，我们在此简要概述一些已经提出的其他方法和解决方案。</p><p>针对并发 B 树问题的第一个解决方案是由 Samadi 提出的.他的做法是最直接的一种，并且是最早考虑并发问题的方法。该方案简单地使用信号量来独占锁定任何一次树结构修改可能经过的整条路径。这实际上锁定了受影响的最高节点所在的整个子树</p><p>Bayer 和 Schkolnick 提出的算法对 Samadi 的方法进行了实质性的改进。他们提出了一种用于 B*-树并发操作的方案；该方案包含一些参数，可以根据所需的并发程度和类型进行设置。<br>首先，修改操作会对树的上部节点加写者排他锁（writer-exclusion locks）（这种锁只排斥其他写者，而不会阻止读者）。<br>当需要真正进行修改操作时，会施加独占锁（exclusive locks），大多应用在树的下部节点。<br>这种对独占锁的稀疏使用提高了算法的并发性能。</p><p>Miller 和 Snyder [12] 研究了一种方案，该方案锁定树中一个有界大小的区域。该算法使用先导锁（pioneer locks）和跟随锁（follower locks），以防止其他进程进入当前进程正在修改的树区域。被锁定的区域沿树向上移动，同时执行相应的修改操作.在使用队列管理的锁策略的帮助下，沿树向下移动的读者可以“越过”被锁定的区域，从而避免死锁。这种算法与本文提出的算法的权衡在于：本文的算法锁定树的区域明显更小，但需要对普通的 B-tree 或 B*-tree 结构进行稍微的修改，以便支持并发。</p><p>Ellis [6] 提出了一种针对 2-3 树的并发解决方案。文中采用了几种方法以提高并发能力，并且（据称）这些方法可以很容易地推广到 B 树。<br>该论文应用了两种思想：一是在相反方向上对一组数据进行读写（由 Lamport [11] 提出）；二是允许数据结构暂时出现轻微退化，同时允许进程不必立即完成操作，可以将工作推迟到更合适的时间再执行。</p><p>Guibas 和 Sedgewick [6a] 提出了一种针对平衡树的统一“双色框架”（dichromatic framework）。这是一种研究平衡树的简化方法：它将所有平衡树方案归约为“带颜色”的二叉树的特例，并具有概念上的清晰性。这些作者利用他们的框架研究一种自上而下的并发锁定方案，其中包括在沿树向下访问时对“几乎满的”节点进行分裂。我们预计，他们的方案将锁定比我们的方案更多的节点（降低并发性），并且需要略多的存储空间。</p><p>另一种针对 B 树并发操作的方法目前正在由 Kwong 和 Wood [10] 进行研究。</p><h2 id="3-Blink-Tree-for-Concurrency"><a href="#3-Blink-Tree-for-Concurrency" class="headerlink" title="3. Blink-Tree for Concurrency"></a>3. Blink-Tree for Concurrency</h2><p>B-link 树是一种在 B*-树基础上修改而成的结构，它在每个节点中增加了一个“链接（link）”指针字段（记作 P2k+1 ——见图 6）。<br>（B-link-tree 的发音是 “Blink-tree”。）   </p><p>这个链接指针指向当前节点所在层的下一个节点；只有在该层最右侧的节点中，这个链接指针才是空指针（null）。这样的链接指针定义是自洽的，因为所有叶子节点都位于树的同一层。  </p><p>因此，在 B-link 树中，同一层的所有节点都被连接成一条链表，如图 7 所示。</p><p>Link 指针的目的，是提供一种到达某个节点的额外途径。<br>当一个节点因为数据溢出而被分裂时，原来的单一节点会被两个新的节点取代。</p><p>在分裂后：</p><ul><li><p>第一个新节点的 link 指针指向第二个新节点；</p></li><li><p>第二个新节点的 link 指针则保存了原来旧节点的 link 指针内容。</p></li></ul><p>通常情况下，第一个新节点会占用旧节点在磁盘上的同一个物理页面。</p><p>设计这个方案的意图是：<br>因为这两个新节点被 link 指针连接起来，在父节点中的正确指针尚未更新之前，它们在功能上仍然等价于原来的那个单一节点。<br>Blink-tree 的精确查找与插入算法将在接下来的两个章节中给出。</p><p>对于树中的任意一个节点（处于某一层且不是该层的第一个节点），通常会有两种指针指向它：</p><p>来自其父节点的“子指针”（son pointer），以及</p><p>来自其左兄弟节点的 link 指针。</p><p>当一个节点被插入到树中时，这两个指针之中必定有一个会先被创建。<br>我们规定：在这两个指针中，link 指针必须最先存在。<br>也就是说，一个节点在树中出现时，可以暂时没有父节点的指针指向它，但必须已经有一个左兄弟指向它的 link 指针。</p><p>这种结构依然被定义为一个合法的树结构，因为新的“右兄弟”节点可以通过“左兄弟”到达。（这两个兄弟节点在功能上仍然可以视作一个节点。）</p><p>当然，为了保证良好的查找效率，来自父节点的指针必须尽快补上。</p><p>Link 指针的优势在于：它会在节点发生分裂时同步建立。<br>因此，即使针对新节点的常规树指针尚未全部更新完毕，link 指针仍可作为一种“临时修补”机制，使并发操作保持正确性。</p><p>当查找键大于节点的最大键值（由 high key 标识）时，这表明树结构已经发生变化，此时应通过 link 指针继续访问右兄弟节点。<br>虽然这种方式略低效一些（因为需要额外一次磁盘读取来跟随 link 指针），但它仍然是到达目标叶子节点的正确路径。</p><p>由于节点分裂本身属于例外情况，link 指针的实际使用频率应该非常低。</p><p>Blink-tree 结构的另一个优点是：在对树进行顺序遍历时，link 指针可以用于快速按“按层次优先（level-major）”的顺序检索树中的所有节点，或者，例如，只检索所有叶子节点。</p><h2 id="4-THE-SEARCH-ALGORITHM"><a href="#4-THE-SEARCH-ALGORITHM" class="headerlink" title="4. THE SEARCH ALGORITHM"></a>4. THE SEARCH ALGORITHM</h2><h3 id="4-1-算法示意图（Algorithm-Sketch）"><a href="#4-1-算法示意图（Algorithm-Sketch）" class="headerlink" title="4.1 算法示意图（Algorithm Sketch）"></a>4.1 算法示意图（Algorithm Sketch）</h3><p>要在树中查找一个值 v，搜索过程从根节点开始，沿树向下比较 v 与每个节点中的键值。在每个节点中，比较键值后，决定沿节点中哪条现有指针继续向下搜索，指示应沿该指针前往下一层节点，或直接到达叶子（记录）节点。</p><p>如果搜索过程中检查某个节点时，发现该节点中的最大值小于 v，则可以推断出当前节点发生了一些变化，而这些变化在搜索检查其父节点时尚未反映到父节点中。</p><p>这意味着当前节点已经被分裂成两个（或更多）新的节点。<br>此时，搜索必须纠正其在树中的位置错误：不再按照普通的父节点子指针（son pointer）前进，而是沿新分裂节点的 link 指针继续搜索。</p><p>搜索过程最终会到达 v 应该所在的叶子节点（如果 v 存在的话）。此时，该节点要么包含 v，要么不包含 v 且节点中的最大值大于 v。<br>因此，该算法能够正确地判断 v 是否存在于树中。</p><h2 id="4-2-算法"><a href="#4-2-算法" class="headerlink" title="4.2 算法"></a>4.2 算法</h2><p><strong>搜索（Search）</strong><br>该过程用于在树中查找一个值 𝑣。如果 𝑣 存在于树中，过程结束时：𝐴包含包含 𝑣 的节点 𝑡<br>包含指向与 𝑣 关联的记录的指针；如果 𝑣 不存在于树中，𝐴 将包含 𝑣 如果存在的话应该所在的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Search(v):</span><br><span class="line">    ...</span><br><span class="line">    if v exists:</span><br><span class="line">        A = 节点页 containing v</span><br><span class="line">        t = 指向 v 的记录</span><br><span class="line">    else:</span><br><span class="line">        A = 节点页 where v would be</span><br><span class="line">        t = null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下文算法中使用的符号在第 2 节中定义。<br>在此过程中，我们使用了一个辅助操作 scannode，其定义如下：</p><blockquote><p>x &lt;- scannode(u, A) denotes the operation of examining the tree node in memory block A for value u and returning the appropriate pointer from A (into x).</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">procedure search(u)</span><br><span class="line">current &lt;- root;</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">while current is not a leaf do </span><br><span class="line">begin</span><br><span class="line">  current &lt;- scannode(u, A);</span><br><span class="line">  A &lt;- get(current) </span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">while t &lt;- scannode(u, A) = link ptr of A do</span><br><span class="line">begin</span><br><span class="line">  current + t ;</span><br><span class="line">  A &lt;- get(current)</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">if v is in A then done “success” else done “failure”</span><br></pre></td></tr></table></figure><p>请注意，这种搜索过程非常简单，其行为与非并发搜索完全相同，将 link 指针与其他指针同等对待。</p><p>还要注意，该过程不进行任何形式的加锁。<br>这与传统的数据库搜索算法形成对比（例如 Bayer 和 Schkolnick [3] 所述），在那些算法中，所有搜索操作都会对它们访问的节点进行读锁。</p><h2 id="5-THE-INSERTION-ALGORITHM"><a href="#5-THE-INSERTION-ALGORITHM" class="headerlink" title="5. THE INSERTION ALGORITHM"></a>5. THE INSERTION ALGORITHM</h2><h3 id="5-1-算法示意图（Algorithm-Sketch）"><a href="#5-1-算法示意图（Algorithm-Sketch）" class="headerlink" title="5.1 算法示意图（Algorithm Sketch）"></a>5.1 算法示意图（Algorithm Sketch）</h3><p>要在树中插入一个值 𝑢 我们执行的操作与前面描述的搜索过程类似。从根节点开始，沿树向下扫描，直到到达应该包含 𝑢 的叶子节点。同时，我们在下降过程中记录每一层中被访问过的最右节点。沿树的下降过程实际上就是在搜索 𝑢 的正确插入位置（比如称该节点为节点 𝑎 ）。</p><p>将值 u 插入叶子节点时，可能需要对该节点进行分裂（当节点不安全时）。<br>在这种情况下，我们对节点进行分裂（如图 8 所示），用两个新节点 a’（a 的新版本，写回同一磁盘页面）和 b’ 替换原来的节点 a。节点 a’ 和 b’ 的内容与原节点 a 相同，只是增加了值 u。随后，我们沿着先前记录的搜索路径回溯树的上层，在叶子节点的父节点中插入新节点 b’ 的条目以及 a’ 的新 high key。</p><p>死锁的避免是由锁定方案的良序性（well-ordering）所保证的，如下所示。<br>需要注意的是，当我们沿树向上回溯时，由于节点可能被分裂，我们必须插入新指针的节点可能并不是下降过程中经过的那个节点。换句话说，我们在下降过程中使用的旧节点可能已经被分裂；此时，正确的插入位置就在原预期插入位置右侧的某个节点。我们通过 link 指针 来找到这个节点。</p><h3 id="5-2-算法"><a href="#5-2-算法" class="headerlink" title="5.2 算法"></a>5.2 算法</h3><p>在下文的算法中，有些过程被视为原语操作（就像上文的 scannode 一样），因为它们容易实现，并且其具体操作对本文的目的而言并不重要。例如：</p><blockquote><p>A &lt;- node.insert (A, w, v) denotes the operation of inserting the pointer w and the value v into the node contained in A.<br>u &lt;- allocate(2 newpage for B) denotes the operation of allocating a new page on the disk. The node contained in B will be written onto this page, using the pointer u.<br>“A, B &lt;- rearrange old A, adding ..” denotes the operation of splitting A into two nodes, A and B, in core.</p></blockquote><p><strong>插入（Insert）</strong>。该算法负责将一个值 v（以及其关联的记录）插入到树中。当算法结束时，值 v 已成功插入到树中，并且在必要的情况下，算法会在从叶子向上回溯的过程中对相应的节点进行分裂。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">procedure insert(v)</span><br><span class="line">initialize stack;</span><br><span class="line">current &lt;- root;</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">while current is not a leaf do</span><br><span class="line">begin</span><br><span class="line">  t &lt;-  current;</span><br><span class="line">  current &lt;- scannode( v, A);</span><br><span class="line">  if new current was not link pointer in A then</span><br><span class="line">    push(t);</span><br><span class="line">  A &lt;- get(current);</span><br><span class="line">end;</span><br><span class="line">lock(current);</span><br><span class="line">A &lt;- get(current);</span><br><span class="line">move.right;</span><br><span class="line">if v is in A then stop “v already exists in tree”;</span><br><span class="line">w &lt;- pointer to pages allocated for record associated with v; </span><br><span class="line">Doinsertion:</span><br><span class="line">if A is safe then</span><br><span class="line">begin</span><br><span class="line">  A &lt;-  node.insert(A, w, v); </span><br><span class="line">  put(A, current); </span><br><span class="line">  unLock(current);</span><br><span class="line">end else begin</span><br><span class="line">  u &lt;- allocate(1 new page for B);</span><br><span class="line">  A, B &lt;- rearrange old A, adding v and w, to make 2 nodes,</span><br><span class="line">    where (link ptr of A, link ptr of B) &lt;- (u, link ptr of old A);</span><br><span class="line">  y &lt;- max value stored in new A;</span><br><span class="line">  put(B, u)</span><br><span class="line">  put(A, current); </span><br><span class="line">  oldnode &lt;- current;</span><br><span class="line">  v &lt;- Y;</span><br><span class="line">  w &lt;- u;</span><br><span class="line">  current &lt;- pop(stack); </span><br><span class="line">  lock(current);</span><br><span class="line">  A &lt;- get(current); </span><br><span class="line">  move.right; </span><br><span class="line">  unlock(oldnode);</span><br><span class="line">  goto Doinsertion</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Move.right. This procedure, which is called by insert, follows link pointers at a given level, if necessary.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure move.right</span><br><span class="line">while t &lt;- scannode(u, A) is a link pointer of A do</span><br><span class="line">begin</span><br><span class="line">  lock(t); </span><br><span class="line">  unlock(current); </span><br><span class="line">  current &lt;- t;</span><br><span class="line">A &lt;- get(current); </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>需要注意的是，该过程在向上回溯树时是 逐层进行的。此外，同时最多只会锁定三个节点，而这种情况发生的频率相对较低：仅在插入分裂节点的指针时，需要沿 link 指针向右移动 的情况下才会出现。此时，被锁定的节点包括：</p><ul><li><p>分裂节点的原始左半部分</p></li><li><p>分裂节点上一层的两个节点</p></li></ul><p>在插入沿右链移动的过程中需要锁定它们。</p><p>与传统方法相比（即只有在确定节点为安全节点时才释放锁），这种做法在 锁粒度和并发性能上都有显著改进。</p><p>该算法的正确性依赖于以下事实：树结构的任何变化（即任何节点的分裂）都会伴随一个 link 指针。节点分裂时，条目总是被移动到树的右侧，在右侧的新节点可以通过 link 指针被访问到，从而保证树的结构在并发操作下仍然可达且正确。</p><p>具体来说，对于任何层级的一个对象（与某个值相关联），我们总能大致知道它的正确插入位置，即我们在该层搜索时经过的“记录节点”。如果该对象的正确插入位置发生了移动，这种移动方式是可预知的：也就是节点分裂向右，留下的 link 指针使得搜索或插入操作仍然能够找到它。因此，从旧的“预期”插入位置开始，始终可以访问到对象的正确插入位置。</p><h2 id="6-CORRECTNESS-PROOF"><a href="#6-CORRECTNESS-PROOF" class="headerlink" title="6 CORRECTNESS PROOF"></a>6 CORRECTNESS PROOF</h2><p>为了证明系统的正确性，我们需要证明以下两个命题对每个进程都成立：</p><ol><li>该进程不会发生死锁（定理 1）；</li><li>当进程终止时，它已经正确地完成了所需的操作。<br>  更具体地说：</li></ol><ul><li>所有磁盘操作都保持树结构的正确性（定理 2）</li><li>除正在进行修改的进程之外，所有其他进程看到的树都是一致的（交互定理 3）。</li></ul><h3 id="6-1-无死锁性（Freedom-from-Deadlock-）"><a href="#6-1-无死锁性（Freedom-from-Deadlock-）" class="headerlink" title="6.1 无死锁性（Freedom from Deadlock ）"></a>6.1 无死锁性（Freedom from Deadlock ）</h3><p>首先，我们开始证明系统不存在死锁。<br>为此，我们对节点施加一个顺序：跨层从下到上、同层从左到右。下面的引理（Lemma：一种 辅助性结论，用于证明后续更大、更重要的定理（Theorem））对这一点进行了严格定义。<br><strong>引理 1</strong> 插入操作对节点加锁遵循一个良序（well-ordering：严格定义的、有序的顺序关系）关系<br><strong>证明</strong> 考虑在树的节点集合上定义如下顺序关系（&lt;）：</p><ol><li>在任意时刻 t，如果两个节点 a 和 b 与树根的距离不同（不在同一层级），那么当且仅当 b 离树根更近（处于更高层级）时，我们称 a &lt; b。</li><li>如果 a 和 b 与树根的距离相同（在同一层级），那么当且仅当 b 能通过从 a 开始沿着一条或多条链接指针到达（即 b 在 a 的右侧）时，我们称 a &lt; b。</li></ol><p>通过检查插入算法我们可以看到：如果在时间 t₀ 时 a &lt; b，那么在所有 t &gt; t₀ 的时间点都仍然有 a &lt; b。因为节点创建过程只是把一个节点 x 分裂成两个新节点 x′ 和 x″，并且满足 x′ &lt; x″，而且</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y&lt;x⟺y&lt;x′</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&lt;y⟺x′′&lt;y</span><br></pre></td></tr></table></figure><p>因此，这些节点形成了一个良序关系，插入者按照良序对节点加锁。一旦在某个节点上加锁，它不会再对该节点之下的任何节点加锁，也不会对同一层中位于左侧的节点加锁。<br>因此，插入者按照给定的良序对节点加锁。证毕。<br>由于插入者是唯一对节点加锁的过程，我们可以立即得到以下定理。  </p><p><strong>定理 1</strong>：无死锁性。 给定的系统不会产生死锁。</p><h3 id="6-2-树结构修改的正确性"><a href="#6-2-树结构修改的正确性" class="headerlink" title="6.2 树结构修改的正确性"></a>6.2 树结构修改的正确性</h3><p>为了确保树结构的完整性，我们必须检查所有修改树结构的操作。首先，需要注意的是，树结构的修改只能通过 “put” 操作 来完成。插入过程中算法中有三个地方会执行 put 操作：</p><ol><li>对安全节点重写时使用 “put(A, current)”。</li><li>对不安全节点的最右节点使用 “put(B, u)”。通过该操作，我们写入由节点分裂形成的两个新节点中的第二个节点。</li><li>对不安全节点使用 “put(A, current)”。这里写入的是两个新节点中的第一个（最左节点）。实际上，我们重写了树中已存在的页面（节点），并修改该页面的链接指针，使其指向由 “put(B, …)” 写入的新节点。</li></ol><p>注意，在算法中（针对不安全节点），“put(B, u)” 紧接在 “put(A, current)” 之前执行。我们将在下面的引理中证明，这种顺序实际上将两个 put 操作简化为本质上的一次操作。 </p><p><strong>引理 2</strong>. 操作 ‘put(B, u); put(A, current)’ 相当于对树结构的一次修改。<br>证明. 假设这两个操作分别写入节点 b 和 a。在执行 “put(B, u)” 时，没有其他节点指向正在写入的节点 b，因此该 put 操作对树结构没有影响。现在，当执行 “put(A, current)” 时，该操作修改了 current 指向的节点（节点 a）。修改内容包括将节点 a 的链接指针指向 b。此时，b 已经存在，并且 b 的链接指针指向与 a 的旧版本相同的节点。这样就实现了同时修改 a 并将 b 引入树结构。证毕。</p><p><strong>定理 2</strong>. 所有 put 操作都能正确地修改树结构。<br><strong>证明</strong><br>case 1： 对安全节点执行 “put(A, current)”。该操作只修改树中一个已加锁的节点，因此树的正确性得到保持。<br>case 2： 对不安全节点执行 “put(B, u)”。该操作不会改变树结构。<br>case 3： 对不安全节点执行 “put(A, current)”。根据引理，该操作既修改了当前节点（比如 a），又将另一个节点（比如 b，通过 “put(B, u)” 写入）引入树结构。与情况 1 类似，节点 a 在执行 “put(A, current)” 时已加锁。本例的区别在于该节点是不安全的，需要分裂。但根据引理，我们可以通过一次操作完成，保持树结构的正确性。证毕</p><h3 id="6-3-正确的交互"><a href="#6-3-正确的交互" class="headerlink" title="6.3 正确的交互"></a>6.3 正确的交互</h3><p>我们还需要证明，无论插入过程对树进行何种修改，其他进程仍能正确操作。<br><strong>定理 3</strong>：交互定理。 插入过程的操作不会破坏其他进程操作的正确性。</p><p>为了证明该定理，我们首先考虑搜索过程与插入操作的交互情况，然后考虑两个插入过程的交互情况。一般来说，为了证明插入者的操作不会破坏其他进程的正确性，我们需要考虑该进程相对于该操作的行为。在所有情况下，该操作都是原子的。</p><p>假设插入者在时间 t0 对节点 a 执行一次 “put” 操作。考虑另一个进程在时间 t′从磁盘读取节点 a 的情况。由于假设 “get” 和 “put” 操作是不可分割的，要么 t′&lt;t0​，要么  t0​ &lt; t′。我们将在下面的引理中证明，后一种情况不会产生问题。</p><p><strong>引理 3</strong><br>如果进程 𝑃 在某个时间 𝑡′ &gt; 𝑡0 读取节点 𝑎，其中 𝑡0 是插入进程 I 修改节点 𝑎 的时间，那么这一修改不会影响进程 𝑃 的正确性。</p><p><strong>证明</strong>. 考虑进程 P 通过节点 a 的路径。进程 P 在到达节点 a 之前所经过的路径不会被插入进程 I 改变。此外，根据上面的定理 2，进程 I 对树结构所做的任何修改都会产生一个正确的树（well-ording）。因此，进程 P 在 a 节点开始的路径（在时间 t&gt;t′t &gt; t’t&gt;t′）将无论修改如何都能正确执行。证毕。</p><p>为了便于将定理的证明分解成不同情况，这里列出在一个节点上对一个值可能执行的三种插入类型。</p><p>类型 1. 简单地将一个值及其关联指针添加到节点中。当节点是安全的（safe）时发生这种类型的插入。<br>类型 2. 对节点进行分裂，并将插入值放入分裂节点的左半部分。左半部分仍然是原来被分裂的节点。<br>类型 3. 类似地，对节点进行分裂，并将插入值放入分裂节点的右半部分。右半部分是新分配的节点。</p><p>现在我们开始定理的证明。我们注意到，定理的正确性涉及几个方面（情况），并将分别证明这些情况。</p><p>证明. 根据引理 3，只需考虑搜索或插入进程 𝑃 在插入进程 𝐼 修改节点之前开始读取该节点的情况。</p><p>第 1 部分. 考虑插入进程 I（在时间 t0 修改节点 n）与搜索进程 S（在时间 t′&lt; t0读取节点 n）之间的交互。记 n′ 为修改后的节点。（本节的论证同样适用于另一插入进程 I′与进程 I 交互的情况，且 I′正在执行搜索。）需要考虑的操作顺序是：S 读取节点 n；然后 I 将节点 n 修改为 n′；然后 S 根据 n 的内容继续搜索。<br>考虑三种插入类型：  </p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">Type 1</td><td align="left">进程 I 对节点 n 执行一次简单插入。如果 n 是叶子节点，插入进程不会改变任何指针。其结果等同于序列调度中 S 在 I 之前运行的情况。如果 n 是非叶子节点，则在 n 中插入一个指向下一层某节点 m′的指针&#x2F;值对。假设 m′是通过将 I 分裂为 I′ 和 m′ 创建的。唯一可能的交互是 S 在插入指向 m′ 的指针之前已经获得了指向 I 的指针。此时指向 I 的指针指向了 I′，而 S 将使用 I′中的 link pointer 访问 m′。因此搜索仍然是正确的。</td></tr><tr><td align="left">Types 2 and 3</td><td align="left">节点 n 在插入过程中被分裂为节点 n1′ 和 n2′。对于叶子节点的情况，搜索在 n 上的结果与在 n1′和 n2′上的结果相同，除了新插入的值 S 无法找到。 如果 n 不是叶子节点，则其下层的某个节点发生了分裂，导致一个新的指针&#x2F;值对被插入节点 n，从而使 n 本身也分裂。根据归纳法，下层节点的分裂是正确的。根据引理 3，下层节点的搜索也是正确的。因此，我们只需证明节点 n 的分裂是正确的。假设节点 n 分裂为节点 n1′ 和 n2′，它们包含与原节点 n 相同的指针集合，并增加了新插入的节点。则从节点 n 开始搜索，将到达下一层与从 n1′（带有指向 n2′的 link pointer）开始搜索时相同的节点集合。特殊情况是：如果搜索在读取节点 n 时，新插入的指针已经存在，本应沿该指针继续。此时实际跟随的指针位于新指针的左侧，这会将搜索引导到某个节点（假设为 k），它位于新指针指向的节点（假设为 m）左侧。然后沿 k 的 link pointer 最终到达 m，这仍然是正确的结果。（类型 3 的论证与类型 2 相同，只是新条目插入到新创建的半节点中，而不是旧半节点。但这对论证没有影响，因为节点在分裂发生前已被S读取。）</td></tr></tbody></table><p>第2部分。接下来我们考虑插入进程 I 与另一个插入进程 I’ 的交互情况。进程 I’ 可能正在搜索用于插入的正确节点、回溯到另一层，或者实际尝试将一个值&#x2F;指针对插入节点 n。如果 I’ 正在搜索一个用于插入值&#x2F;指针对的节点，则该搜索行为与普通搜索进程完全相同。因此，证明与上文针对搜索进程的证明相同。</p><p>第3部分。如果 I’ 因为下层节点分裂而需要回溯上行树，则 I’ 需要回到上层以便将指针插入到分裂节点的新半部分。</p><ul><li>回溯是使用在下降过程中记录在栈中的信息完成的。</li><li>在每一层，被压入栈的节点是该层被检查过的最右侧节点。</li><li>考虑在将某个节点 n 压入栈和回溯时再次访问该节点之间可能发生的情况：该节点可能已经分裂过一次或多次，这些分裂会在节点 n 的“右侧”产生新的节点。</li><li>由于节点 n 右侧的所有节点都可以通过 link 指针访问，因此插入算法能够找到适当的位置插入值。</li></ul><p>第四部分。如果进程 I’ 试图在节点 n 上进行插入，它会尝试锁定该节点。但进程 I 已经持有节点 n 的锁。最终，I 会释放该锁，I’ 再锁定该节点并将其读入内存。根据上面的引理，该交互是正确的，因为 I’ 的读取发生在 I 的插入之前。节点 n 要么就是插入的正确位置——此时 I’ 会执行插入；要么搜索必须沿节点的 link 指针访问其右兄弟。</p><h3 id="LiveLock"><a href="#LiveLock" class="headerlink" title="LiveLock"></a>LiveLock</h3><p>我们在此指出，我们的算法并不能完全避免活锁(LiveLock)的可能性（即某个进程无限运行）。<br>如果一个进程因为不断跟随其他进程创建的 link 指针而无法终止，就可能发生这种情况。<br>然而，根据以下观察，我们认为在实际实现中这种情况极不可能成为问题。<br>在多处理器系统中，如果该进程运行在相对非常慢的处理器上，这种情况可能发生。</p><p>(1) 在我们所知的大多数系统中，处理器的运行速度大致相当。<br>(2) 在 B 树中，节点的创建和删除只占很小的比例，因此即使是较慢的处理器，也不太可能因节点的创建或删除而遇到困难（也就是说，它只需要跟随少量的 link 指针）。<br>(3) 在树的任意给定层上，只能创建固定数量的节点，从而限制了较慢处理器需要“追赶”的量。  </p><p>我们认为，这些想法结合起来可以使实际系统中进程发生活锁的概率几乎为零（除非涉及的进程速度差异极大）。模拟可以帮助我们验证系统在“合理”条件下能够正常工作，并帮助确定进程相对速度的可接受范围。</p><p>在进程速度确实存在极大差异的情况下，我们可能会引入一些额外机制来防止活锁。实现这种机制有多种选择。本文不讨论避免活锁的完整方法，但其中一种方法可能是为每个进程分配优先级，优先级可能基于进程的“存在时间”。这将保证每个进程最终会终止，因为它最终会成为最“老”的进程，从而成为拥有最高优先级的进程。</p><h2 id="7-DELETION"><a href="#7-DELETION" class="headerlink" title="7. DELETION"></a>7. DELETION</h2><p>一种处理删除操作的简单方法是允许叶子节点中的条目少于 K 个。对于非叶子节点则不需要这样做，因为删除操作仅会移除叶子节点中的键；非叶子节点中的键仅作为其对应指针的上界，它在删除过程中并不会被移除。</p><p>因此，为了从叶子节点中删除一个条目，我们对该节点执行的操作与插入操作（尤其是插入情况 1）非常类似。具体来说，我们首先搜索出值 u 所在的节点，然后锁定该节点，将其读入内存，对内存中的副本删除值 u 后再将节点重写回磁盘。有时，这样会导致节点中条目数量少于 K。<br>该算法的正确性证明与插入操作类似。例如，死锁自由性的证明非常简单，因为删除操作只需要锁定一个节点。对于操作的正确性，如果一个搜索进程在删除值 u 之前读取了节点，它仍然会报告节点中存在 u，这与序列化调度（搜索操作先于删除操作执行）是一致的，因此搜索结果仍然正确。</p><p>我们刚描述的这种删除处理方法比需要处理节点下溢（underflow）和合并（concatenation）的方案要简单得多。在假设插入操作发生频率高于删除操作的情况下，这种方法几乎不需要额外存储空间。</p><p>当然，在删除操作过多导致树节点存储利用率过低的情况下，可以执行批量重组（batch reorganization）或者全树锁定的下溢操作（underflow operation）来重新组织树结构，以保证空间的合理利用。</p><h2 id="8-锁定效率（LOCKING-EFFICIENCY）"><a href="#8-锁定效率（LOCKING-EFFICIENCY）" class="headerlink" title="8. 锁定效率（LOCKING EFFICIENCY）"></a>8. 锁定效率（LOCKING EFFICIENCY）</h2><p>显然，在并发方案中，至少需要一个锁，以防止不同进程同时更新同一个节点。</p><p>上文给出的插入操作方案，在任何时刻对任意进程使用的锁数量最多是一个常数（最多三个）。这种情况仅在特定情况下发生：当插入进程刚刚向某个节点（叶子节点或非叶子节点）插入条目，并导致该节点分裂时。在回溯树的过程中，为了向新分裂节点的一半插入指针，插入进程发现旧的父节点已经不再是正确的插入位置，因此必须沿包含父节点的这一层节点进行链式查找，以找到正确的插入位置。在整个操作过程中，同时锁定三个节点。</p><p>在每个节点容量较大的 B*-树中，这种类型的锁定操作发生的频率非常低。因此，除非有大量并发进程运行，否则该结构的锁冲突概率极低。</p><p>这种系统的行为可以通过模拟进行量化，模拟参数包括并发进程数量、每个节点的容量，以及搜索、插入和删除操作的相对频率。这样的模拟不仅可以评估当前方案的性能，也可用于与其他并发控制方案进行比较。</p><h2 id="9-SUMMARY-AND-CONCLUSIONS"><a href="#9-SUMMARY-AND-CONCLUSIONS" class="headerlink" title="9. SUMMARY AND CONCLUSIONS"></a>9. SUMMARY AND CONCLUSIONS</h2><p>B 树在维护大型数据库时被发现非常有用。并发操作这样的数据具有明显优势，因为它允许多个用户同时共享数据；而且在大规模数据库中，用户的数据需求通常不会产生冲突，因此并发访问是可行的。</p><p>本文给出了一个算法，可以在 B 树的一种变体上执行正确的并发操作。该算法的特点是任意进程在任何时刻只需使用少量常数个锁。算法本身非常直接，其流程与顺序执行的算法仅有轻微差别。（可以通过模拟来量化本文算法与顺序算法或其他并发算法相比的效率提升。）</p><p>这一性能的实现依赖于对数据结构的一个小改动，使得当一个进程的位置因其他进程的操作而失效时，能够进行恢复（参见 [8]）。</p><p>我们希望将这项工作扩展到更通用的并发数据库操作方案。理想的方案应当仅需对数据结构和顺序算法做极少量修改，同时能够保证当其他进程对数据结构做出改变使某进程的操作失效时，该进程能够正确恢复。</p><p>另一条未来研究方向是对算法的“并行化”：研究将一个（已充分理解的）顺序算法转换为并发算法的通用方法。目标是尽可能充分利用问题的并发特性，同时保证算法的正确性不受影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Lehman–Yao-B-Trees&quot;&gt;&lt;a href=&quot;#1-Lehman–Yao-B-Trees&quot; class=&quot;headerlink&quot; title=&quot;1. Lehman–Yao B*-Trees&quot;&gt;&lt;/a&gt;1. Lehman–Yao B*-Trees&lt;/</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
    <category term="paper" scheme="https://jeffrey-fly-github-io.pages.dev/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>an_example_of_using_pageinspect</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/11/13/postgresql/an-example-of-using-pageinspect/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/11/13/postgresql/an-example-of-using-pageinspect/</id>
    <published>2025-11-13T06:52:14.000Z</published>
    <updated>2025-12-30T08:39:12.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备表数据"><a href="#准备表数据" class="headerlink" title="准备表数据"></a>准备表数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">create table</span> users(id <span class="type">int</span> generated always <span class="keyword">as</span> <span class="keyword">identity</span> <span class="keyword">primary key</span>, name text);</span><br><span class="line"><span class="keyword">CREATE TABLE</span></span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> oid, relname, relfilenode <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>;</span><br><span class="line">  oid  <span class="operator">|</span> relname <span class="operator">|</span> relfilenode </span><br><span class="line"><span class="comment">-------+---------+-------------</span></span><br><span class="line"> <span class="number">40980</span> <span class="operator">|</span> users   <span class="operator">|</span>       <span class="number">40980</span></span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> c.oid, c.relname, i.indisprimary <span class="keyword">from</span> pg_class c <span class="keyword">join</span> pg_index i <span class="keyword">on</span> c.oid <span class="operator">=</span> i.indexrelid <span class="keyword">where</span> i.indrelid <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>::regclass <span class="keyword">and</span> i.indisprimary;</span><br><span class="line">  oid  <span class="operator">|</span>  relname   <span class="operator">|</span> indisprimary </span><br><span class="line"><span class="comment">-------+------------+--------------</span></span><br><span class="line"> <span class="number">40986</span> <span class="operator">|</span> users_pkey <span class="operator">|</span> t</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">ERROR:  block number <span class="number">0</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">for</span> relation &quot;users&quot;</span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">ERROR:  block number <span class="number">1</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span></span><br><span class="line">test<span class="operator">=</span># <span class="operator">^</span>C</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="insert-values"><a href="#insert-values" class="headerlink" title="insert values"></a>insert values</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">insert into</span> users(name) <span class="keyword">values</span>(<span class="string">&#x27;jeffrey&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_len <span class="operator">|</span>           t_data           </span><br><span class="line"><span class="comment">----+--------+----------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>     <span class="number">36</span> <span class="operator">|</span> \x01000000116a656666726579</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> itemoffset <span class="operator">|</span> ctid  <span class="operator">|</span> itemlen <span class="operator">|</span> nulls <span class="operator">|</span> vars <span class="operator">|</span>          data           <span class="operator">|</span> dead <span class="operator">|</span> htid  <span class="operator">|</span> tids </span><br><span class="line"><span class="comment">------------+-------+---------+-------+------+-------------------------+------+-------+------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> </span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> page_header(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">    lsn     <span class="operator">|</span> checksum <span class="operator">|</span> flags <span class="operator">|</span> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize <span class="operator">|</span> version <span class="operator">|</span> prune_xid </span><br><span class="line"><span class="comment">------------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span><span class="operator">/</span><span class="number">03</span>F5E7A0 <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span>    <span class="number">28</span> <span class="operator">|</span>  <span class="number">8152</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>         <span class="number">0</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test<span class="operator">=</span># <span class="keyword">insert into</span> users(name) <span class="keyword">values</span>(<span class="string">&#x27;Ethan&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> page_header(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line">    lsn     <span class="operator">|</span> checksum <span class="operator">|</span> flags <span class="operator">|</span> lower <span class="operator">|</span> upper <span class="operator">|</span> special <span class="operator">|</span> pagesize <span class="operator">|</span> version <span class="operator">|</span> prune_xid </span><br><span class="line"><span class="comment">------------+----------+-------+-------+-------+---------+----------+---------+-----------</span></span><br><span class="line"> <span class="number">0</span><span class="operator">/</span><span class="number">03</span>F62810 <span class="operator">|</span>        <span class="number">0</span> <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span>    <span class="number">32</span> <span class="operator">|</span>  <span class="number">8112</span> <span class="operator">|</span>    <span class="number">8192</span> <span class="operator">|</span>     <span class="number">8192</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>         <span class="number">0</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> lp,lp_len,t_data <span class="keyword">from</span> heap_page_items(get_raw_page(<span class="string">&#x27;users&#x27;</span>, <span class="number">0</span>));</span><br><span class="line"> lp <span class="operator">|</span> lp_len <span class="operator">|</span>           t_data           </span><br><span class="line"><span class="comment">----+--------+----------------------------</span></span><br><span class="line">  <span class="number">1</span> <span class="operator">|</span>     <span class="number">36</span> <span class="operator">|</span> \x01000000116a656666726579</span><br><span class="line">  <span class="number">2</span> <span class="operator">|</span>     <span class="number">34</span> <span class="operator">|</span> \x020000000d457468616e</span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br><span class="line">test<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bt_page_items(<span class="string">&#x27;users_pkey&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"> itemoffset <span class="operator">|</span> ctid  <span class="operator">|</span> itemlen <span class="operator">|</span> nulls <span class="operator">|</span> vars <span class="operator">|</span>          data           <span class="operator">|</span> dead <span class="operator">|</span> htid  <span class="operator">|</span> tids </span><br><span class="line"><span class="comment">------------+-------+---------+-------+------+-------------------------+------+-------+------</span></span><br><span class="line">          <span class="number">1</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">1</span>) <span class="operator">|</span> </span><br><span class="line">          <span class="number">2</span> <span class="operator">|</span> (<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span> f     <span class="operator">|</span> f    <span class="operator">|</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="operator">|</span> f    <span class="operator">|</span> (<span class="number">0</span>,<span class="number">2</span>) <span class="operator">|</span> </span><br><span class="line">(<span class="number">2</span> <span class="keyword">rows</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备表数据&quot;&gt;&lt;a href=&quot;#准备表数据&quot; class=&quot;headerlink&quot; title=&quot;准备表数据&quot;&gt;&lt;/a&gt;准备表数据&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="postgresql" scheme="https://jeffrey-fly-github-io.pages.dev/categories/postgresql/"/>
    
    
    <category term="learn" scheme="https://jeffrey-fly-github-io.pages.dev/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>install_oceanbase</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/11/11/database/install-oceanbase/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/11/11/database/install-oceanbase/</id>
    <published>2025-11-11T12:23:40.000Z</published>
    <updated>2025-12-30T07:56:30.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>To build OceanBase from source code, you need to install the C++ toolchain in your development environment first. If the C++ toolchain is not installed yet, you can follow the instructions in this document for installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git wget rpm rpm2cpio cpio make build-essential binutils m4</span><br></pre></td></tr></table></figure><h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>Clone the source code to your development machine:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oceanbase/oceanbase.git</span><br></pre></td></tr></table></figure><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>Build OceanBase from the source code in debug mode or release mode:</p><h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash build.sh debug --init --make</span><br></pre></td></tr></table></figure><h3 id="Release-mode"><a href="#Release-mode" class="headerlink" title="Release mode"></a>Release mode</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash build.sh release --init --make</span><br></pre></td></tr></table></figure><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>Now that you built the observer binary, you can deploy an OceanBase instance with the obd.sh utility:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tools/deploy/obd.sh prepare -p /tmp/obtest</span><br><span class="line">./tools/deploy/obd.sh deploy -c ./tools/deploy/single.yaml</span><br></pre></td></tr></table></figure><p>You can check the mysql_port in .&#x2F;tools&#x2F;deploy&#x2F;single.yaml file to see the listening port. Normally, if you deploy with the root user, the OceanBase server will listen on port 10000, and the examples below are also based on this port.</p><h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>You can use the official MySQL client to connect to OceanBase:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P10000</span><br></pre></td></tr></table></figure><p>Alternatively, you can use the obclient to connect to OceanBase:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="operator">/</span>deps<span class="operator">/</span><span class="number">3</span>rd<span class="operator">/</span>u01<span class="operator">/</span>obclient<span class="operator">/</span>bin<span class="operator">/</span>obclient <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P10000 <span class="operator">-</span>uroot <span class="operator">-</span>Doceanbase <span class="operator">-</span>A</span><br></pre></td></tr></table></figure><h2 id="Shutdown"><a href="#Shutdown" class="headerlink" title="Shutdown"></a>Shutdown</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/deploy/obd.sh destroy --<span class="built_in">rm</span> -n single</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisites&quot;&gt;&lt;a href=&quot;#Prerequisites&quot; class=&quot;headerlink&quot; title=&quot;Prerequisites&quot;&gt;&lt;/a&gt;Prerequisites&lt;/h2&gt;&lt;p&gt;To build OceanBase from so</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>SSTables and LSM Trees</title>
    <link href="https://jeffrey-fly-github-io.pages.dev/2025/11/08/database/SSTables-and-LSM-Trees/"/>
    <id>https://jeffrey-fly-github-io.pages.dev/2025/11/08/database/SSTables-and-LSM-Trees/</id>
    <published>2025-11-08T05:15:45.000Z</published>
    <updated>2025-12-30T07:56:30.285Z</updated>
    
    <content type="html"><![CDATA[<p>SSTables：Sorted String Table ： 每个segment文件中key值是有序（根据key值排序）并且唯一的。sstable有如下优势：</p><ul><li>merge简单高效</li><li>因为有序，不需要维护所有记录的索引，可以是稀疏索引</li><li>因为有序，可以按block进行压缩同时维护索引，除了降低磁盘占用以外，还可以降低磁盘io</li></ul><h2 id="构建和管理SSTables"><a href="#构建和管理SSTables" class="headerlink" title="构建和管理SSTables"></a>构建和管理SSTables</h2><p>因为写入是无序的，所以我们需要在内存中借助于红黑树或者avl树等数据结构来保证：任意写入，有序读取.</p><p>构建步骤如下:</p><ol><li>当写入发生时，将写入的key-value加入内存平衡树（如红黑树）中，称为”memtable”</li><li>当memtable增大到一定阈值后（a few megabytes），将memtable写入磁盘生成一个SSTable文件。新写入的SSTable成为数据库中最新的segment文件。 写入SSTable到磁盘时，写入可以继续写入新的memtable</li><li>读请求来时，优先在memtable中查找，然后按顺序从新到老查找磁盘上的segment文件</li><li>随着时间的推移，可以后台启动合并和压缩segment文件、丢弃或者覆盖掉老的文件</li></ol><p>这种机制工作的很好，但是存在一个问题，如果数据库宕机了，内存中的memtable还没有来得及写入磁盘，可能造成数据丢失。可以通过一个单独的log文件来记录所有的操作，这个log的作用只是用于宕机恢复memtable，每当memtable被写入磁盘，相应的log文件就可以被丢弃了</p><h2 id="用SSTables构建LSM-tree"><a href="#用SSTables构建LSM-tree" class="headerlink" title="用SSTables构建LSM-tree"></a>用SSTables构建LSM-tree</h2><p>LSM-Tree用于 LevelDB 和 RocksDB、嵌入其他应用的key-value存储引擎。参考：Google’s Bigtable paper</p><p>SSTables + log &#x3D; “Log-Structured Merge-Tree ”</p><h3 id="LSM-tree两种文件管理策略："><a href="#LSM-tree两种文件管理策略：" class="headerlink" title="LSM-tree两种文件管理策略："></a>LSM-tree两种文件管理策略：</h3><ol><li><p>Size-Tiered Compaction（STC） </p><ul><li><p>基本思想<br>  “当某一层（或同一大小区间）的 SSTable 文件数达到阈值时，将它们合并成一个更大的文件。”<br> 也就是说，不是按“层级”，而是按“文件大小”来触发 compaction。</p></li><li><p>结构示意<br> MemTable → SSTable</p></li><li><p>优点</p><ul><li>写放大低<br>  每条数据在被 flush 后只会参与少数几次合并；每次合并是“几块 → 一块”，合并次数较少。</li><li>写入吞吐高<br>  flush 后直接落地；合并是批量异步进行；对写性能非常友好。</li></ul></li><li><p>缺点</p><ul><li>读放大高<br>  同一 key 可能存在于多个 SSTable 中；读时需要查多个文件（除非借助 Bloom Filter）。</li><li>空间放大高<br>  合并不够积极；多个旧版本的数据同时存在；临时文件和重复 key 较多。</li></ul></li><li><p>应用场景<br> 适合写多读少的场景；比如日志系统、时间序列数据库（TSDB）、写入密集的监控系统Cassandra 默认采用 STCS（Size-Tiered Compaction Strategy）</p></li></ul></li><li><p>Level Compaction（LC）<br> 这种策略是 LevelDB、RocksDB 采用的，更现代化。又叫 leveled compaction 或 分层压实。</p><ul><li><p>基本思想：<br> 数据被组织成多个层级（Level 0, Level 1, Level 2…），每一层都有固定大小的空间限制，同一层内文件的 key 范围 互不重叠。</p></li><li><p>层次结构：<br> Level 0: 多个小 SSTable，key 范围可能重叠。<br> Level 1: 较大文件，key 范围不重叠。<br> Level 2: 更大文件，key 范围不重叠。<br> …</p></li><li><p>Compaction 逻辑：<br> 当某一层（如 Level 0）容量超标；就选择一个 SSTable（或一组）与下一层（如 Level 1）中 key 范围重叠的文件；合并、去重、重写为更大的 SSTable，放入下一层。</p></li><li><p>优点</p><ul><li>读性能优异<br>  除 Level 0 外，其余层内文件 key 范围不重叠；读取某个 key 只需查找每层最多一个文件；查找代价从 O(n_files) 降到 O(levels)。</li><li>空间利用率高<br>  去重及时；每层占用空间接近固定比例；不容易膨胀。</li></ul></li><li><p>缺点</p><ul><li>写放大高<br>  每条数据会多次参与合并（从 L0 → L1 → L2…）；每次都要重写到下一层； 磁盘写入量是原始写入的数倍。</li><li>Compaction 代价大<br>  大文件之间的合并非常消耗 I&#x2F;O；RocksDB 必须限制后台 compaction 线程数量。</li></ul></li><li><p>应用场景<br> 适合读写比较均衡、查询多的系统；比如 RocksDB、LevelDB、TiKV、ClickHouse 的部分引擎。</p></li></ul></li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>当查找的key在数据库中不存在时，LSM-Tree算法可能会变慢：在你确认key不存在之前，你需要检查所有memtable，所有sstable对应的磁盘文件。可以使用bloom filters：它可以检查key不在数据库中（每个sstable固化时，生成对应的bloom filter文件）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SSTables：Sorted String Table ： 每个segment文件中key值是有序（根据key值排序）并且唯一的。sstable有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;merge简单高效&lt;/li&gt;
&lt;li&gt;因为有序，不需要维护所有记录的索引，可以是稀疏索引</summary>
      
    
    
    
    <category term="database" scheme="https://jeffrey-fly-github-io.pages.dev/categories/database/"/>
    
    
    <category term="storage" scheme="https://jeffrey-fly-github-io.pages.dev/tags/storage/"/>
    
  </entry>
  
</feed>
